{"meta":{"title":"DataScience","subtitle":"","description":"","author":"JackFeng","url":"http://www.a2data.cn","root":"/"},"pages":[{"title":"404 Not Found","date":"2021-01-24T14:21:18.498Z","updated":"2020-08-01T03:24:02.867Z","comments":true,"path":"404.html","permalink":"http://www.a2data.cn/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2020-09-11T09:55:13.993Z","updated":"2020-09-11T09:55:13.993Z","comments":true,"path":"README.html","permalink":"http://www.a2data.cn/README.html","excerpt":"","text":"A2DataDataScience 公众号 博客站点！"},{"title":"","date":"2025-05-04T12:21:04.612Z","updated":"2022-07-12T14:44:20.987Z","comments":true,"path":"about/index.html","permalink":"http://www.a2data.cn/about/index.html","excerpt":"关于我 var binft = function (r) { function t() { return b[Math.floor(Math.random() * b.length)] } function e() { return String.fromCharCode(94 * Math.random() + 33) } function n(r) { for (var n = document.createDocumentFragment(), i = 0; r > i; i++) { var l = document.createElement(\"span\"); l.textContent = e(), l.style.color = t(), n.appendChild(l) } return n } function i() { var t = o[c.skillI]; c.step ? c.step-- : (c.step = g, c.prefixP < l.length ? (c.prefixP >= 0 && (c.text += l[c.prefixP]), c.prefixP++) : \"forward\" === c.direction ? c.skillP < t.length ? (c.text += t[c.skillP], c.skillP++) : c.delay ? c.delay-- : (c.direction = \"backward\", c.delay = a) : c.skillP > 0 ? (c.text = c.text.slice(0, -1), c.skillP--) : (c.skillI = (c.skillI + 1) % o.length, c.direction = \"forward\")), r.textContent = c.text, r.appendChild(n(c.prefixP < l.length ? Math.min(s, s + c.prefixP) : Math.min(s, t.length - c.skillP))), setTimeout(i, d) } var l = \"\", o = [\"人生在勤，不索何获\", \"日日待明日,万事成蹉跎\", \"丈夫志四海，万里犹比邻\", \"还在看这里吗？\", \"能不能别看了？\", \"文章更精彩....\"].map(function (r) { return r + \"\" }), a = 2, g = 1, s = 5, d = 75, b = [\"rgb(110,64,170)\", \"rgb(150,61,179)\", \"rgb(191,60,175)\", \"rgb(228,65,157)\", \"rgb(254,75,131)\", \"rgb(255,94,99)\", \"rgb(255,120,71)\", \"rgb(251,150,51)\", \"rgb(226,183,47)\", \"rgb(198,214,60)\", \"rgb(175,240,91)\", \"rgb(127,246,88)\", \"rgb(82,246,103)\", \"rgb(48,239,130)\", \"rgb(29,223,163)\", \"rgb(26,199,194)\", \"rgb(35,171,216)\", \"rgb(54,140,225)\", \"rgb(76,110,219)\", \"rgb(96,84,200)\"], c = { text: \"\", prefixP: -s, skillI: 0, skillP: 0, direction: \"forward\", delay: a, step: g }; i() }; binft(document.getElementById('author-one'));","text":"关于我 var binft = function (r) { function t() { return b[Math.floor(Math.random() * b.length)] } function e() { return String.fromCharCode(94 * Math.random() + 33) } function n(r) { for (var n = document.createDocumentFragment(), i = 0; r > i; i++) { var l = document.createElement(\"span\"); l.textContent = e(), l.style.color = t(), n.appendChild(l) } return n } function i() { var t = o[c.skillI]; c.step ? c.step-- : (c.step = g, c.prefixP < l.length ? (c.prefixP >= 0 && (c.text += l[c.prefixP]), c.prefixP++) : \"forward\" === c.direction ? c.skillP < t.length ? (c.text += t[c.skillP], c.skillP++) : c.delay ? c.delay-- : (c.direction = \"backward\", c.delay = a) : c.skillP > 0 ? (c.text = c.text.slice(0, -1), c.skillP--) : (c.skillI = (c.skillI + 1) % o.length, c.direction = \"forward\")), r.textContent = c.text, r.appendChild(n(c.prefixP < l.length ? Math.min(s, s + c.prefixP) : Math.min(s, t.length - c.skillP))), setTimeout(i, d) } var l = \"\", o = [\"人生在勤，不索何获\", \"日日待明日,万事成蹉跎\", \"丈夫志四海，万里犹比邻\", \"还在看这里吗？\", \"能不能别看了？\", \"文章更精彩....\"].map(function (r) { return r + \"\" }), a = 2, g = 1, s = 5, d = 75, b = [\"rgb(110,64,170)\", \"rgb(150,61,179)\", \"rgb(191,60,175)\", \"rgb(228,65,157)\", \"rgb(254,75,131)\", \"rgb(255,94,99)\", \"rgb(255,120,71)\", \"rgb(251,150,51)\", \"rgb(226,183,47)\", \"rgb(198,214,60)\", \"rgb(175,240,91)\", \"rgb(127,246,88)\", \"rgb(82,246,103)\", \"rgb(48,239,130)\", \"rgb(29,223,163)\", \"rgb(26,199,194)\", \"rgb(35,171,216)\", \"rgb(54,140,225)\", \"rgb(76,110,219)\", \"rgb(96,84,200)\"], c = { text: \"\", prefixP: -s, skillI: 0, skillP: 0, direction: \"forward\", delay: a, step: g }; i() }; binft(document.getElementById('author-one')); 已过期!!!"},{"title":"archives","date":"2020-07-31T15:11:22.000Z","updated":"2020-07-31T15:11:22.852Z","comments":true,"path":"archives/index.html","permalink":"http://www.a2data.cn/archives/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2020-08-01T03:20:39.634Z","updated":"2020-08-01T03:20:39.634Z","comments":true,"path":"categories/index.html","permalink":"http://www.a2data.cn/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-08-03T09:52:03.000Z","updated":"2020-09-14T12:23:47.743Z","comments":true,"path":"books/index.html","permalink":"http://www.a2data.cn/books/index.html","excerpt":"","text":"书籍推荐 2020-09-12 1.21 -&gt; 1.22 如果有 喜欢的文章 ，点击 按钮 。请输入你的真实邮箱,按照以下格式留言&lt;details cyan&gt;&lt;summary&gt; &lt;p&gt;相关主题&lt;/p&gt; &lt;/summary&gt; &lt;div class=&#39;content&#39;&gt; &lt;div class=&quot;btns circle grid5&quot;&gt; &lt;a class=&quot;button&quot; href=&#39;书籍地址&#39; title=&#39;书籍名称&#39;&gt;&lt;img src=&#39;书籍封面&#39;&gt;书籍名称&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/details&gt;欢迎贡献更多好书 。 2020-09-10 1.2 -&gt; 1.21 特殊节日: 长大方知少年纯、回首才懂师恩深 2020-08-20 1.0-&gt; 1.2 推、荐、微、信、读、书。 如何找书 快速找书https://weread.qq.com/#search 技术书籍好书推荐学习使我快乐 Python相关 Python编程：从入门到实践利用Python进行数据分析（原书第2版）超简单：用Python让Excel飞起来Python Qt GUI与数据可视化编程Python网络爬虫从入门到实践 Spark相关 Spark SQL入门与实践指南Spark大数据分析实战Spark全栈数据分析 推荐 价值：我对投资的思考"},{"title":"","date":"2025-05-04T18:37:40.559Z","updated":"2025-05-04T18:37:40.559Z","comments":true,"path":"friends/index.html","permalink":"http://www.a2data.cn/friends/index.html","excerpt":"","text":"友情链接 友链更新通知 关于本站添加友链 本站信息 本站开通自助友链,请根据相关要求自己添加即可。 请优先添加本站链接。如下信息。 小编微信：a2data十年之约 开源社区 ，请点击 加入 。{ &quot;title&quot;: &quot;DataScience&quot;, &quot;description&quot;: &quot;放弃不难，但坚持一定很酷&quot;, &quot;screenshot&quot;: &quot;https://ds.ipyingshe.net/datascience/2025/05/05/0e4b344a04092.png&quot;, &quot;url&quot;: &quot;www.a2data.cn&quot;, &quot;avatar&quot;: &quot;https://ds.ipyingshe.net/datascience/2025/05/05/3694a41d52ade.jpg&quot;, &quot;version&quot;: &quot;十年之约&quot;} 如何交换友链？ 互换博客，要求原创不低于20篇。长期维护者优先。请根据根据自己内容选择对应模板填写。添加完成之后，请刷新页面即可。 添加 您的链接 ，请点击 按钮 。按照格式填写并提交。 { &quot;title&quot;: &quot;博客名&quot;, &quot;description&quot;: &quot;描述&quot;, &quot;screenshot&quot;: &quot;背景图&quot;, &quot;url&quot;: &quot;博客链接&quot;, &quot;avatar&quot;: &quot;作者头像&quot;, &quot;version&quot;: &quot;分类&quot; } 为了提高图片加载速度，建议优化头像和截图： 打开 压缩图 上传自己的头像，将图片尺寸调整到 96px 后下载。将压缩后的图片上传到 sm.ms 。 图床 并使用此图片链接作为头像。重复上述步骤，把压缩网站截图并把尺寸调整到 540x360 以下。 请添加本站到您的友链中，如果您也使用 issue 作为友链源，只需要告知您的友链源仓库即可。"},{"title":"","date":"2020-08-01T03:57:10.000Z","updated":"2020-09-14T12:23:47.725Z","comments":true,"path":"contact/index.html","permalink":"http://www.a2data.cn/contact/index.html","excerpt":"","text":"噫，你来了：欢迎留言哦 查看留言规则 1、 直接输入QQ号即可自动补全邮箱哦2、 你有好的想法或者建议可以加小编微信哦,(来源备注博客) a2xf6693、 拒绝垃圾评论！"},{"title":"","date":"2020-08-03T10:43:31.000Z","updated":"2020-09-14T12:23:47.741Z","comments":true,"path":"movies/index.html","permalink":"http://www.a2data.cn/movies/index.html","excerpt":"","text":"视频推荐 Audio Your browser does not support the video tag."},{"title":"所有标签","date":"2020-08-01T03:20:49.302Z","updated":"2020-08-01T03:20:49.302Z","comments":true,"path":"tags/index.html","permalink":"http://www.a2data.cn/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-08-03T12:30:41.000Z","updated":"2020-09-14T12:23:47.738Z","comments":true,"path":"tools/index.html","permalink":"http://www.a2data.cn/tools/index.html","excerpt":"","text":"》 这里为大家推荐常用软件 以及下载链接"}],"posts":[{"title":"数据可视化-艺术字","slug":"Python/数据可视化/数据可视化-艺术字","date":"2021-01-26T15:33:01.000Z","updated":"2025-05-04T18:37:40.538Z","comments":true,"path":"posts/818bed05.html","link":"","permalink":"http://www.a2data.cn/posts/818bed05.html","excerpt":"数据可视化之艺术字","text":"数据可视化之艺术字 Python绘制-艺术字matplotlib 还是使用我们熟悉的 matplotlib 来绘制。 发现不出图 解决方案matplotlib画图在jupyter notebook中不显示 需要注意的是：每次单独绘制完成之后 需要点击关闭，否则后续会增加进来的。 开头加%matplotlib notebook 确保fig,ax = plt.subplots()与plt.show在一个cell执行，不能放到两个cell里 1、绘制文字# DataSicnece 与2021.1.25 测试 # 解决不出图 %matplotlib notebook import matplotlib.pyplot as plt import matplotlib.patheffects as path_effects #解决中文乱码问题 plt.rcParams[&quot;font.sans-serif&quot;] = [&quot;SimHei&quot;] #解决负号显示问题 plt.rcParams[&quot;axes.unicode_minus&quot;] = False #设置图的大小 fig = plt.figure(figsize=(5,1.5)) #设置字在图片中显示的位置,宽和高的百分比，距离图左上角顶点的距离 text = fig.text(0.5,0.5,u&quot;hello DataScience\\nmatplotlib\\n 小丑竟是我自己！&quot;, ha=&quot;center&quot;,va=&quot;center&quot;,size=20) #设置正常字体显示 text.set_path_effects([path_effects.Normal()]) plt.show() 2、绘制阴影效果#设置字体带有阴影 text = plt.text(0.5,0.5,&quot;小丑竟是我自己&quot;, path_effects=[path_effects.withSimplePatchShadow()]) #通过设置一个列表的path_effects，来间隔显示不同的效果 plt.plot([0,4,2,6],linewidth=5,color=&quot;green&quot;, path_effects=[path_effects.SimpleLineShadow(),path_effects.Normal()]) plt.show() 3、艺术字Ifig = plt.figure(figsize=(5,2)) text = fig.text(0.5,0.5,&quot;小丑竟是我自己&quot;, color=&quot;white&quot;,ha=&quot;center&quot;,va=&quot;center&quot;,size=30) text.set_path_effects([path_effects.Stroke(linewidth=5,foreground=&quot;blue&quot;),path_effects.Normal()]) plt.show() 4、艺术字IIfig = plt.figure(figsize=(10,2)) t = fig.text(0.02,0.5,&quot;小丑竟是我自己&quot;,fontsize=75,weight=1000,va=&quot;center&quot;) t.set_path_effects([ path_effects.PathPatchEffect(offset=(4,-4),hatch=&quot;***&quot;,facecolor=&quot;grey&quot;), path_effects.PathPatchEffect(edgecolor=&quot;white&quot;,linewidth=1.1,facecolor=&quot;blue&quot;) ]) plt.show()","categories":[],"tags":[{"name":"数据可视化","slug":"数据可视化","permalink":"http://www.a2data.cn/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"}]},{"title":"数据可视化矢量库Pygal","slug":"Python/数据可视化/数据可视化之Pygal矢量库","date":"2021-01-19T09:25:11.000Z","updated":"2025-05-05T05:47:55.845Z","comments":true,"path":"posts/6a4da3dd.html","link":"","permalink":"http://www.a2data.cn/posts/6a4da3dd.html","excerpt":"数据可视化之矢量库 Pygal。","text":"数据可视化之矢量库 Pygal。 Pygal官方文档http://www.pygal.org/ 这次介绍一个不那么广为人知但依然优秀的可视化库-Pygal。 最好得学习方式就是官方文档。 大家多多支持官方，引用得也要著名出处。 官网介绍说Pygal是一个性感的Python制表工具，提供了14种图表类型，可以轻松定制出版级别的交互式图表。 1、安装Pygal 2、引用# 导入包引用 import pygal # 使用步骤 1.生成图像对象 2.导入数据|自己new一个数据 3.导出图像结果 3、柱状图# 官方案例 pygal.Bar()(1, 3, 3, 7)(1, 6, 6, 4).render() 数据来源，近期文章阅读。第一次运行，发现少包 ModuleNotFoundError: No module named ‘cairosvg’ 原因是因为，png转 svg 没有安装依赖。 找不到cairo解决方案： pip install cairosvg 再次运行： 纳尼？ 又错了？ 不要慌，我们慢慢解决它。 OSError: no library called &quot;cairo&quot; was found no library called &quot;libcairo-2&quot; was found cannot load library &#39;libcairo.so.2&#39;: error 0x7e cannot load library &#39;libcairo.2.dylib&#39;: error 0x7e cannot load library &#39;libcairo-2.dll&#39;: error 0x7e OSError: no library called “cairo” was found 怎么解决 前往：https://github.com/tschoonj/GTK-for-Windows-Runtime-Environment-Installer 安装： 重启，基本上就解决了问题。 But，在jupyter notebook 中 看到得是xml文件。 如果想输出看的话 必须是在浏览器中查看。否则即使安装了也会报错。 正确打开方式# 可以看到 我们把文件保存为 bar_wx.svg # 图表命名 bar.title = &#39;Ds近期文章阅读数&#39; # 添加数据 bar.add(&#39;第一篇&#39;,700) bar.add(&#39;第二篇&#39;,708) bar.add(&#39;第三篇&#39;,628) bar.add(&#39;第四篇&#39;,571) bar.add(&#39;第五篇&#39;,561) bar.add(&#39;第六篇&#39;,447) bar.render_to_file(&#39;bar_wx.svg&#39;) 方式1：用浏览器打开svg 文件即可。 方式2： 将以下xml 代码复制粘贴到 编辑器中，即可查看。 HTML在线编辑器： https://c.runoob.com/front-end/61 叮咚，这样不用下载或者再次打开，也能看到了。 4、折线图# 折线图案例 line_chart = pygal.Line() line_chart.title = &#39;Browser usage evolution (in %)&#39; line_chart.x_labels = map(str, range(2011, 2020)) line_chart.add(&#39;Firefox&#39;, [None, None, 0, 16.6, 25, 31, 36.4, 45.5, 46.3, 42.8, 37.1]) line_chart.add(&#39;Chrome&#39;, [None, None, None, None, None, None, 0, 3.9, 10.8, 23.8, 35.3]) line_chart.add(&#39;IE&#39;, [85.8, 84.6, 84.7, 74.5, 66, 58.6, 54.7, 44.8, 36.2, 26.6, 20.1]) line_chart.add(&#39;Others&#39;, [14.2, 15.4, 15.3, 8.9, 9, 10.4, 8.9, 5.8, 6.7, 6.8, 7.5]) line_chart.render_to_file(&#39;bar_chart.svg&#39;) 5、XY 本案例来自官方 from math import cos xy_chart = pygal.XY() xy_chart.title = &#39;XY Cosinus&#39; xy_chart.add(&#39;x = cos(y)&#39;, [(cos(x / 10.), x / 10.) for x in range(-50, 50, 5)]) xy_chart.add(&#39;y = cos(x)&#39;, [(x / 10., cos(x / 10.)) for x in range(-50, 50, 5)]) xy_chart.add(&#39;x = 1&#39;, [(1, -5), (1, 5)]) xy_chart.add(&#39;x = -1&#39;, [(-1, -5), (-1, 5)]) xy_chart.add(&#39;y = 1&#39;, [(-5, 1), (5, 1)]) xy_chart.add(&#39;y = -1&#39;, [(-5, -1), (5, -1)]) xy_chart.render() 6、叠加测线from pygal.style import DefaultStyle chart = pygal.StackedLine(fill=True, interpolate=&#39;cubic&#39;, style=DefaultStyle) # Setting style here is not necessary chart.add(&#39;A&#39;, [1, 3, 5, 16, 13, 3, 7]) chart.add(&#39;B&#39;, [5, 2, 3, 2, 5, 7, 17]) chart.add(&#39;C&#39;, [6, 10, 9, 7, 3, 1, 0]) chart.add(&#39;D&#39;, [2, 3, 5, 9, 12, 9, 5]) chart.add(&#39;E&#39;, [7, 4, 2, 1, 2, 10, 0]) chart.render_to_file(&#39;Hello.svg&#39;) #生成svg文件 #这里指定将你的图表生成一个svg文件，如果不指定路径就保存在这个.py相同的路径下 #官网下的案例都是reder(),具体输出查看官网的output 7、饼图# 饼图 # 逐步解锁更多技能 pie_chart = pygal.Pie(inner_radius=.4) pie_chart.title = &#39;Ds目前技能树&#39; pie_chart.add(&#39;SQL&#39;, 19.5) pie_chart.add(&#39;Python&#39;, 36.6) pie_chart.add(&#39;数据可视化&#39;, 36.3) pie_chart.add(&#39;机器学习&#39;, 4.5) pie_chart.add(&#39;自动化&#39;, 2.3) pie_chart.render_to_file(&#39;pie.svg&#39;) 8、雷达图# 注，案例数据参考官方说明 radar_chart = pygal.Radar() radar_chart.title = &#39;V8 benchmark results&#39; radar_chart.x_labels = [&#39;Richards&#39;, &#39;DeltaBlue&#39;, &#39;Crypto&#39;, &#39;RayTrace&#39;, &#39;EarleyBoyer&#39;, &#39;RegExp&#39;, &#39;Splay&#39;, &#39;NavierStokes&#39;] radar_chart.add(&#39;Chrome&#39;, [6395, 8212, 7520, 7218, 12464, 1660, 2123, 8607]) radar_chart.add(&#39;Firefox&#39;, [7473, 8099, 11700, 2651, 6361, 1044, 3797, 9450]) radar_chart.add(&#39;Opera&#39;, [3472, 2933, 4203, 5229, 5810, 1828, 9013, 4669]) radar_chart.add(&#39;IE&#39;, [43, 41, 59, 79, 144, 136, 34, 102]) radar_chart.render() 9、箱线图# 注，案例数据参考官方说明 box_plot = pygal.Box() box_plot.title = &#39;V8 benchmark results&#39; box_plot.add(&#39;Chrome&#39;, [6395, 8212, 7520, 7218, 12464, 1660, 2123, 8607]) box_plot.add(&#39;Firefox&#39;, [7473, 8099, 11700, 2651, 6361, 1044, 3797, 9450]) box_plot.add(&#39;Opera&#39;, [3472, 2933, 4203, 5229, 5810, 1828, 9013, 4669]) box_plot.add(&#39;IE&#39;, [43, 41, 59, 79, 144, 136, 34, 102]) box_plot.render() 10、漏斗 11、环形图 12、计量 13、金字塔 14、矩形树图 15、地图 更多说明：http://www.pygal.org/en/latest/documentation/builtin_styles.html 欢迎大家一起学习，进步。发现更多可视化之美。","categories":[],"tags":[{"name":"数据可视化","slug":"数据可视化","permalink":"http://www.a2data.cn/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"}]},{"title":"数据可视化实战项目","slug":"Python/数据可视化/数据可视化实战","date":"2020-12-25T13:33:35.000Z","updated":"2025-05-05T06:12:46.390Z","comments":true,"path":"posts/b6595881.html","link":"","permalink":"http://www.a2data.cn/posts/b6595881.html","excerpt":"从零开始做个数据可视乎项目。","text":"从零开始做个数据可视乎项目。 数据可视化实战项目 NLP 数据可视化 request BeautifulSoup #爬虫所需 import requests from bs4 import BeautifulSoup # Nlp可视化所需包 import matplotlib.pyplot as plt from wordcloud import WordCloud import jieba import jieba.analyse import pandas 1、爬虫其实很简单 进入糗事百科 https://www.qiushibaike.com/text/ 这里以： 段子内容来说，其它类似同理的。 1、打开开发者模式什么是开发者模式呢？ 通常情况是方便前端开发调试页面 如何打开呢？ 方式： 浏览器右键，选择检查 ctrl + shift + i / F12 — windows option+command+I — Mac Request Headers 里面是我们用浏览器访问网站的信息，有了信息后就能模拟浏览器访问这也是为了防止网站封禁IP，不过糗事百科一般是不会封IP的，也是公开信息，仅用于学习。 2、模拟浏览器User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36 3、准备工作 杠精请绕道哦，这里说的是公开数据，不非法用途，仅用于学习，自然也就没有反爬啊 什么的。 不信，你来试试咯？ 所需模块： #requests是一个非常方便的模块。 pip install requests #Beautiful soup是另一个python的模块，我们将用这个模块来分解网页的结构，并对其中的内容进行提取。 pip install beautifulsoup4 小试牛刀 - 跟度娘问个好# 引入 request包 import requests r0 = requests.get(&#39;https://baidu.com&#39;) print(r0.text) 可能有的同学一开始这样爬会得到一个timeout的错误。如果出现了这样的情况，就是网站怀疑是一个机器人在访问自己，所以作出了一定的阻止。 那怎么办呢？没有关系，我们稍微修改一下我们的代码，改成 # headers的意思就是告诉网站，我们是一个正常的浏览器在给它发送信息，请它给我们正确的信息。 # Mac # headers = &#123;&#39;User-Agent&#39;: &#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36&#39;&#125; # 请求头部 # windows headers = &#123;&#39;user-agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36&#39;&#125; r0 = requests.get(&#39;https://baidu.com&#39;, headers = headers) content = r0.text print(content) 糗事百科段子1 网页爬取# 设定一个网址不变的部分，然后我们只要每次在这个后面加数字就可以了 base_url = &#39;https://www.qiushibaike.com/text/page/&#39; headers = &#123;&#39;User-Agent&#39;: &#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36&#39;&#125; r1 = requests.get(&#39;https://www.qiushibaike.com/text/&#39;, headers = headers) content = r1.text print(content) 接下来我们来分析网站的结构。 可能你也发现了，直接使用我们打印出来的结果分析起来十分吃力。所以我们使用更加高效的工具——开发者工具（Developer tools）来进行分析。通常来说任何一个浏览器都有开发者工具，这里我们以Chrome为例。 也就是我们上边所说的 开发者模式。 可以看到我们要的段子的内容就储存在这个叫做 span 的标签中。 我们再往上追寻，可以看到标签是属于一个叫做的标签的。继续往上我们可以看到一个叫做的标签。 所以很显然，我们只要把这样的标签都提取出来，我们就可以得到糗事百科中的段子了。 2 数据处理首先我们把我们需要的内容转换到Beautiful soup中。 # 引入Beautiful Soup包 from bs4 import BeautifulSoup # 把刚刚保存在content中的文件放入Beautiful Soup中 soup = BeautifulSoup(content, &#39;lxml&#39;) #首先我们分解出所有class为article block untagged mb15 typs_hot 标签： divs = soup.find_all(class_ = &#39;article block untagged mb15 typs_hot&#39;) 接下来我们要做的事情就是把这些div里面的span都取出来。 我们先把最后一行去掉，避免不必要的打印。然后提取出每个div里面的span # 取出每个div中的数据 for div in divs: joke = div.span.get_text() print(joke) print(&quot;------&quot;) 3 多页面数据完整代码,不到几十行的爬虫代码，你会了吗? #!/usr/bin/env python # -*- coding:utf-8 -*- __author__ = &#39;JackFeng&#39; # @Time : 20/12/20 23:18 # @Author : JackFeng # @FileName: pySprider.py # @Software: PyCharm # @Blog ：http://www.a2data.cn/ import requests from bs4 import BeautifulSoup &quot;&quot;&quot; # 所需要依赖包 pip install requests pip install beautifulsoup4 &quot;&quot;&quot; # 请求头部 headers = &#123; &#39;user-agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36&#39;&#125; # 设定一个网址不变的部分，然后我们只要每次在这个后面加数字就可以了 base_url = &#39;https://www.qiushibaike.com/text/page/&#39; # 设置循环，让num分别等于2-9 for num in range(2, 9): print(&#39;第&#123;&#125;页&#39;.format(num)) r1 = requests.get(base_url + str(num), headers = headers) #这里对网址进行一个修改 # 剩下的部分都是和原来的代码一样 content = r1.text # print(content) # 把刚刚保存在content中的文件放入Beautiful Soup中 soup = BeautifulSoup(content, &#39;lxml&#39;) divs = soup.find_all(class_=&#39;article block untagged mb15 typs_hot&#39;) # 我们可以打印出divs看看是什么样子的。 # print(divs) for div in divs: joke = div.span.get_text() print(joke) print(&quot;------&quot;) 2、数据挖掘1、数据存储根据爬取的数据，将数据存储下来。 为了做出更加好看，有趣，有用的可视化视图。 优化爬虫内容 增加 作者，评论数 ，好笑度 # -*- coding: utf-8 -*- from urllib import parse import requests from lxml import etree headers = &#123; &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36 Edg/87.0.664.66&#39;, &#39;Accept&#39;: &#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#39;, &#39;Referer&#39;: &#39;https://www.qiushibaike.com/text/&#39;, &#39;Accept-Language&#39;: &#39;zh-CN,zh;q=0.9,en;q=0.8&#39;, &#125; next_page = &quot;/text/page/1/&quot; while next_page: response = requests.get(url=parse.urljoin(&#39;https://www.qiushibaike.com&#39;, next_page), headers=headers) html = etree.HTML(response.content) infos = html.xpath(&quot;//div[contains(@class,&#39;article block untagged mb15&#39;)]&quot;) for one in infos: content = one.xpath(&quot;string(.//div[@class=&#39;content&#39;])&quot;) vote = one.xpath(&quot;.//div[@class=&#39;stats&#39;]/span[@class=&#39;stats-vote&#39;]//i/text()&quot;) vote = vote[0] if vote else 0 comments = one.xpath(&quot;.//div[@class=&#39;stats&#39;]/span[@class=&#39;stats-comments&#39;]//i/text()&quot;) comments = comments[0] if comments else 0 cmt_main = &quot;&quot;.join(one.xpath(&quot;.//div[@class=&#39;cmtMain&#39;]/div[@class=&#39;main-text&#39;]/text()&quot;)).strip() item = &#123; &quot;content&quot;: content.strip(), &quot;vote&quot;: vote, &quot;comments&quot;: comments, &quot;cmt_main&quot;: cmt_main, &#125; print(item) print(&quot;*&quot; * 100) #爬虫结果保存到文件wordCloud，供词云使用 with open(&#39;wordCloud.txt&#39;, &#39;a&#39;, encoding=&#39;utf-8&#39;) as a: a.write(item[&#39;content&#39;]) next_page = html.xpath(&quot;//span[@class=&#39;next&#39;]/../@href&quot;) next_page = next_page[0] if next_page else None print(next_page) 保存到wordCloud文件： 2、Nlp 分词 stopWords下载源自网络 + 自己更新了部分词汇 —— DsTeam Kath import pandas as pd import numpy import jieba #去除停用词 wordCount = open(&#39;wordCloud.txt&#39;,encoding=&#39;utf-8&#39;).read() stopwords = pd.read_csv(&#39;stopWords.txt&#39;,index_col=False,quoting=3,sep=&quot;\\t&quot;,names=[&#39;stopword&#39;], encoding=&#39;utf-8&#39;) #stopWords下载源自网络+自己更新了部分词汇 words=[] wordCount = jieba.lcut(wordCount) for word in wordCount: if len(word) &gt; 1 and word != &#39;\\r\\n&#39;: words.append(word) wordCount=pd.DataFrame(&#123;&#39;words&#39;:words&#125;) # print(wordCount.count()) wordCount=wordCount[~wordCount.words.isin(stopwords.stopword)] # 保留不在停用词词表中的词，即把包含在停用词表里的词语去掉 print(wordCount.count()) #统计词频 wordStat=wordCount.groupby(&#39;words&#39;).agg(计数=pd.NamedAgg(column=&#39;words&#39;, aggfunc=numpy.size)).reset_index().sort_values(by=&#39;计数&#39;, ascending=False) print(wordStat.head(20)) 3、数据可视化1、词云制作#安装词云库 pip install wordcloud # jieba nlp分词 pip install jieba #词云制作 from wordcloud import WordCloud,ImageColorGenerator import jieba import imageio f = open(&#39;wordCloud.txt&#39;,encoding=&#39;utf-8&#39;).read() f = &#39; &#39;.join(jieba.lcut(f)) stopwords = open(&#39;stopWords.txt&#39;,encoding=&#39;utf-8&#39;).read() # 词云背景 background = imageio.imread(&quot;qiubai.jpeg&quot;) image_colors = ImageColorGenerator(background) w = WordCloud( mask=background, width=690, height=560, font_path=&#39;C:\\Windows\\Fonts\\simhei.ttf&#39;, # 自己可以更换字体 scale=5, stopwords=stopwords) w.generate(f) w.to_file(&#39;qiubaiWordCloud.png&#39;) # word_counts = collections.Counter(object_list) 2、pyecharts画图 # 词云 from pyecharts import WordCloud wordcloud = WordCloud(width=1300, height=620) wordcloud.add(&quot;&quot;, wordStat[&#39;words&#39;], wordStat[&#39;计数&#39;], word_size_range=[20, 100]) wordcloud 3、图表#coding=utf-8 from __future__ import unicode_literals #绘制图表 from pyecharts import Bar bar = Bar(&quot;糗事百科&quot;,&quot;词频分布(DataScience)&quot;) bar.add(&quot;分词&quot;,wordStat[&#39;words&#39;], wordStat[&#39;计数&#39;]) #bar.print_echarts_options() # 该行只为了打印配置项，方便调试时使用 bar.render() #生成本地 HTML 文件 bar 4、Bar#EG 案例 from pyecharts import Bar attr = [&quot;&#123;&#125;&quot;.format(i) for i in wordStat[&#39;words&#39;]] v1 = wordStat[&#39;计数&#39;] bar = Bar(&quot;糗事百科-DataScience&quot;) bar.add(&quot;词频分布&quot;,attr,v1,mark_line=[&quot;average&quot;],mark_point=[&quot;max&quot;,&quot;min&quot;]) bar 5、饼图# 饼图 from pyecharts import Pie # 数据太多 我们取top 200 w=wordStat.head(20) attr = w[&#39;words&#39;] v1 = w[&#39;计数&#39;] pie= Pie(&quot;糗事百科-玫瑰图示例-DataScience&quot;,title_pos=&#39;center&#39;,width=900) pie.add(&quot;词频分布&quot;,attr,v1,center=[25,50],is_random=True,redius=[30,75],rosetype=&#39;redius&#39;) pie.add(&quot;词频分布&quot;,attr,v1,center=[75,50],is_random=True,redius=[30,75],rosetype=&#39;area&#39;,is_legend_show=False,is_label_show=True) pie","categories":[],"tags":[{"name":"数据可视化","slug":"数据可视化","permalink":"http://www.a2data.cn/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"}]},{"title":"Day6.PPT引入Pyecharts","slug":"Python/数据可视化/Day6、PPT引入Pyecharts","date":"2020-12-17T11:21:07.000Z","updated":"2025-05-04T18:37:40.538Z","comments":true,"path":"posts/7a179f78.html","link":"","permalink":"http://www.a2data.cn/posts/7a179f78.html","excerpt":"PPT中引入 Pyecharts","text":"PPT中引入 Pyecharts PPT中引入Pyecharts如何把pyecharts 放到PPT?辛辛苦苦用pyecharts做好后，那如何展示给老板们看呢？打工人日常用的最多的展示工具是PPT,这次展示如何把pyecharts放到ppt上？一般把html文件放到PPT用两种方法： 1、插件使用powerpoint的插件，office apps fiddle for powerpiont 在最新的office已经下架了该插件了，那么只能用第二种方法了。 2、VBA1、在PPT选项卡里添加开发工具 2.开发工具-其他控件-microsoft web brower-画透明展示框 首先看PPT是否开启插件，开启后 此处就有标志，然后就在你想插入的幻灯片处插入两个控件 1、网页控件 可以自定义拖拽，就会比较大了。 2、按钮控件 插入后如下，同理大小位置可自行调整 当然名称也是可以改的 右键点击按钮 选择属性 更改caption属性（不是名称） 然后开始改代码 ！！！ 如果PPT 没有开启宏的话 会提醒你开启宏 ，文件须得另存为.pptm格式的宏文件。 双击按钮 会弹出代码界面 填写代码 Private Sub WebBrowser1_DownloadBegin() WebBrowser1.Silent = True End Sub Private Sub WebBrowser1_DownloadComplate() WebBrowser1.Silent = True End Sub Private Sub CommandButton1_Click() WebBrowser1.Navigate (&quot;C:\\Users\\DataScience\\Desktop\\headmap.html&quot;) End Sub 红线部分为网页链接地址或者下载的模板网页绝对路径 在线编辑echarts 后下载下来 把绝对路径复制到代码中 （1个字符都不能错包括不能多一个空格，否则链接就会错误） 然后放映幻灯片，点击按钮 OK了 效果图如下： 踩坑记 切记要安装 网页控件 以及 点击控件 切记要打开宏链接 切记路径要绝对 绝对 绝对的准群 练习 1、讲自己做的图引入到PPT 2、做一个演示的动态可视化","categories":[],"tags":[{"name":"数据可视化","slug":"数据可视化","permalink":"http://www.a2data.cn/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"}]},{"title":"Day5.数据可视化Pyecharts","slug":"Python/数据可视化/Day5、数据可视化-Pyecharts","date":"2020-12-16T03:41:52.000Z","updated":"2025-05-04T18:37:40.539Z","comments":true,"path":"posts/ff2330ff.html","link":"","permalink":"http://www.a2data.cn/posts/ff2330ff.html","excerpt":"数据可视化，Pyecharts 神器","text":"数据可视化，Pyecharts 神器 Pyecharts我们对matplotlib和seaborn都有了一定的了解，并且可以绘制一系列图形。今天我们将讲几个关于pycharts的具体的案例，让大家对可视化有更深的了解。 0、安装#安装 pip install pyecharts 引入报错 解决方案： (如果是安装失败的情况的话，安装如下方式重新安装) #卸载 pip uninstall pycharts #方案1：安装 pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyecharts #方案2： #去官网下载： https://pypi.org/project/pyecharts/0.1.9.4/#files #把下载下来的whl文件放在相映路径下，接着在改路径下执行cmd。 #使用 pip install pyecharts-0.1.9.4-py2.py3-none-any.whl # 报错 init() got an unexpected keyword argument ‘title_color’ # 原因版本太新了没有安装拓展库 所以这里用老版本演示 pip uninstall pyecharts #安装指定版本 pip install pyecharts==0.5.0 # 地图库安装 pip install echarts-countries-pypkg pip install echarts-china-provinces-pypkg pip install echarts-china-cities-pypkg pip install echarts-china-counties-pypkg pip install echarts-china-misc-pypkg pip install echarts-united-kingdom-pypkg 1、地理坐标图#报错找不到 是因为 新版本更改了引入方式 from pyecharts import Geo #新版本引入如下 from pyecharts.charts import Geo # 旧版本测试地理图 data = [ (&quot;海门&quot;, 95), (&quot;鄂尔多斯&quot;, 15), (&quot;招远&quot;, 12), (&quot;舟山&quot;, 12), (&quot;齐齐哈尔&quot;, 14), (&quot;盐城&quot;, 15), (&quot;赤峰&quot;, 16), (&quot;青岛&quot;, 18), (&quot;乳山&quot;, 18), (&quot;金昌&quot;, 19), (&quot;泉州&quot;, 21), (&quot;莱西&quot;, 21), (&quot;日照&quot;, 21), (&quot;胶南&quot;, 22), (&quot;南通&quot;, 23), (&quot;拉萨&quot;, 24), (&quot;云浮&quot;, 24), (&quot;梅州&quot;, 25), (&quot;文登&quot;, 25), (&quot;上海&quot;, 25), (&quot;攀枝花&quot;, 25), (&quot;威海&quot;, 25), (&quot;承德&quot;, 25), (&quot;厦门&quot;, 26), (&quot;汕尾&quot;, 26), (&quot;潮州&quot;, 26), (&quot;丹东&quot;, 27), (&quot;太仓&quot;, 27), (&quot;曲靖&quot;, 27), (&quot;烟台&quot;, 28), (&quot;福州&quot;, 29), (&quot;瓦房店&quot;, 30), (&quot;即墨&quot;, 50), (&quot;抚顺&quot;, 31), (&quot;玉溪&quot;, 31), (&quot;张家口&quot;, 31), (&quot;阳泉&quot;, 31), (&quot;莱州&quot;, 42), (&quot;湖州&quot;, 32), (&quot;汕头&quot;, 32), (&quot;昆山&quot;, 33), (&quot;宁波&quot;, 33), (&quot;湛江&quot;, 33), (&quot;揭阳&quot;, 44), (&quot;荣成&quot;, 54), (&quot;连云港&quot;, 35), (&quot;葫芦岛&quot;, 35), (&quot;常熟&quot;, 36), (&quot;东莞&quot;, 36), (&quot;河源&quot;, 36), (&quot;淮安&quot;, 56), (&quot;泰州&quot;, 36), (&quot;南宁&quot;, 47), (&quot;营口&quot;, 37), (&quot;惠州&quot;, 37), (&quot;江阴&quot;, 67), (&quot;蓬莱&quot;, 57), (&quot;韶关&quot;, 38), (&quot;嘉峪关&quot;, 78), (&quot;广州&quot;, 38), (&quot;延安&quot;, 38), (&quot;太原&quot;, 69), (&quot;清远&quot;, 59), (&quot;中山&quot;, 39), (&quot;昆明&quot;, 79), (&quot;寿光&quot;, 40), (&quot;盘锦&quot;, 40), (&quot;长治&quot;, 61), (&quot;深圳&quot;, 51), (&quot;珠海&quot;, 42), (&quot;宿迁&quot;, 73), (&quot;咸阳&quot;, 43), (&quot;铜川&quot;, 44), (&quot;平度&quot;, 64), (&quot;佛山&quot;, 54), (&quot;海口&quot;, 44), (&quot;江门&quot;, 75), (&quot;章丘&quot;, 45), (&quot;肇庆&quot;, 46), (&quot;大连&quot;, 67), (&quot;临汾&quot;, 57), (&quot;吴江&quot;, 47), (&quot;石嘴山&quot;, 9), (&quot;沈阳&quot;, 50), (&quot;苏州&quot;, 50), (&quot;茂名&quot;, 60), (&quot;嘉兴&quot;, 41), (&quot;长春&quot;, 51), (&quot;胶州&quot;, 52), (&quot;银川&quot;, 52), (&quot;张家港&quot;, 52), (&quot;三门峡&quot;, 53), (&quot;锦州&quot;, 54), (&quot;南昌&quot;, 54), (&quot;柳州&quot;, 54), (&quot;三亚&quot;, 54), (&quot;自贡&quot;, 56), (&quot;吉林&quot;, 56), (&quot;阳江&quot;, 57), (&quot;泸州&quot;, 57), (&quot;西宁&quot;, 57), (&quot;宜宾&quot;, 58), (&quot;呼和浩特&quot;, 58), (&quot;成都&quot;, 58), (&quot;大同&quot;, 58), (&quot;镇江&quot;, 59), (&quot;桂林&quot;, 59), (&quot;张家界&quot;, 59), (&quot;宜兴&quot;, 59), (&quot;北海&quot;, 60), (&quot;西安&quot;, 61), (&quot;金坛&quot;, 62), (&quot;东营&quot;, 62), (&quot;牡丹江&quot;, 63), (&quot;遵义&quot;, 63), (&quot;绍兴&quot;, 63), (&quot;扬州&quot;, 64), (&quot;常州&quot;, 64), (&quot;潍坊&quot;, 65), (&quot;重庆&quot;, 66), (&quot;台州&quot;, 67), (&quot;南京&quot;, 67), (&quot;滨州&quot;, 70), (&quot;贵阳&quot;, 71), (&quot;无锡&quot;, 71), (&quot;本溪&quot;, 71), (&quot;克拉玛依&quot;, 72), (&quot;渭南&quot;, 72), (&quot;马鞍山&quot;, 72), (&quot;宝鸡&quot;, 72), (&quot;焦作&quot;, 75), (&quot;句容&quot;, 75), (&quot;北京&quot;, 79), (&quot;徐州&quot;, 79), (&quot;衡水&quot;, 80), (&quot;包头&quot;, 80), (&quot;绵阳&quot;, 80), (&quot;乌鲁木齐&quot;, 84), (&quot;枣庄&quot;, 84), (&quot;杭州&quot;, 84), (&quot;淄博&quot;, 85), (&quot;鞍山&quot;, 86), (&quot;溧阳&quot;, 86), (&quot;库尔勒&quot;, 86), (&quot;安阳&quot;, 90), (&quot;开封&quot;, 90), (&quot;济南&quot;, 92), (&quot;德阳&quot;, 93), (&quot;温州&quot;, 95), (&quot;九江&quot;, 96), (&quot;邯郸&quot;, 98), (&quot;临安&quot;, 99), (&quot;兰州&quot;, 99), (&quot;沧州&quot;, 100), (&quot;临沂&quot;, 103), (&quot;南充&quot;, 104), (&quot;天津&quot;, 105), (&quot;富阳&quot;, 106), (&quot;泰安&quot;, 112), (&quot;诸暨&quot;, 112), (&quot;郑州&quot;, 113), (&quot;哈尔滨&quot;, 114), (&quot;聊城&quot;, 116), (&quot;芜湖&quot;, 117), (&quot;唐山&quot;, 119), (&quot;平顶山&quot;, 119), (&quot;邢台&quot;, 119), (&quot;德州&quot;, 120), (&quot;济宁&quot;, 120), (&quot;荆州&quot;, 127), (&quot;宜昌&quot;, 130), (&quot;义乌&quot;, 132), (&quot;丽水&quot;, 133), (&quot;洛阳&quot;, 134), (&quot;秦皇岛&quot;, 136), (&quot;株洲&quot;, 143), (&quot;石家庄&quot;, 147), (&quot;莱芜&quot;, 148), (&quot;常德&quot;, 152), (&quot;保定&quot;, 153), (&quot;湘潭&quot;, 154), (&quot;金华&quot;, 157), (&quot;岳阳&quot;, 169), (&quot;长沙&quot;, 175), (&quot;衢州&quot;, 177), (&quot;廊坊&quot;, 193), (&quot;菏泽&quot;, 194), (&quot;合肥&quot;, 229), (&quot;武汉&quot;, 273), (&quot;大庆&quot;, 279)] geo = Geo(&quot;全国主要城市空气质量&quot;, &quot;data from pm2.5&quot;, title_color=&quot;b&quot;, title_pos = &quot;center&quot;, width = 1200, height = 600, background_color = &#39;#404a59&#39;) attr, value = geo.cast(data) geo.add(&quot;&quot;, attr, value, visual_range=[0, 200], visual_text_color=&quot;#fff&quot;, symbol_size = 15, is_visualmap = True) geo.render() geo 解决不显示地图问题 sudo pip install echarts-countries-pypkg sudo pip install echarts-china-provinces-pypkg sudo pip install echarts-china-cities-pypkg sudo pip install echarts-countries-pypkg sudo pip install echarts-china-provinces-pypkg sudo pip install echarts-china-cities-pypkg 效果图如下： 上面为默认的“scatter”类型，下面我们画一下’effectScatter’类型 attr, value = geo.cast(data) geo.add(&quot;&quot;, attr, value, type=&quot;effectScatter&quot;, is_random=True, effect_scale=5) geo.render(&quot;effect.html&quot;) 下面画一下 ‘headmap’类型，这是非常常用的一种类型。 geo.add(&quot;&quot;, attr, value, type=&quot;heatmap&quot;, is_visualmap=True, visual_range=[0, 300], visual_text_color=&#39;#fff&#39;) geo.render(&quot;headmap.html&quot;) 3、地理坐标系线图适用于分析数据出行 from pyecharts import GeoLines, Style style = Style(title_top=&quot;#fff&quot;,title_pos = &quot;center&quot;,width=1200,height=600,background_color=&quot;#404a59&quot;) style_geo = style.add(is_label_show=True,line_curve=0.2,line_opacity=0.6,legend_text_color=&quot;#eee&quot;, legend_pos=&quot;right&quot;,geo_effect_symbol=&quot;plane&quot;,geo_effect_symbolsize=15,label_color=[&#39;#a6c84c&#39;, &#39;#ffa022&#39;, &#39;#46bee9&#39;], label_pos=&quot;right&quot;,label_formatter=&quot;&#123;b&#125;&quot;,label_text_color=&quot;#eee&quot;,) data_guangzhou = [ [&quot;广州&quot;, &quot;上海&quot;], [&quot;广州&quot;, &quot;北京&quot;], [&quot;广州&quot;, &quot;呼和浩特&quot;], [&quot;广州&quot;, &quot;太原&quot;], [&quot;广州&quot;, &quot;长沙&quot;], [&quot;广州&quot;, &quot;吐鲁番&quot;] ] geolines = GeoLines(&quot;GeoLines 示例 -DataScience&quot;, **style.init_style) geolines.add(&quot;从广州出发&quot;, data_guangzhou, **style_geo) geolines.render() 4、关系图关系图是用于展现节点以及节点之间的关系的一种图，顾名思义，它用以分析关系最为适合，比如微博转发关系，文章引用关系等。 from pyecharts import Graph nodes = [&#123;&quot;name&quot;: &quot;a&quot;, &quot;symbolSize&quot;: 10&#125;, &#123;&quot;name&quot;: &quot;b&quot;, &quot;symbolSize&quot;: 20&#125;, &#123;&quot;name&quot;: &quot;c&quot;, &quot;symbolSize&quot;: 30&#125;, &#123;&quot;name&quot;: &quot;d&quot;, &quot;symbolSize&quot;: 40&#125;, &#123;&quot;name&quot;: &quot;e&quot;, &quot;symbolSize&quot;: 50&#125;, &#123;&quot;name&quot;: &quot;f&quot;, &quot;symbolSize&quot;: 40&#125;, &#123;&quot;name&quot;: &quot;g&quot;, &quot;symbolSize&quot;: 30&#125;, &#123;&quot;name&quot;: &quot;h&quot;, &quot;symbolSize&quot;: 20&#125;] links = [] for i in nodes: for j in nodes: links.append(&#123;&quot;source&quot;: i.get(&#39;name&#39;), &quot;target&quot;: j.get(&#39;name&#39;)&#125;) graph = Graph(&quot;关系图-环形布局示例-DataScience 提供&quot;) graph.add(&quot;&quot;, nodes, links, is_label_show=True, graph_repulsion=8000, graph_layout=&#39;circular&#39;, label_text_color=None) graph.render(&quot;graph.html&quot;) 5、词云# 数据指标随机生成的，名字是安装本期活动顺序写的 from pyecharts import WordCloud name = [ &#39;喵呜&#39;, &#39;四方&#39;, &#39;映琴&#39;, &#39;梧桐&#39;, &#39;Ray&#39;, &#39;子逐&#39;, &#39;小明&#39;, &#39;小小外星人&#39;, &#39;大熊喵喵喵&#39;, &#39;Tony&#39;, &#39;木夫&#39;, &#39;平凡人&#39;, &#39;不染&#39;, &#39;W.&#39;, &#39;白饭&#39;, &#39;vicky&#39;, &#39;不是&#39;, &#39;挖掘机&#39;, &#39;陌影&#39;, &#39;赛茜&#39;] value = [ 10000, 6181, 4386, 4055, 2467, 2244, 1898, 1484, 1112, 965, 847, 582, 555, 550, 462, 366, 360, 282, 273, 265] wordcloud = WordCloud(width=1300, height=620) wordcloud.add(&quot;&quot;, name, value, word_size_range=[20, 100]) wordcloud.render(&quot;wordcloud.html&quot;) 6、图表#coding=utf-8 from __future__ import unicode_literals #首先来我的绘制第一个图表 from pyecharts import Bar bar = Bar(&quot;我的第一个图表&quot;,&quot;这里是一个副标题(DataScience)&quot;) bar.add(&quot;分类&quot;,[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;],[15,18,35,66,6,88]) #bar.print_echarts_options() # 该行只为了打印配置项，方便调试时使用 bar.render() #生成本地 HTML 文件 bar 参数说明： ·add() 主要方法，用于添加图表的数据和设置各种配置项 ·print_echarts_options() 打印输出图表的所有配置项 ·render() 默认将会在根目录下生成一个render.html的文件,支持path参数，设置文件保存位置。 例如：render(r”e:\\my_first_chart.html”),文件用浏览器打开 ·Note： 可以按右边的下载按钮将图片下载到本地，如果想要提供更多实用工具按钮，请在add()中设置is_more_utils 为True 图形绘制过程 步骤 描述 代码示例 备注 实例一个具体类型图表的对象 chart = FooChart() 为图表添加通用的配置，如主题 chart.use_theme() 为图表添加特定的配置 geo.add_coordinate() 添加数据及配置项 chart.add()5 生成本地文件(html/svg/jpeg/png/pdf/gif）chart.render() 参考 数据解析与导入篇 7、柱状图# note ：使用Pandas &amp; Numpy 时，整数类型请确保为int， 而不是 numpy.int32 #当然你可以采用更加酷炫的方式，使用jupyter notebook 来展示图表，matplotib有的， # pyecharts 也会有的 #Note :从v0.1.9.2版本开始，废弃 render_notebook() 方法，现在已采用更加pythonic的做法。 #直接调用本身实例就可以了。 #EG 案例 from pyecharts import Bar attr = [&quot;&#123;&#125;月&quot;.format(i) for i in range(1,13)] v1 = [2.0,4.9,7.0,23.2,25.6,76.7,135.6,162.2,32.6,20.0,6.4,3.3] v2 = [2.6,5.9,9.0,26.4,28.7,70.7,175.6,182.2,48.7,18.8,6.0,2.3] bar = Bar(&quot;柱状图示例-DataScience&quot;) bar.add(&quot;增长数&quot;,attr,v1,mark_line=[&quot;average&quot;],mark_point=[&quot;max&quot;,&quot;min&quot;]) bar.add(&quot;取关数&quot;,attr,v2,mark_line=[&quot;average&quot;],mark_point=[&quot;max&quot;,&quot;min&quot;]) bar 8、饼图# 饼图 from pyecharts import Pie attr = [&quot;算法&quot;,&quot;产品&quot;,&quot;大数据&quot;,&quot;数据分析&quot;,&quot;Python&quot;,&quot;数据可视化&quot;] v1 = [11,12,13,10,10,10] v2 = [19,21,32,20,20,33] pie= Pie(&quot;饼图-玫瑰图示例-DataScience&quot;,title_pos=&#39;center&#39;,width=900) pie.add(&quot;品种A&quot;,attr,v1,center=[25,50],is_random=True,redius=[30,75],rosetype=&#39;redius&#39;) pie.add(&quot;品种B&quot;,attr,v2,center=[75,50],is_random=True,redius=[30,75],rosetype=&#39;area&#39;,is_legend_show=False,is_label_show=True) pie 9、自定义# 如果使用的是 自定义类，直接调用自定义类示例即可 from pyecharts import Bar,Line,Overlap attr = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;] v1 = [10,20,30,40,50,60] v2 = [38,28,58,48,88,68] bar =Bar(&quot;Line-Bar 示例&quot;) bar.add(&quot;bar&quot;,attr,v1) line = Line() line.add(&quot;line&quot;,attr,v2) overlap = Overlap() overlap.add(bar) overlap.add(line) overlap 如需使用 Jupyter Notebook 来展示图表，只需要调用自身实例即可，同时兼容 Python2 和 Python3 的 Jupyter Notebook 环境。 所有图表均可正常显示，与浏览器一致的交互体验，这下展示报告连 PPT 都省了！！","categories":[],"tags":[{"name":"数据可视化","slug":"数据可视化","permalink":"http://www.a2data.cn/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"}]},{"title":"Day4.数据可视化拓展图形的绘制","slug":"Python/数据可视化/Day4、数据可视化拓展图形的绘制","date":"2020-12-14T01:57:52.000Z","updated":"2025-05-04T18:37:40.535Z","comments":true,"path":"posts/62cf8a54.html","link":"","permalink":"http://www.a2data.cn/posts/62cf8a54.html","excerpt":"数据可视化，更多拓展图形的绘制,以及如何引入本地数据集","text":"数据可视化，更多拓展图形的绘制,以及如何引入本地数据集 使用Matplotlib和Seaborn进行画图，包括 箱线图 热力图 雷达图 二元变量分布 成对关系。 箱线图箱线图(boxplot)又称盒式图，可以显示数据的分散情况，由五个数值点组成：最大值(max)-上界、最小值(min)-下界、中位数(median)和上下四分位数(Q1, Q3)。它可以帮我们分析出数据的差异性、离散程度和异常值等。 **** # 数据准备 # ⽣成0-1之间的10*4维度数据(10行，4列的数组) import numpy as np data = np.random.normal(size=(10,4)) lables = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;] # ⽤Matplotlib画箱线图 # boxplot(x,labels=None)函数，x代表绘图数据，labels是缺省值，可以为箱线图添加标签。 import matplotlib.pyplot as plt plt.boxplot(data, labels=lables) #注意单词labels和lables plt.show() # ⽤Seaborn画箱线图 # boxplot(x=None,y=None,data=None)函数。data为DataFrame类型，x、y是data中的变量。 import seaborn as sns import pandas as pd df = pd.DataFrame(data, columns=lables) sns.boxplot(data=df) plt.show() 运行结果： 热力图热力图（heat map）是一种矩阵表示方法，其中矩阵中的元素值用颜色来代表，不同的颜色代表不同大小的值。通过颜色的深浅就能直观地知道某个位置上数值的大小。另外也可以某个位置上的颜色与其他位置颜色进行比较，是一种非常直观的多元变量分析方法。 1、基本热力图 2、设置热力图区间 3、颜色差异更大的原因 4、使用Seaborn自带数据 一般使用Sarborn中的sns.heatmap(data)函数绘制，我们使用Seaborn中自带的数据集ﬂights，该数据集记录了1949年到1960年期间，每个月的航班乘客的数量。 一般可能会出网络问题导致的失败。 下载地址：https://github.com/mwaskom/seaborn-data 代码改进，将下载的数据引入进来： 数据透视表 直接读入进来还是不可的 需要对表进行重塑 转化为数据透视表才可以使用 hhh 蒙蔽了吧 改进代码和运行结果如下： 5、指定调色板 雷达图雷达图（radar chart）是以从同一点开始的轴上表示的三个或多个变量的图表的形式，也是显示一对多关系的方法。在雷达图中，一个变量相对于另一个变量的显著性清晰可见。 如果我们制作一张影响购买手机的因素分析图，我们通过收集问卷采访顾客对品牌，价格，外观，硬件，拍照，电量几个方面进行打分，将统计好的因素比重用雷达图表示出来。这里使用Matplotlib进行画图，首先设置两个数组：items和scores，它们分别保存了购买因素的名称和分数。 雷达图的边框是⼀个圆形，需要计算每个坐标的角度，然后对这些数值进行设置。当画完最后⼀个点后，需要与第⼀个点连线。 因为需要计算角度，所以我们要准备angles数组；又因为需要设定统计结果的数值，所以我们要设定scores数组。并且需要在原有angles和scores数组上增加⼀位，也就是添加数组的第一个元素。 # 数据准备 import numpy as np import pandas as pd import matplotlib.pyplot as plt plt.rcParams[&#39;font.sans-serif&#39;] = [&#39;KaiTi&#39;] # 显示中文字体• items = np.array([u&quot;品牌&quot;, u&quot;价格&quot;, u&quot;外观&quot;, u&quot;硬件&quot;, u&quot;拍照&quot;, u&quot;电量&quot;]) # u:unicode scores= [88, 92, 70, 78, 79, 82] # 画图数据准备，⻆度、score和angles的状态值 angles=np.linspace(0, 2*np.pi, len(items), endpoint=False) #分割圆周长 scores=np.concatenate((scores,[scores[0]])) # concatenate:拼接，在原有的score和angles上加一 angles=np.concatenate((angles,[angles[0]])) # ⽤Matplotlib画蜘蛛图 fig = plt.figure() # 创建一个空白画布对象，添加子图可以将画板分成一行一列,形成一个绘图区 ax = fig.add_subplot(111, polar=True) #设置字画布，极坐标系：True ax.plot(angles, scores, &#39;o-&#39;,linewidth=2) #连线 ax.fill(angles, scores, alpha=0.25) #上色 ax.set_thetagrids(angles * 180/np.pi, items) #写上标签 plt.show() 运行结果： 二元变量分布如果我们想要看两个变量之间的关系，就需要用到二元变量分布。二元变量分布有多种呈现方式，之前讲解的散点图就是一种二元变量分布。 在Seaborn里，使用二元变量分布非常方便，直接用sns.jointplot(x, y, data=None, kind)函数即可。kind表示不同的视图类型：“kind=‘scatter’”代表散点图，“kind=‘kde’”代表核密度图，“kind=‘hex’ ”代表Hexbin图，它代表的是有六边形的单元画出的二维直方图的模拟。 我们在演示中使用Seaborn自带的数据集tips，这个数据集记录了不同顾客在餐厅的消费账单及小费情况。代码中total_bill保存了客户的账单金额，tip是该客户给出的小费金额。我们可以用Seaborn中的jointplot来探索这两个变量之间的关系。 # 数据准备 import seaborn as sns tips = sns.load_dataset(&quot;tips&quot;) print(tips.head(10)) # head将表格中的第一行取作列名，然后取10行数据 # ⽤Seaborn画二元变量分布图（散点图，核密度图，Hexbin图） sns.jointplot(x=&quot;total_bill&quot;, y=&quot;tip&quot;, data=tips, kind=&#39;scatter&#39;) sns.jointplot(x=&quot;total_bill&quot;, y=&quot;tip&quot;, data=tips, kind=&#39;kde&#39;) sns.jointplot(x=&quot;total_bill&quot;, y=&quot;tip&quot;, data=tips, kind=&#39;hex&#39;) plt.show() 同样报错，我们使用相同方式把数据引入进来。数据都到本地了，怎么玩还不是看你的思维么？ 所谓自己动手丰衣足食！！ 引入数据 运行结果如下： 成对关系如果想要探索数据集中的多个成对双变量的分布，可以直接采⽤sns.pairplot()函数。它会同时展示出DataFrame中每对变量的关系，另外在对角线上，能看到每个变量本身作为单变量的分布情况。pairplot()是探索性分析中的常用函数，可以很快帮我们理解变量对之间的关系。 我们使用Seaborn中自带的iris鸢尾花数据集。 鸢尾花可以分成： Setosa Versicolour Virginica三个品种 在这个数据集中，针对每⼀个品种，都有50个数据，每个数据中包括了4个属性，分别是花萼长度、花萼宽度、花瓣长度和花瓣宽度。通过这些数据，可以预测出鸢尾花卉属于三个品种中的哪一种。 # 数据准备 import seaborn as sns iris = sns.load_dataset(&#39;iris&#39;) # 用Seaborn画成对关系 sns.pairplot(iris) plt.show() ⽤Seaborn中的pairplot函数来对数据集中的多个双变量的关系进行探索，如下图所示： 解析： 从图上可以看出，⼀共有 sepal_length、sepal_width、petal_length和petal_width4个变量，它们分别是花萼长度、花萼宽度、花瓣长度和花瓣宽度。这张图相当于这4个变量两两之间的关系。 第一行第一列中的图代表的是花萼长度自身的分布图，右侧的第一行第二列的这张图代表的是花萼长度与花萼宽度这两个变量之间的关系。 小作业 1、Seaborn数据集中自带了car_crashes数据集，这是一个国外车祸的数据集，对这个数据集进行成对关系的探索。并用Seaborn画二元变量(x=”total,y=”speeding”)分布图，如果想要画散点图，核密度图，Hexbin图该怎样写. 2、 探索更多seaborn-data 的数据展示 3、 你有应用的场景嘛？举个栗子","categories":[],"tags":[{"name":"数据可视化","slug":"数据可视化","permalink":"http://www.a2data.cn/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"}]},{"title":"Day3.常见图形的不同绘制方法","slug":"Python/数据可视化/Day3、常见图形的不同绘制方法","date":"2020-12-13T01:46:25.000Z","updated":"2025-05-04T18:37:40.535Z","comments":true,"path":"posts/f893cfd3.html","link":"","permalink":"http://www.a2data.cn/posts/f893cfd3.html","excerpt":"数据可视化，常见图形的不同绘制方式。","text":"数据可视化，常见图形的不同绘制方式。 我们了解了常用的五种图形： 散点图 折线图 柱状图 直方图 饼图 那么如何用Matplotlib和Seaborn来画出它们。 Matplotlib：它在使用时灵活，可以定制化绘图，但是时间上的花费也比较多。为了提高画图效率，包Seaborn基于Matplotlib底层开发，使用更少的代码，将常用的可视化绘图过程进行封装，有时只需要一行代码便可以画出我们想要的图形，省时省力；此外seaborn还提供更为丰富的图像以及3D图形供我们使用。掌握两个库的使用可以满足我们在不同情况下的需求。 散点图散点图（scatter plot），它将两组数据（或者变量）的值显示在二维坐标中，适合展示两个变量之间的关系。 第一张散点图用matplotlib绘制，第二张用seaborn绘制。我们可以看到两张图的区别：matplotlib默认情况下绘图区呈现是一个长方形，而seaborn是正方形并且含有x轴和y轴的标签；seaborn还展示散点图还给出了两组数据（变量）的分布情况。 说明： 用==seaborn==画图时，使用函数 画散点图。其中x,y是data中的下标，data就是我们要传入的数据。 在Seaborn中，数据格式需要转换一下，采用科学计算库Pandas中的数据格式DataFrame；对DataFrame的概念我们了解即可，下期DataScience也会推出科学计算库Numpy和Pandas的使用中会有讲解。 折线图折线图能够显示数据的变化趋势，在matplotlib使用plot函数绘制，而在seaborn使用 lineplot(x,y,data=None)函数；data是传入的数据，一般是pandas中的DataFrame数据结构。 直方图直方图( histogram )将横坐标等分成一定数量的小区间，在小区间内填充图形，它的高度是y值。特点是用来绘制连续性的数据，展示一组或者多组数据的分布状况(统计)。 #数据准备：创建一个一维随机数组 import numpy as np import random import pandas as pd a = np.random.randn(100) x = pd.Series(a) # Series是pandas中用来存放一维数组的数据格式 # ⽤Matplotlib画直⽅图； &quot;&quot;&quot; 使用plt.hist(x, bins=10)函数 参数x是一维数组，bins代表小区间的数量，默认是10。 &quot;&quot;&quot; import matplotlib.pyplot as plt plt.hist(x, bins=10) plt.show() # ⽤Seaborn画直⽅图： &#39;&#39;&#39; 使用sns.distplot(x, bins=10, kde=True)函数 参数x是一维数组，bins代表直方图中的小区间数量，kde代表显示核密度估计，默认是True。 核密度估计是通过核函数来估计概率密度的方法。 &#39;&#39;&#39; import seaborn as sns sns.distplot(x, kde=False) plt.show() # 图三显示用核函数估计概率密度 sns.distplot(x, kde=True) plt.show() Matplotlib 运行结果： Seaborn运行结果: 条形图通过直方图可以看到变量的数值分布，那么条形图可以帮我们查看类别的特征。在条形图中，长条形的长度表示类别的频数，宽度表示类别。 条形图(bar chart)绘制离散的数据,能够一眼看出各个数据的大小,比较数据之间的差别。(统计/对比) # 数据准备 x = [&#39;Cat1&#39;, &#39;Cat2&#39;, &#39;Cat3&#39;, &#39;Cat4&#39;, &#39;Cat5&#39;] y = [3, 5, 7, 2, 9] # ⽤Matplotlib画条形图 # plt.bar(x, height)函数，参数x代表x轴的类别，height是y轴的数值 import matplotlib.pyplot as plt plt.bar(x,y) plt.show # ⽤Seaborn画条形图 # sns.barplot(x=None,y=None,data=None)函数；参数data为DataFrame类型 import seaborn as sns sns.barplot(x,y) plt.show() 运行结果: 饼图饼图（Pie Chart）可以显示每个部分大小与总和之间的比例。在Python数据可视化中，主要用Matplotlib的pie函数来绘制。 用到的方法 matplotlib.pyplot.pie() 参数解析: pie(x, explode=None, labels=None, colors=(&#39;b&#39;, &#39;g&#39;, &#39;r&#39;, &#39;c&#39;, &#39;m&#39;, &#39;y&#39;, &#39;k&#39;, &#39;w&#39;), autopct=None, pctdistance=0.6, shadow=False, labeldistance=1.1, startangle=None, radius=None, counterclock=True, wedgeprops=None, textprops=None, center = (0, 0), frame = False ) 参数说明： x (每一块)的比例，如果sum(x) &gt; 1会使用sum(x)归一化 labels (每一块)饼图外侧显示的说明文字explode (每一块)离开中心距离 startangle 起始绘制角度,默认图是从x轴正方向逆时针画起,如设定=90则从y轴正方向画起 shadow 是否阴影 labeldistance label绘制位置,相对于半径的比例, 如&lt;1则绘制在饼图内侧 autopct控制饼图内百分比设置,可以使用format字符串或者format function‘%1.1f’指小数点前后位数(没有用空格补齐) pctdistance 类似于labeldistance,指定autopct的位置刻度 radius 控制饼图半径 返回值: 如果没有设置autopct,返回(patches, texts) 如果设置autopct,返回(patches, texts,autotexts) patches – list –matplotlib.patches.Wedge对象 textsautotexts – matplotlib.text.Text对象 # 数据准备，显示各学历人数的比例 nums = [20, 42, 18, 7, 6] labels = [&#39;High-school&#39;, &#39;Bachelor&#39;, &#39;Master&#39;, &#39;Ph.d&#39;, &#39;Other&#39;] # pie(x, labels=None)函数,x代表绘制饼图的数据，labels是缺省值，可以为饼图添加标签 import matplotlib.pyplot as plt plt.pie(x=nums, labels=labels, autopct=&#39;%1.1f%%&#39;) # autopct:设置圆内的文本 # &#39;1.1f%&#39;指图片上显示的数字格式，表示小数点前后位数# 另外两个%%是format格式的符号plt.show() 运行结果： 小作业 1、说出Matplotlib和Seaborn库的区别。 2、总结画出五种常见图像的函数。","categories":[],"tags":[{"name":"数据可视化","slug":"数据可视化","permalink":"http://www.a2data.cn/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"}]},{"title":"Day2.数据可视化基本图像绘制","slug":"Python/数据可视化/Day2、数据可视化基本图像绘制","date":"2020-12-12T01:51:37.000Z","updated":"2025-05-04T18:37:40.539Z","comments":true,"path":"posts/b11c450a.html","link":"","permalink":"http://www.a2data.cn/posts/b11c450a.html","excerpt":"数据可视化，基本图像的绘制。","text":"数据可视化，基本图像的绘制。 数据可视化的基础语法可视化主要是以图像来展示数据间的关系， 常见的图形种类有 ==折线图,散点图,条形图，直方图，饼图==。 此外在接下来课程中还会用到==箱线图，热力图，蜘蛛图==，表示二元变量分布和成对关系的视图。 今天我们要来了解折线图，散点图，条形图，直方图，饼图和器特点。认识Matplotlib的图像结构，并以Matplotlib绘制折线图为例来掌握设置辅助显示层；此外，用Matplotlob设置辅助显示层，内容还增添拓展部份，平时用到的不是很多，作为了解即可。 常见图像折线图 以折线的上升或下降来表示统计数量的增减变化的统计图 特点：能够显示数据的变化趋势，反映事物的变化情况。(变化) 散点图（Scatter） 用两组数据构成多个坐标点，考察坐标点的分布,判断两变量之间是否存在某种关联或总结坐标点的分布模式。 特点：判断变量之间是否存在数量关联趋势,展示离群点(分布规律) 条形图 排列在工作表的列或行中的数据可以绘制到柱状图中。 特点：绘制连离散的数据,能够一眼看出各个数据的大小,比较数据之间的差别。(统计/对比) 直方图(Histogram) 由一系列高度不等的纵向条纹或线段表示数据分布的情况。一般用横轴表示数据范围，纵轴表示分布情况。 特点：绘制连续性的数据展示一组或者多组数据的分布状况(统计) 饼图(pie) 用于表示不同分类的占比情况，通过弧度大小来对比各种分类。 特点：分类数据的占比情况(占比) Matplotlib画图基础 Matplotlib，它是一个Python 2D绘图库，它可以在各种平台上以各种硬拷贝格式和交互式环境生成出具有出版品质的图形。只需几行代码即可生成绘图，直方图，条形图,散点图等。 Matplotlib画图的简单实现 # 导入模块 import matplotlib.pyplot as plt # 在jupyter中执行的时候显示图片 #matplotlib inline # 传入x和y, 通过plot画图 plt.plot([3, 1, 7], [4, 5, 6]) # 在执行程序的时候展示图形 plt.show() 传入x和y时，括号中的第一个列表是x轴上的值，第二个列表是y上的值。 运行结果： 如何应用呢？ 对Matplotlib图像结构的认识 在学习Matplotlib的过程中，大家一定会遇到这样那样的问题， 比如说， 背景图怎么设置？ 坐标轴怎么设置？ 坐标轴上的刻度值怎么设置？ 因此对于Matplotlib的图像结构组成我们要有一定的了解。通常情况下，我们可以将一副Matplotlib图像分成三层结构： 第一层是底层的容器层 主要包括Canvas(画板)底层、Figure（画布）用户操作第一层设置画布的大小和背景颜色、Axes（绘图区）独立的坐标系； 第二层：辅助显示层 主要包括Axis（轴）、Spines（边框线）、Tick（坐标轴刻度）、Grid（网格线）、Legend（图例说明）、Title（标题）等，该层可通过set_axis_off()或set_frame_on(False)等方法设置不显示。 该层的设置可使图像显示更加直观更加容易被用户理解，但又并不会对图像产生实质的影响。 第三层：图像层 即通过plot、hist、contour、scatter等方法绘制的图像。 Matplotlib绘制折线图折线图的绘制 代码解析： x轴数值的产生使用range函数，开始数字是1，结束时7，不包含8。 折线的颜色和形状设置from matplotlib import pyplot as plt x = range(1,8) # x轴的位置 y = [17, 17, 18, 15, 11, 11, 13] # 传入x和y, 通过plot画折线图 plt.plot(x, y, color=&#39;red&#39;,alpha=0.5,linestyle=&#39;--&#39;,linewidth=3) plt.show() &#39;&#39;&#39;基础属性设置 color=&#39;red&#39; : 折线的颜色 alpha=0.5 : 折线的透明度(0-1) linestyle=&#39;--&#39; : 折线的样式 linewidth=3 : 折线的宽度 &#39;&#39;&#39; &#39;&#39;&#39;线的样式 - 实线(solid) -- 短线(dashed) -. 短点相间线(dashdot) ：虚点线(dotted) &#39;&#39;&#39; 运行结果： 折点样式 折点形状选择： 标记maker 描述 ‘o’ 圆圈 ‘.’ 点 ‘D’ 菱形 ‘s’ 正方形 ‘h’ 六边形1 ‘*’ 星号 ‘H’ 六边形2 ‘d’ 小菱形 ‘_’ 水平线 ‘v’ 一角朝下的三角形 ‘8’ 八边形 ‘&lt;’ 一角朝左的三角形 ‘p’ 五边形 ‘&gt;’ 一角朝右的三角形 ‘,’ 像素 ‘^’ 一角朝上的三角形 ‘+’ 加号 ‘|‘ 竖线 ‘None’,’’,’ ‘ 无 ‘x’ X 设置图片的大小和保存from matplotlib import pyplot as plt import random x = range(2,20,2) # x轴的位置 y = [random.randint(15, 30) for i in x] # 设置图片的大小 &#39;&#39;&#39; figsize:指定figure的宽和高，单位为英寸； dpi参数指定绘图对象的分辨率，即每英寸多少个像素，缺省值为80 1英寸等于2.5cm,A4纸是 21*30cm的纸张 &#39;&#39;&#39; # 设置画布对象 plt.figure(figsize=(20,8),dpi=80) plt.plot(x,y) # 传入x和y, 通过plot画图 # 保存(注意：要放在show的上面，plt.show()会释放figure资源，如果在显示图像之后保存图片将只能保存空图片。) plt.savefig(&#39;./t1.png&#39;) #./表示放在当前python文件的目录 plt.show() # 图片的格式也可以保存为svg这种矢量图格式，这种矢量图放在网页中放大后不会有锯齿 # plt.savefig(&#39;./t1.svg&#39;) x轴的数值，使用range(),step为2,不包括20； y轴的数值是一个列表表达式，由随机数产生，import random之后，randint产生随机整数，范围是15-30。“for i in x”是一个循环，作用是表明y轴数值产生随机数的次数，次数由x轴上数值的个数决定。 运行结果： 绘制x轴和y轴的刻度 在设置Y轴标签时，标签数值的取值范围range(min(y),max(y)+1)，这里min()和max()时是函数，分别取y中的最小和最大值，由于range函数不包集合右边的值，故加1。plt.yticks(range(min(y),max(y)+1),y_ticks_label)中，y_ticks_label表示y轴刻度产生的次数。 设置显示中文matplotlib只显示英文，无法显示中文，需要修改matplotlib的默认字体。通过模块font_manager使用中文字体可以解决。 以表示两个小时内心脏每分钟跳动变化为例，x轴需要加上标题“时间”，y轴“次数”，图像标题“每分钟跳动次数”,如下图所示： 一图多线 拓展部分：一图多个坐标系# 方法add_subplot：给figure新增子图 # 这里引进的科学计算库Numpy,把它看作一个[列表]即可，目的是要使用log方法画log对数函数。 import numpy as np from matplotlib import pyplot as plt x = np.arange(1, 100) #与range（）相同 #新建figure画布对象，三个坐标轴（子图）建立在同一个画布上 fig=plt.figure(figsize=(20,10),dpi=80) #利用画布对象，在上面放置三个坐标系 #新建子图1 ax1=fig.add_subplot(2,2,1) ax1.plot(x, x) #新建子图2 ax2=fig.add_subplot(2,2,2) ax2.plot(x, x ** 2) #x的二次方，如果是x**3是x的三次方 ax2.grid(color=&#39;r&#39;, linestyle=&#39;--&#39;, linewidth=1,alpha=0.3) #新建子图3 ax3=fig.add_subplot(2,2,3) ax3.plot(x, np.log(x)) plt.show() 在这里解释一下add_subplot(2,2,1)里的参数的含义。在一个画布上放置三个图，需要排列位置。 首先将一张图，分成两列，再分成两行，总共划分出四个格子，子图1按照从左到右从上到下的顺序放在第一个格子里。 运行结果： 拓展部分：设置坐标轴范围 打卡格式 小作业 1、说出你理解的五种常用图像的特点，你有没有地方需要用得到呢？。 2、运用Matplotlib,自己编数据设计样式，绘制一幅自己的折线图。","categories":[],"tags":[{"name":"数据可视化","slug":"数据可视化","permalink":"http://www.a2data.cn/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"}]},{"title":"Day1.数据可视化Python语法","slug":"Python/数据可视化/Day1、零基础与Python做个朋友","date":"2020-12-11T00:56:37.000Z","updated":"2025-05-04T18:37:40.539Z","comments":true,"path":"posts/bb9346ce.html","link":"","permalink":"http://www.a2data.cn/posts/bb9346ce.html","excerpt":"数据可视化，基础语法。","text":"数据可视化，基础语法。 数据可视化-Python基础语法Python简单？想学好数据分析，最好最快的方式是掌握==Python语言==。 Python语言的强大 简洁，有大量的第三方库，功能强大（数据科学领域） Numpy 科学计算工具 Pandas 解决数据分析任务 Keras和TensorFlow 深度学习工具 Scikit-learn 机器学习工具 能解决数据分析的大部分问题 容易上手,语法简单。 总之，在数字化时代掌握⼀门编程语言，尤其是Python语言的使用是⾮常有必要的。相信使用Python的流行，不必多说，接下来我们一起学习基础语法。需要注意编程中除了文字部分可以使用中文，标点符号一定要使用英文输入法否则会报错。 输入输出语法==input是输入函数input()== 括号中存放的是提示文 双引号里面存放字符串类型数据。 ==print是输出函数 print()== 括号里是输出的内容，第一个print函数，打印出字符串。 %name代表变量name的数值，因为是字符串类型，所以在前面加上%s作为代替。 第二个print函数中，%sum代表变量sum的数值，是数值型，在前面加上%d作为代替。 例如如下展示： 在Jupyter Notebook 中运行后会出现一个输入框。将内容输入对话框中，内容会被赋值给变量name。 # 运行结果如下 what&#39;s your name?DataScience hello,DataScience ========= sum=200 注释什么是注释呢？ 简单来说就两点作用: 1、把暂时 无用的代码注掉。 为什么说是暂时呢，怕你删多了后边忘记(但是工作上线的话，不能有过多冗余代码的) 2、言简意赅 也就是说 为了标明 这段代码的作用是什么，亦或者大家顺便吐槽一下。 注释方式： # 号 “” &amp;&amp; ‘’ # 早报参数 # 如下函数注释 def morningEdition(request): &quot;&quot;&quot; :param request: 早报相关信息传参 :return: 早报结果 &quot;&quot;&quot; #单行注释 &#39;&#39;&#39; 这是多⾏注释，⽤三个单引号 这是多⾏注释，⽤三个单引号 这是多⾏注释，⽤三个单引号 &#39;&#39;&#39; &quot;&quot;&quot; 这是多⾏注释，⽤三个双引号 这是多⾏注释，⽤三个双引号 这是多⾏注释，⽤三个双引号 &quot;&quot;&quot; 又或者如下所示： #我是一匹来自北方的狼 #你们谁懂我心理的伤 # ░░░░░░░░░░░░░░░░░░░░░░░░▄░░ # ░░░░░░░░░▐█░░░░░░░░░░░▄▀▒▌░ # ░░░░░░░░▐▀▒█░░░░░░░░▄▀▒▒▒▐ # ░░░░░░░▐▄▀▒▒▀▀▀▀▄▄▄▀▒▒▒▒▒▐ # ░░░░░▄▄▀▒░▒▒▒▒▒▒▒▒▒█▒▒▄█▒▐ # ░░░▄▀▒▒▒░░░▒▒▒░░░▒▒▒▀██▀▒▌ # ░░▐▒▒▒▄▄▒▒▒▒░░░▒▒▒▒▒▒▒▀▄▒▒ # ░░▌░░▌█▀▒▒▒▒▒▄▀█▄▒▒▒▒▒▒▒█▒▐ # ░▐░░░▒▒▒▒▒▒▒▒▌██▀▒▒░░░▒▒▒▀▄ # ░▌░▒▄██▄▒▒▒▒▒▒▒▒▒░░░░░░▒▒▒▒ # ▀▒▀▐▄█▄█▌▄░▀▒▒░░░░░░░░░░▒▒▒ # - 单身狗就这样默默地看着你，一句话也不说。- # =======DATASCIENCE======= 判断语句if … else … 是经典的判断语句 ==注意点：== 在if 后有个冒号，同样在else后⾯也存在冒号。 Python采用代码缩进和冒号的方式来区分代码之间的层次关系。 ==易错点：== 所以代码缩进在Python中是一种语法，如果代码缩进不统一，比如有的是tab有的是空格，会怎样呢？ 会产生错误或者异常。所以相同层次的代码⼀定要采用相同层次的缩进。 ==代码解析：== 代码中实现输入分数，判断是否优秀和及格。 score后面加上int()作用是将==input函数==中获得的字符串数值转换为整数integer. 循环语句for ..in ..for循环是⼀种迭代循环机制，迭代即的逻辑操作。如果规定循环的次数，我们可以使用range函数，它在for循环中比较常用。range(11)代表从数字0到10，不包括末尾11，也相当于range(0,11)，range里面还可以增加步长，比如range(1,11,2)代表的是数组[1,3,5,7,9] while 1到10的求和也可以⽤while循环来写，这里while控制了循环的次数。while循环是条件循环，在while循环中对于变量的计算方式更加灵活。因此while循环，⽽for循环的条件相对确定，。 数据类型Python3 中有六个标准的数据类型： Number （数字） String （字符串） List （列表） Tuple （元组） Set （集合） Dictionary （字典） 列表[List]列表是Python中常用的数据结构，相当于数组，具有增删改查的功能，我们可以使用len()即英文length长度，函数获得lists中元素的个数；使⽤ append()在尾部添加元素，使用insert()在列表中插⼊元素，使用pop()删除尾部元素。 元组{tuple}元组tuple和list⾮常类似，但是tuple==⼀旦初始化就不能修改==。因为不能修改所以没有append(), insert() 这样的⽅法，可以像访问数组⼀样进⾏访问，⽐如tuples[0]，但不能赋值。 字典{dict}字典其实就是&#123;key, value&#125;键值对，==多次对同⼀个key放入value，后面的值会把前面的值覆盖，同样字典也有增删改查==。增加字典的元素相当于赋值，比如score[‘小张’] = 98，删除⼀个元素使⽤pop，字典不支持直接修改元素中的key，可将旧元素删除后添加一个元素。 集合 Set集合set和``字典dictionary`类似，不过==它只是key的集合==，==不存储value==。同样可以增删查，增加使⽤add，删除使⽤remove，查询看某个元素是否在这个集合里，使用in。 函数def是函数装饰器，将函数代码块打包。函数代码块以def关键词开头，后接函数名和圆括号，在圆括号里是传进来的参数，然后通过return进行函数结果得反馈。 引⽤模块/包：import#导⼊⼀个模块 import model_name #导⼊多个模块 import module_name1,module_name2 #导⼊包中指定模块 from package_name import moudule_name #导⼊包中所有模块 from package_name import * Python语言中import的使用很简单，直接使用import module_name语句导入即可。 ==这里import的本质是什么呢？== import的本质。 import引用可以是模块module，或者包package。 针对module，实际上是引⽤⼀个.py ⽂件。而针对package，可以采⽤from … import …的方式，这里实际上是从⼀个目录中引用模块，这时目录结构中必须带有⼀个_ init_.py⽂件。 小作业 1、如果我想在Python中引⽤matplotlib库该如何引⽤？ 2、求 1+3+5+7+…+99 的求和，⽤Python该如何写？","categories":[],"tags":[{"name":"数据可视化","slug":"数据可视化","permalink":"http://www.a2data.cn/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"}]},{"title":"活动三步走","slug":"活动三步走","date":"2020-12-10T13:14:10.000Z","updated":"2025-05-04T18:37:40.528Z","comments":true,"path":"posts/cfcef26f.html","link":"","permalink":"http://www.a2data.cn/posts/cfcef26f.html","excerpt":"进来看看 不吃亏，肯定有你不会的。不信你来看看","text":"进来看看 不吃亏，肯定有你不会的。不信你来看看 活动打卡三步走 博客网站留言，评论自己的错误问题,以便后续大家交流学习 将问题截图，上传留言，可以给出解题思路或者答案 将每日作业存放于个人目录下，或者截长图 留言打卡 公号打卡示例每日文章按照格式，评论打卡学习如下图所示 https://mp.weixin.qq.com/s/EEfhIVlQgrlLgUU7QNy8_Q 博客打卡示例https://www.a2data.cn/posts/cc50857e.html 尽量留言自己的 问题 明确格式 不是博主笑话你，在座的各位 不一定都会截长图 有没有又学到东西了呢？ 往下看 认真看哦 #评论格式 问题说明 ![](图片地址) 例如： ![https://ds.ipyingshe.net/datascience/2025/05/05/aecd6f5cd2ac4.png] 看我看我 效果如下：一句话 牛逼~ 每日作业打卡示例博客作业打卡 零环境搭建打卡 什么是图床？简而言之，就是 相当于公开百度出来的图片，大家都能看到。 明白了不？ 那么图床可以做什么呢？ 或者为啥要弄图床呢？ 希望可以帮助后边学习的人 1、让大家学习遇到的问题,记录下来帮助更多的人 2、给大家留一份纪念，陪伴DS一起成长 如果你想搭建自己的图床，可以联系博主哦。 路过图传无需配置 直接将图片上传即可 https://imgchr.com/ 截图神器https://www.snipaste.com/ 长图使用： 可以实现滚动截图哦！ 链接：https://share.weiyun.com/1cXk0kyI 密码：56vqm7 最后感谢大家的参与。本次活动开支，内网映射1k,活动经费200，时间8天。 希望可以帮到大家，一起进步。 博主：www.a2data.cn 公号: DataScience 数据科学，分析 可视化爬虫相关 DataBricks 大数据全栈开发 DataScience 同名小程序 作者：一个有趣有态度，软件控的，互联网的体育僧！","categories":[],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/tags/Tools/"}]},{"title":"Anaconda利器","slug":"Python/数据可视化/Day0、Python-Anaconda","date":"2020-12-10T02:29:51.000Z","updated":"2025-05-05T04:38:52.912Z","comments":true,"path":"posts/6e2faa04.html","link":"","permalink":"http://www.a2data.cn/posts/6e2faa04.html","excerpt":"数据可视化，环境搭建。","text":"数据可视化，环境搭建。 Python-Anaconda 环境搭建-Anaconda这是一个支持 Linux, Mac, Windows系统的python发行版本，占空间约600MB。如对空间要求严格的用户，Miniconda是一种选择。 Windows系统 https://www.anaconda.com/distribution/ 首先打开这个网址 本文以作者系统为例， 双击安装文件 Anaconda3-2019.10-Windows-x86_64.exe，进入安装界面，点击 Next。 点击 I Agree，同意 Anaconda 的协议。 一般选择 Just Me，这也是建议安装选项，当然，选 All Users，为电脑上的所有用户安装也未尝不可。选好了以后点击 Next 继续。 在下图显示的界面选择安装目录，建议不要存C盘，这样以后会更多。 默认第一个勾选框是没有选中的，需要自己点选，这个选项说的是把 Anaconda 添加为 PATH 环境参数 。 后边基本没太多需要注意的。Install 安装到如下界面，可以选择安装，也可以跳过。我这里跳过了。 下一步，Finish 到此，安装完成。其实这个安装很简单。一般都会。 Anaconda启动 Python,你好！ 也许会迟到，但绝对不会缺席！ print(&quot;Hello world&quot;) 全宇宙最亲近一行代码 没有之一 这里我们通过执行Jupyter notebook ，启动方式有两种！ 1、点击 jupyter botebook 图标运行 2、Win+ R 在命令行中输入 Jupyter notebook 对于小白来说，你可能会遇到这样的问题？ 如图所示 默认进入： 更改工作路径之后的截图 恭喜进入Coding的世界 Jupyter 高级配置Anaconda 配置 Flie：文件 Edit：编辑 View：视图 Cell： 单元格工具栏 Kernel 更改工作空间 方式1 ： 不是每次都好使 在其配置文件ipython_notebook_config.py中，有如下一句 # The directorytousefornotebooksandkernels. # c.NotebookApp.notebook_dir = u&#39;&#39; 该句就是用来指定其工作空间的，例如，默认的工作空间是：用户名文件夹，例如，现在想要将工作空间变为D:\\DataScience\\Jupyter，那么，需要做如下更改(要记得删掉注释#) # The directory to use for notebooks and kernels. c.NotebookApp.notebook_dir =u&#39;\\DataScience\\Jupyte&#39; 注意：路径最后一级后面不要加符号“\\” 如何找到该配置文件？ 在cmd中输入jupyter notebook --generate-config 如果该配置文件已经存在，那么，会出现如下信息,从中可以见到配置文件存在的位置，注意，此时，输入N，不要overwrite 如果该配置文件不存在，那么，将会初始化产生一个配置文件 在cmd中输入：ipython profile create 打开 jupyter_notebook_config.py 文件，找到 ## The directory to use for notebooks and kernels. #c.NotebookApp.notebook_dir = &#39;&#39; 将要指定的路径填入 #c.NotebookApp.notebook_dir = ‘ ‘ 中的 ‘ ‘ 中即可，同时注意将 #c 中的 # 删去，： c.NotebookApp.notebook_dir = &#39;D:\\DataScience\\Jupyte&#39; 保存，在命令行中再次输入 jupyter notebook 指令即可在指定的文件夹下启动。 方式2(绝招)： 进入工作目录文件夹 键盘Shift+鼠标右键-&gt;在此处打开命令窗口-&gt; 在弹出的命令窗口中输入：Jupyter Notebook 利用jupyter的cell是可以运行python文件的，即在cell中运行如下代码： %runfile.py 1 file.py为要运行的python程序，结果会显示在该cell中 为Jupyter Notebook添加目录功能 利用Anaconda安装Jupyter Notebook extensions conda install -c conda-forge jupyter_contrib_nbextensions 工具栏隐藏和更改 注：有时候jupyter输出后，需要滚动条才能看全，执行下列命令，修改输出段的字号大小，就不需要滚动条了。 在cmd 命令行执行！！！ #jt -t monokai -f fira -fs 13 -cellw 90% -ofs 11 -dfs 11 -T -N #-f(字体) -fs(字体大小) -cellw(占屏比或宽度) -ofs(输出段的字号) -T(显示工具栏) -N(显示自己主机名) jt -t gruvboxl -f fira -fs 13 -cellw 90% -ofs 11 -dfs 11 -T -N # 主题更改 pip install --upgrade jupyterthemes jt -l jt -t chesterish -T # 主题列表 chesterish grade3 gruvboxd gruvboxl monokai oceans16 onedork solarizedd solarizedl 恢复默认主题,只需执行代码：jt -r，即可恢复至原来的白色背景。 Jupyter快捷键 Jupyter 编辑模式 命令模式 Jupyter Notebook 有两种键盘输入模式。编辑模式，允许你往单元中键入代码或文本；这时的单元框线是绿色的。命令模式，键盘输入运行程序命令；这时的单元框线是灰色。 命令模式 (按键 Esc 开启) Enter : 转入编辑模式 Shift-Enter : 运行本单元，选中下个单元 Ctrl-Enter : 运行本单元 Alt-Enter : 运行本单元，在其下插入新单元 Y : 单元转入代码状态 M :单元转入markdown状态 R : 单元转入raw状态 1 : 设定 1 级标题 2 : 设定 2 级标题 3 : 设定 3 级标题 4 : 设定 4 级标题 5 : 设定 5 级标题 6 : 设定 6 级标题 Up : 选中上方单元 K : 选中上方单元 Down : 选中下方单元 J : 选中下方单元 Shift-K : 扩大选中上方单元 Shift-J : 扩大选中下方单元 A : 在上方插入新单元 B : 在下方插入新单元 X : 剪切选中的单元 C : 复制选中的单元 Shift-V : 粘贴到上方单元 V : 粘贴到下方单元 Z : 恢复删除的最后一个单元 D,D : 删除选中的单元 Shift-M : 合并选中的单元 Ctrl-S : 文件存盘 S : 文件存盘 L : 转换行号 O : 转换输出 Shift-O : 转换输出滚动 Esc : 关闭页面 Q : 关闭页面 H : 显示快捷键帮助 I,I : 中断Notebook内核 0,0 : 重启Notebook内核 Shift : 忽略 Shift-Space : 向上滚动 Space : 向下滚动 编辑模式 ( Enter 键启动) Tab : 代码补全或缩进 Shift-Tab : 提示 Ctrl-] : 缩进 Ctrl-[ : 解除缩进 Ctrl-A : 全选 Ctrl-Z : 复原 Ctrl-Shift-Z : 再做 Ctrl-Y : 再做 Ctrl-Home : 跳到单元开头 Ctrl-Up : 跳到单元开头 Ctrl-End : 跳到单元末尾 Ctrl-Down : 跳到单元末尾 Ctrl-Left : 跳到左边一个字首 Ctrl-Right : 跳到右边一个字首 Ctrl-Backspace : 删除前面一个字 Ctrl-Delete : 删除后面一个字 Esc : 进入命令模式 Ctrl-M : 进入命令模式 Shift-Enter : 运行本单元，选中下一单元 Ctrl-Enter : 运行本单元 Alt-Enter : 运行本单元，在下面插入一单元 Ctrl-Shift– : 分割单元 Ctrl-Shift-Subtract : 分割单元 Ctrl-S : 文件存盘 Shift : 忽略 Up : 光标上移或转入上一单元 Down :光标下移或转入下一单元 工欲善其事必先利其器 开启你的数据学习之美吧。","categories":[],"tags":[{"name":"数据可视化","slug":"数据可视化","permalink":"http://www.a2data.cn/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"}]},{"title":"零基础数据可视化入门学习","slug":"Python/数据可视化/零基础学习数据可视化","date":"2020-12-08T05:14:22.000Z","updated":"2025-05-04T18:37:40.538Z","comments":true,"path":"posts/cc50857e.html","link":"","permalink":"http://www.a2data.cn/posts/cc50857e.html","excerpt":"零基础学习数据可视化。","text":"零基础学习数据可视化。 数据可视化学习 数据可视化为什么会火？==为什么大家都对数据可视化比较感兴趣呢？== 大部分情况下，上级更关心呈现的结果。当可视化的结果呈现在你眼前时，你才能直观地体会到“数据之美”。 例如 ：腾讯云示例， 永辉超市 ==图片在内容表达上，要远胜于文字，它不仅能体现数据真实性，还能给人很大的想象空间。== 什么是数据可视化？做为⼀名数据分析师，掌握可视化技能是必不可少的。 我们经常听到的Tableau 和 PowerBI 是商业可视化工具，在可视化灵活分析上功能强⼤，主要目标用户是较专业的数据分析师。同时在工作场景中使用率高，因此掌握对于晋升和求职都很有帮助，之后DataScience也会推出相关内容。 Tableau 地址：https://www.tableau.com/zh-cn/trial/visualize-your-data?utm_campaign_id=2017049&amp;utm_campaign=Prospecting-VISANLYT-ALL-ALL-ALL-ALL&amp;utm_medium=Paid+Search&amp;utm_source=Baidu&amp;utm_language=CN&amp;utm_country=GrCHINA-CN&amp;kw=%e7%bd%91%e7%bb%9c%e5%8f%af%e8%a7%86%e5%8c%96%e5%b7%a5%e5%85%b7&amp;adgroup=Data+Visualization-Tool&amp;ag_kwid=17202-3-36e95ed5d95e59af.d2b20cf962abd475 PowerBi 地址： https://powerbi.microsoft.com/zh-cn/ https://video1.grapecity.com.cn/WynEnterprise/online/wyn4.0.mp4 注： 本视频只是为了展示powerbi的应用。 并无侵权行为。如上为源地址。 Your browser does not support the video tag. Python语言 Python是数据分析的首选语言，如果我们的学习目标是数据挖掘工程师，或者算法工程师，那么最重要的就是要了解，并且熟练掌握Python的数据可视化，在校学生以及科研人员也可==使用Python进行可视化==。此外当我们在使用Python与数据库交互时，获取数据后直接在Python进行分析和观察会更为方便。 Python里包括了众多可视化库， 比如： Matplotlib Seaborn Bokeh Plotly Pyecharts、Mapbox和Geoplotlib。 其中使用频率，最需要掌握的就是Matplotlib和Seaborn。Matplotlib是Python的可视化基础库，作图风格和MATLAB类似，所以称为Matplotlib。⼀般学习Python数据可视化，都会从 Matplotlib⼊⼿，然后再学习其他的Python可视化库。 Seaborn是⼀个基于Matplotlib的⾼级可视化效果库，针对Matplotlib做了更⾼级的封装，让作图变得更加容易 本次学习的内容包含有Python安装，语言基础，绘图基础，和使用Matplotlib和Seaborn库绘制十个常用的可视化试图，如： 连Excel都不会也能学？==你连Excel都玩不明白,也敢来学习数据可视化么？== But 你知道很多人还没开始就==结束==了么？ 根据小编组织多次学习活动来说,很多人只是看看，并没有勇气尝试，以及试错。有句话说的很对。 总是在会凌晨想通很多事情呐 又在天亮之后，忘得一干二净。 吐槽一下首先声明一点,上次我们Team 耗时两个月 打造的Python入门学习，说实话挺失败的，付费3元过滤广告党, 按时完成作业，我们发红包激励，送书发的顺丰快递。 21天，不但赚了，而且可以学习一门不错得知识。 最后那篇文章还被==举报== 说我们违规使用 付费功能，我就呵呵了。 活动刚结束。然后说违规。 违规截图： 上期活动说明： 活动结束日期： 课程流程如下 感谢坚持下来得朋友： 写公号的初心认识我的人，大多数都知道我是跨行的,跨的很大的那种。 前段时间项目团队有个小伙伴说了一句!! ==你凭什么可以写公号呢？== 我当时说，我是先分享我的很多经历,学习方式,然后结合更多人来传达更多的知识价值。 做 价值复利 在这个快时代，知识泛滥，但是对小白的教程一点也不友好。就拿CSDN来说，你经常百度到的东西，就是一个链接，还能原创。说实话很浪费时间。 公众号的内容是个宝藏，我也会花时间整理出来给大家。希望可以在跨行，亦或者兴趣道路的探索上，可以帮助到更多的人。 ==话不多说了，时隔多月，我们回来了。大纲如下， 那么如何参与学习呢？== 参与方式活动说明： 本次活动为零环境搭建,可以再课程结束后再搭建环境。(学习环境由本公号提供）也就是有网的情况下，你就可以学习了。 零基础,或者对数据可视化感兴趣的人群。 在留言区，说出你对公号的看法,或者表达为啥要参与学习 加入学习群,精选留言后,联系小编开通学习环境以及注意事项。 特别声明： 本次活动纯属公益，不涉任何金钱。感谢大家的参与，希望可以帮助更多的人。 学习方式： 独家零环境搭建提供支持 每天晚上在线答疑 优秀学员获得特别奖励 12.10-12.18 扫码加入： 添加小编微信回复，进群 进入粉丝交流群。 回复关键字: 数据可视化 进入数据可视化学习交流群。","categories":[],"tags":[{"name":"数据可视化","slug":"数据可视化","permalink":"http://www.a2data.cn/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"}]},{"title":"Win10子系统","slug":"Linux/Win10子系统","date":"2020-11-30T15:36:30.000Z","updated":"2025-05-04T18:37:40.544Z","comments":true,"path":"posts/a9378efd.html","link":"","permalink":"http://www.a2data.cn/posts/a9378efd.html","excerpt":"Win10 子系统。","text":"Win10 子系统。 Win10子系统除了Vmware 中安装Linux虚拟机之外，如何快速在Win10下搭建 Linux系统呢？ 1、启用开发者模式打开win10 设置， 点击 更新和安全 点击开发者选项，启用开发人员模式 2、更改系统功能使用Win + X 快捷键 ，调出系统管理菜单后点击应用和功能，然后拉到底下，选择程序和功能 选中启用或关闭Windows功能 勾选适用于Linux的Windows子系统，然后确认并重启就可以了 重新启动 3、安装Linux系统打开功能以后系统中其实还没有安装Linux，需要使用cmd完成安装。首先按Win+R开启cmd命令输入框，然后输入lxrun /install /y来下载Linux系统（注意斜杠后面前要空一格，要不然无法识别命令） 下载最新版本 安装好了如下 点击启动 一定要等安装完成之后，如下界面设置用户名和密码。 设置对应得用户名,密码。 UserName: DataBricks PassWd: 123 打开 MobaXterm 默认会自动多一个WSL-Ubuntu的 Session的。到此,你就算成功安装好Win10钟 Linux的子系统了。体验一波操作吧。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"}]},{"title":"edge复制网址在微信PC端被保存成文字","slug":"Tools/edge浏览器复制异常解决","date":"2020-11-30T03:37:37.000Z","updated":"2025-05-04T18:37:40.532Z","comments":true,"path":"posts/e73bc34f.html","link":"","permalink":"http://www.a2data.cn/posts/e73bc34f.html","excerpt":"最近使用Edge 复制网址,粘贴到微信，发现网址会被保存为文字。","text":"最近使用Edge 复制网址,粘贴到微信，发现网址会被保存为文字。 问题现象：浏览器edge复制网址在微信PC端被保存成文字，举例：复制https://www.baidu.com，如下图所示 问题分析： 1、将复制的网址粘贴在创建的txt文本中有效，怀疑是微信PC端bug，重装微信PC端，问题没有改善 2、怀疑是edge的bug，使用IE复制网址粘贴在微信PC端，没有出现问题 问题解决：将edge的URL 复制和粘贴格式默认从链接更改为文本，如下图所示：","categories":[],"tags":[{"name":"Win10","slug":"Win10","permalink":"http://www.a2data.cn/tags/Win10/"},{"name":"Edge","slug":"Edge","permalink":"http://www.a2data.cn/tags/Edge/"}]},{"title":"数据仓库之任务调度","slug":"DataBase/数据仓库/数据仓库之任务调度","date":"2020-11-15T10:20:24.000Z","updated":"2021-01-24T13:53:54.806Z","comments":true,"path":"posts/646dbc2e.html","link":"","permalink":"http://www.a2data.cn/posts/646dbc2e.html","excerpt":"数据仓库之任务调度。","text":"数据仓库之任务调度。 概述随着数据仓库的开发，ETL作业会越来越多，怎么把这些作业有序的运行起来，就需要一个健壮的调度系统来保证数据能够准确、及时的提供给BI应用程序。 调度系统架构 ETL作业 数据仓库的ETL作业可能不至一种，需要把各种作业再次进行封装，建立作业的标准格式，统一作业的输入参数、输出参数和参数格式，达到所有的作业调度方式一致。 作业管理 提供便捷的作业配置和依赖关系配置页面。 作业调度 根据作业调度算法进行自动执行，如果发生异常情况可以进行人工重启和停止。 作业监控 对作业运行情况进行监控，发送邮件或者提供监控页面 常用的调度组件 组件名 属性标签 特性 使用场景 azkaban 调度工具 处理有依赖关系的复杂任务调度，只支持mysql存储基本信息 常用调度工具之一 crontab linux自带调度工具 简单任务调度 适用日常少量调度 ooize 调度工具 处理复杂任务调度，但好像并不好用 大数据领域调度工具之一（Oozie, Azkaban,Cascading,Hamake） 作业调度状态 初始化：把新添加的作业加入到执行计划中。 待运行：根据时间和依赖关系把可执行的任务更新为待运行。 运行中：把待运行的任务执行，更新为运行中。 结束：作业运行完成，分为成功和失败。","categories":[],"tags":[{"name":"数仓","slug":"数仓","permalink":"http://www.a2data.cn/tags/%E6%95%B0%E4%BB%93/"}]},{"title":"数据仓库之维度建模","slug":"DataBase/数据仓库/数据仓库维度建模","date":"2020-11-14T16:35:41.000Z","updated":"2025-05-04T18:37:40.530Z","comments":true,"path":"posts/29966d.html","link":"","permalink":"http://www.a2data.cn/posts/29966d.html","excerpt":"数据仓库架构到底是怎么设计的，意义是什么?","text":"数据仓库架构到底是怎么设计的，意义是什么? 概述在数据建模过程中，最简单的描述就是按照事实表、维度表来构建数据仓库、数据集市。在维度建模方法体系中，维度是描述事实的角度，如日期、客户、供应商等，事实是要度量的指标，如客户数、销售额等。 维度建模还会分为星型模型、雪花模型等，各有优缺点，但很少直接回答一个问题，也就是数据仓库为什么要采用维度建模？ 维度模型是数据仓库领域大师Ralph Kimball 所倡导，他的《[数据仓库工具箱]》，是数据仓库工程领域最流行的数仓建模经典。维度建模以分析决策的需求出发构建模型，构建的数据模型为分析需求服务，因此它重点解决用户如何更快速完成分析需求，同时还有较好的大规模复杂查询的响应性能。 星型模型与OLAP多维数据库 为什么要进行数据建模 进行全面的业务梳理，改进业务流程。 在业务模型建设的阶段，能够帮助我们的企业或者是管理机关对本单位的业务进行全面的梳理。通过业务模型的建设，我们应该能够全面了解该单位的业务架构图和整个业务的运行情况，能够将业务按照特定的规律进行分门别类和程序化，同时，帮助我们进一步的改进业务的流程，提高业务效率，指导我们的业务部门的生产。 建立全方位的数据视角，消灭信息孤岛和数据差异。 通过数据仓库的模型建设，能够为企业提供一个整体的数据视角，不再是各个部门只是关注自己的数据，而且通过模型的建设，勾勒出了部门之间内在的联系，帮助消灭各个部门之间的信息孤岛的问题，更为重要的是，通过数据模型的建设，能够保证整个企业的数据的一致性，各个部门之间数据的差异将会得到有效解决。 解决业务的变动和数据仓库的灵活性。 通过数据模型的建设，能够很好的分离出底层技术的实现和上层业务的展现。当上层业务发生变化时，通过数据模型，底层的技术实现可以非常轻松的完成业务的变动，从而达到整个数据仓库系统的灵活性。 帮助数据仓库系统本身的建设。 通过数据仓库的模型建设，开发人员和业务人员能够很容易的达成系统建设范围的界定，以及长期目标的规划，从而能够使整个项目组明确当前的任务，加快整个系统建设的速度。 事实表发生在现实世界中的操作型事件，其所产生的可度量数值，存储在事实表中。从最低的粒度级别来看，事实表行对应一个度量事件，例如电商行业中的订单表，每完成一个订单，就会在表中增加一条记录，实际上就是业务上的流水表，表内不存放实际的内容，是一堆维度表主键的集合，通过这些维度主键可以对应到维度表中的一条记录。 维度表每个维度表都包含单一的主键列。维度表的主键可以作为与之关联的任何事实表的外键，这里的主键和外键可以是实际表中创建的，也可以是物理意义上的虚拟主键和外键。 维度表通常是比较宽、扁平型的非规范表，包含大量的低粒度属性。 以上面两种表简单举一个列子: 建模原则 高内聚和低辑合 将业务相近或者相关、粒度相同的数据设计为一个逻辑或者物理模型：将高概率同时访问的数据放一起，将低概率同时访问的数据分开存储。 核心模型与扩展模型分离 建立核心模型与扩展模型体系，核心模型包括的宇段支持常用的核心业务，扩展模 型包括的字段支持个性化或少量应用的需要 ，不能让扩展模型的宇段过度侵人核心模型，以免破坏核心模型的架构简洁性与可维护性。 公共处理逻辑下沉及单一 越是底层公用的处理逻辑越应该在数据调度依赖的底层进行封装与实现，不要让公用的处理逻辑暴露给应用层实现，不要让公共逻辑多处同时存在。 成本与性能平衡 适当的数据冗余可换取查询和刷新性能，不宜过度冗余与数据复制。 数据可回滚 不改变处理逻辑，不修改代码的情况下重跑任务结果不变 一致性 字段命名及定义必须一致 命名清晰、可理解 表命名需清晰、一致，表名需易于使用方理解 维度模型设计在数仓中存在几种数据存储方式的算法： 1.历史快照： 每天都是增量数据，保存每日增量，例如流水表 2.拉链： 对于流水记录存储，一般存储5年的记录，例如在银行业中，每天的流水记录太大，数仓存储压力太过大，用历史拉链的方式节省存储空间拉链表是一种数据库设计模式，类似与面向对象的23中设计模式，用于存储历史数据和分析时间维度。可以查看某一个时间点活着时间段的历史快照信息； 3.全量覆盖： 配置信息可以用这种方式 宽事实表设计的优缺点： 业务直观，在做业务的时候，这种表特别方便，直接能对到业务中。 使用方便，写sql的时候很方便。 数据冗余巨大，真的很大，在几亿的用户规模下，他的订单行为会很恐怖、粒度僵硬，什么都写死了，这张表的可复用性太低。 维度模型设计的优缺点： 数据冗余小（因为很多具体的信息都存在相应的维度表中了，比如客户信息就只有一份） 结构清晰（表结构一目了然） 便于做OLAP分析（数据分析用起来会很方便） 增加使用成本，比如查询时要关联多张表 数据不一致，比如用户发起购买行为的时候的数据，和我们维度表里面存放的数据不一致","categories":[],"tags":[{"name":"数仓","slug":"数仓","permalink":"http://www.a2data.cn/tags/%E6%95%B0%E4%BB%93/"}]},{"title":"ETL开发","slug":"DataBase/数据仓库/数据仓库之ETL开发","date":"2020-11-14T04:50:01.000Z","updated":"2025-05-04T18:37:40.531Z","comments":true,"path":"posts/ca165cd5.html","link":"","permalink":"http://www.a2data.cn/posts/ca165cd5.html","excerpt":"数据仓库之ETL开发。","text":"数据仓库之ETL开发。 ETL开发概述ETL是数据仓库的后台，主要包含抽取、清洗、规范化、提交四个步骤，传统数据仓库一般分为四层模型。 分层的作用： 1.划分ETL阶段工作重心，便于管理 2.降低开发和维护成本 3.减少需求变化带来的冲击 4.便于数据问题跟踪 名词解释： ODS——操作性数据 DW——数据仓库 DM——数据集市 STG层在维度建模阶段已经确定了源系统，而且对源系统进行了数据评估。STG层是根据CDC策略把各个源系统的数据抽取到数据仓库中。STG层主要是面向批处理的形式，如果是根据日志信息实时同步，可以跳过STG层直接进入ODS层。 STG作用： 减轻源系统压力；数据备份，支持重跑；便于问题跟踪；数据质量检查，主要起到缓冲的作用。 开发步骤： 确定CDC策略，根据源系统的数据状况选择一个合适的CDC策略。 设计Mapping文档。 设计物理模型，STG的物理模型一般包括源系统的所有字段和审计字段，例如：源系统名称，源表名称，加载时间，加载方式。可以去掉其他约束条件，比如主键、索引，默认值。如果源表和目标表的数据库类型不同，最好字段长度要进行扩充，一般目标表的数据类型就选择几种常用，长度就选择几个固定的长度。 抽取数据，STG层面向异构数据源，最好选择用ETL工具，一般ETL工具都支持多种数据源。STG层不做数据转换。 加载数据，STG层一般保留7天或一月的数据 ODS层ODS层是把STG层数据进行历史存档，保留源系统的所有历史数据，如果是流式的，可以跳过STG层，实时同步到ODS层。 ODS作用： 全量存储源系统的数据；支持下游系统实时查询业务；数据质量检查 开发步骤： 设计Mapping文档。 设计物理模型，ODS的物理模型一般包括源系统的所有字段和审计字段，但是和源系统最主要的区别是ODS层加了逻辑删除标记和增量时间戳。因为很多源系统都可能进行物理删除数据，即使有逻辑删除标记，但是也可以在后台人工删除数据。 抽取数据，ODS层从STG层抽取数据，在同一个数据平台上，可以采用ETL工具，也可以手工编码。 加载数据，进行数据比较，判断是否有物理删除情况，如果有打上删除标记。ODS层保留全量数据。 DW层DW层是清洗、规范化，提交一致化维度和事实的工作区，建立反规范化的维度模型。 数据清洗： 数据清洗是发现数据质量问题并纠正数据的过程，通用的方法是戴明质量环 主要步骤： 定义数据质量需求，根据业务需求和数据剖析结果确定数据质量需求的优先级。 制定数据质量测量类型 提交数据质量测量结果表，通常异常数据处理策略有：中断处理；把拒绝记录放在错误时间表里；只做标记，数据继续处理 纠正数据分为四个优先级：必须在ETL处理；最好在ETL处理；最好在源头处理；必须在源头处理 数据规范化： 由于数据仓库的数据来源各个业务系统，每个业务系统相对都是封闭的，他们在命名、取值上都有自己的特点。规范化就是经过标准化、去重、合并、拆分、整合等过程把各个业务系统的数据统一命名，统一取值，建立企业标准版本数据。 主要步骤：1.数据标准化 从数据的内容、格式、命名、计算规则等输出为唯一的版本数据，把各个源系统的相同描述对象但是不同取值进行统一，比如：性别字段，有的源系统用0和1或Man和Wonen。通过映射表统一命名为M和F。 2.删除重复数据 如果源系统中存在重复数据或者多个源系统维护了相同对象的数据，这时候就要根据保留规则，删除重复数据，只保留唯一的一条数据。 3.数据共存 把各个业务系统的数据经过拆分、合并、整合。例如相同的客户号，二个源系统都维护了这个客户的联系方式，这时候就要根据业务规则来选择保留哪那个源系统的值。 维度表的提交： 1.确认粒度 维度表的粒度就是表的业务主键，根据业务主键来判断记录的唯一性。 2.选择代理键生成器 ETL工具和数据库都有设置字段自增长的功能。 3.选择维度表类型 根据业务系统的实际情况选择合适的维度表类型，一般采用缓慢变化维类型1和类型2。 4.增量加载维度数据 维度表的每个字段都要设置默认值，不能为空。首次加载的时候要有一条代理键为-1的默认记录，为了防止事实表查找不到代理键。 5.生成代理键管道 为了生成事实表的维度代理键，一般会建一个查找维表，查找维表包含业务主键和代理键的映射关系。 事实表的提交： 1.选择事实表类型 根据业务需求选择合适的事实表类型，一般会先建最细粒度的事务事实表，根据事务事实表建周期快照或累积事实表。 2.用代理键替换主键 根据事实表中维表的业务主键关联查找维表替换成代理键，如果关联不上设置为-1。 3.增量加载事实数据 事实表的每个字段不能为空，事实表主要包含事实粒度的业务主键、维表业务主键、维表代理键、源表的主键、逻辑删除标识和事实。便于重新加载事实表和问题跟踪。由于事实表的数据量大，一般采用分区的方式进行存储。 4.提交错误事实表 把加载事实表的拒绝记录存储在错误事实表中，以便进行数据质量跟踪。 5.事实表合并 一级事实表都是根据单个业务过程建立的，为了便于分析和重用，需要把多个业务过程的事实表进行合并，形成二级事实表。 6.事实表归档 随着时间的推移，事实表中会存放大量的历史数据，如果这些数据很少再出现在统计分析中，需要把这些数据迁移到其他表中或以文件格式存储。 DM层DM层根据业务需求把DW层数据进行聚合或生成宽表。 创建聚合事实表 前台展现的数据一般都是聚合后的数据，聚合后的数据量比最细粒度的事实表小很多，查询性也有很大的提升。 创建聚合表的方法 1.增量加载，创建聚合表，增量加载聚合表。 2.聚合导航，用户通过报表分析工具，根据用户请求把基础事实表自动生成聚合数据。 3.物化视图，创建物化视图定时刷新聚合表。 创建缩小维度表 由于聚合事实表的粒度和基础事实表粒度不同，需要创建和聚合表相同粒度的维度表，这些维度表只是基础维度表的缩小版。 ETL优化1.减少磁盘I/O 关联查询的时候，尽可能把无效的数据过滤掉 只查出需要的列 大数据量尽量不要有排序 在加载数据时关闭日志 2.分区和并行 大数据量可以进行分区 查询和任务调度都可以进行并行处理 3.增量加载 4.增加索引 5.大而化小,复杂的查询可以分成多个子任务来执行。 6.重用结果集,把多个查询任务的共用数据可以单独建临时表。","categories":[],"tags":[{"name":"数仓","slug":"数仓","permalink":"http://www.a2data.cn/tags/%E6%95%B0%E4%BB%93/"}]},{"title":"数据质量管理","slug":"DataBase/数据仓库/数据质量管理","date":"2020-11-13T01:49:55.000Z","updated":"2025-05-04T18:37:40.529Z","comments":true,"path":"posts/65aeda8b.html","link":"","permalink":"http://www.a2data.cn/posts/65aeda8b.html","excerpt":"数据质量是如何管理的?","text":"数据质量是如何管理的? 数据质量管理 概述数据质量的高低代表了该数据满足数据消费者期望的程度，这种程度基于他们对数据的使用预期。数据质量必须是可测量的，把测量的结果转化为可以理解的和可重复的数字，使我们能够在不同对象之间和跨越不同时间进行比较。 数据质量管理 是通过计划、实施和控制活动，运用质量管理技术度量、评估、改进和保证数据的恰当使用。 数据质量产生的根本原因 源系统: 源系统的数据结构发生变化，这是常有的事，数据仓库只是数据存储中心，而源系统的改变会造成数据仓库中数据质量发生变化 ETL: 源系统业务流程发生了变更 业务需求： 源系统数据录入错误或者延迟 源系统随着时间的推移，数据发生了演变 需求不明确或者满足不了客户需求 ETL映射规则错误 ETL程序错误 数据没有及时到达或者依赖关系错误 源系统的业务数据与业务需求发生冲突 数据质量面临的挑战数据的污染是在数据仓库中处理的，延伸出去就形成了专业的数据治理，但是数据的污染却在数据仓库之外发生的，所有必须要清楚数据的污染源有哪些： 系统转换： 源系统的系统升级、转换、迁移是数据污染的重要原因 数据老化： 在经历一代又一代的系统升级、转换、迁移，历史数据往往无法满足当时时间的业务需求 复杂的系统集成： 源系统种类繁多，关系日渐复杂，出现污染数据的可能性越来越大 拙劣的数据库设计： 坚持实体完整性和参考完整性规则可以防止一些数据污染，但是目前数据仓库存在两种观点：注重模型、注重集市，围绕业务进行数据库设计，这两种观点与传统的十大主题设计存在矛盾点。 数据输入的不完整性： 源系统的数据输入是数据污染的主要来源，信息输入错误会给数据仓库模型建立造成很大的压力 缺乏数据治理相关的政策： 如果一个公司对数据质量没有明确的相关政策，那么他的数据质量不可能得到保证 数据质量的指标 准确性 准确性要求数据能够正确描述客观世界。比如某用户姓名拼音mu chen错误的录入成了muc hen，就应该弹出警告语； 唯一性（视情况而定） 唯一性要求数据不能被重复录入，或者不能有两个几乎相同的关系。比如张三李四在不同业务环境下分别建立了近乎相同的关系，这时应将这两个关系合并； 完整性 完整性要求进行数据搜集时，需求数据的被描述程度要高。比如一个用户的购买记录中，必然要有支付金额这个属性；规则验证。 一致性 一致性要求不同关系、或者同一关系不同字段的数据意义不发生冲突。 比如某关系中昨天存货量字段+当天进货量字段-当天销售量字段等于当天存货量就可能是数据质量有问题； 及时性 及时性要求数据库系统中的数据”保鲜”。比如当天的购买记录当天就要入库； 统一性 统一性要求数据格式统一。比如nike这个品牌，不能有的字段描述为”耐克”，而有的字段又是”奈克”； 数据质量管理的方法论在数据治理方面，不论是国际的还是国内的，我们能找到很多数据治理成熟度评估模型这样的理论框架，作为企业实施的指引。而说到数据质量管理的方法论，其实业内还没有一套科学、完整的数据质量管理的体系。很多企业对数据质量的重视程度还不够，即使部分企业在朝着这个方向努力，也是摸着石头过河。 下图是ISO9001基于PDCA的质量管理核心思想，其重点强调以客户为关注焦点、领导作用、全员参与、过程方法、持续改进、循证决策和关系管理。 数据质量监控数据质量监控可以分为数据质量的事前预防控制、事中过程控制和事后监督控制： 数据质量问题的预防控制最有效的方法就是找出发生数据质量问题的根本原因并采取相关的策略进行解决。 1）确定根本原因：确定引起数据质量问题的相关因素，并区分它们的优先次序，以及为解决这些问题形成具体的建议。 2）制定和实施改进方案：最终确定关于行动的具体建议和措施，基于这些建议制定并且执行提高方案，预防未来数据质量问题的发生。","categories":[],"tags":[{"name":"数仓","slug":"数仓","permalink":"http://www.a2data.cn/tags/%E6%95%B0%E4%BB%93/"}]},{"title":"数据仓库元数据","slug":"DataBase/数据仓库/数据仓库之元数据管理","date":"2020-11-12T01:07:51.000Z","updated":"2021-01-24T13:53:55.048Z","comments":true,"path":"posts/6637aa6e.html","link":"","permalink":"http://www.a2data.cn/posts/6637aa6e.html","excerpt":"数据仓库架构到底是怎么设计的，意义是什么?","text":"数据仓库架构到底是怎么设计的，意义是什么? 元数据管理概述元数据通常定义为”关于数据的数据”,在数据仓库中是定义和描述DW/BI系统的结构，操作和内容的所有信息。元数据贯穿了数据仓库的整个生命周期，使用元数据驱动数据仓库的开发，使数据仓库自动化，可视化。 元数据在构建数仓过程中，定义了源数据系统到数据仓库的映射、数据转换的规则、数据仓库的逻辑结构、数据更新的规则、数据导入历史记录以及装载周期等相关内容。数据抽取和转换的专家以及数据仓库管理员正是通过元数据高效地构建数据仓库。 元数据类型1.业务元数据业务元数据指从业务角度描述业务领域相关的概念、关系和规则的数据，包括业务术语和业务规则等信息。 2.技术元数据技术元数据指描述系统中技术细节相关的概念、关系和规则的数据，包括对数据结构、数据处理方面的描述，以及数据仓库、ETL、前端展现等技术细节方面的信息。 技术元数据又细分为： 数据源元数据 ETL元数据 数据仓库元数据 BI元数据 3.管理元数据管理元数据指描述管理领域相关的概念、关系和规则的数据，主要包括管理流程、人员组织、角色职责等信息。 元数据获取途径 外部数据源 主要有源系统、ETL工具、报表工具的元数据 数据仓库 数据库物理模型的元数据 手工补录 主要有Mapping文档、任务配置、业务规则、业务术语、业务人员手工补录的数据，大多数是规则明确的业务数据 元数据功能血缘分析： 向上追溯元数据对象的数据来源。 影响分析：向下追溯元数据对象对下游的影响。 同步检查： 检查源表到目标表的数据结构是否发生变更。 指标一致性分析： 定期分析指标定义是否和实际情况一致。 实体关联查询： 事实表与维度表的代理键自动关联 元数据应用ETL自动化管理： 使用元数据信息自动生成物理模型，ETL程序脚本，任务依赖关系和调度程序。 数据质量管理： 使用数据质量规则元数据进行数据质量测量。 数据安全管理： 使用元数据信息进行报表权限控制。 数据标准管理： 使用元数据信息生成标准的维度模型。 数据接口管理： 使用元数据信息进行接口统一管理。 数据质量管理概述数据质量的高低代表了该数据满足数据消费者期望的程度，这种程度基于他们对数据的使用预期。数据质量必须是可测量的，把测量的结果转化为可以理解的和可重复的数字，使我们能够在不同对象之间和跨越不同时间进行比较。 数据质量管理是通过计划、实施和控制活动，运用质量管理技术度量、评估、改进和保证数据的恰当使用。 数据质量产生的根本原因 源系统：源系统的数据结构发生变化，这是常有的事，数据仓库只是数据存储中心，而源系统的改变会造成数据仓库中数据质量发生变化 ETL：源系统业务流程发生了变更 业务需求： 源系统数据录入错误或者延迟 源系统随着时间的推移，数据发生了演变 需求不明确或者满足不了客户需求 ETL映射规则错误 ETL程序错误 数据没有及时到达或者依赖关系错误 源系统的业务数据与业务需求发生冲突 数据质量面临的挑战数据的污染是在数据仓库中处理的，延伸出去就形成了专业的数据治理，但是数据的污染却在数据仓库之外发生的，所有必须要清楚数据的污染源有哪些： 系统转换：源系统的系统升级、转换、迁移是数据污染的重要原因 数据老化：在经历一代又一代的系统升级、转换、迁移，历史数据往往无法满足当时时间的业务需求 复杂的系统集成：源系统种类繁多，关系日渐复杂，出现污染数据的可能性越来越大 拙劣的数据库设计： 坚持实体完整性和参考完整性规则可以防止一些数据污染，但是目前数据仓库存在两种观点：注重模型、注重集市，围绕业务进行数据库设计，这两种观点与传统的十大主题设计存在矛盾点。 数据输入的不完整性：源系统的数据输入是数据污染的主要来源，信息输入错误会给数据仓库模型建立造成很大的压力 缺乏数据治理相关的政策：如果一个公司对数据质量没有明确的相关政策，那么他的数据质量不可能得到保证 数据质量的指标准确性准确性要求数据能够正确描述客观世界。比如某用户姓名拼音mu chen错误的录入成了muc hen，就应该弹出警告语； 唯一性（视情况而定）唯一性要求数据不能被重复录入，或者不能有两个几乎相同的关系。比如张三李四在不同业务环境下分别建立了近乎相同的关系，这时应将这两个关系合并； 完整性完整性要求进行数据搜集时，需求数据的被描述程度要高。比如一个用户的购买记录中，必然要有支付金额这个属性；规则验证。 一致性一致性要求不同关系、或者同一关系不同字段的数据意义不发生冲突。 比如某关系中昨天存货量字段+当天进货量字段-当天销售量字段等于当天存货量就可能是数据质量有问题； 及时性及时性要求数据库系统中的数据”保鲜”。比如当天的购买记录当天就要入库； 统一性统一性要求数据格式统一。比如nike这个品牌，不能有的字段描述为”耐克”，而有的字段又是”奈克”； 元数据的作用在数据仓库中，元数据的主要作用如下。 （1）描述哪些数据在数据仓库中，帮助决策分析者对数据仓库的内容定位。 （2）定义数据进入数据仓库的方式，作为数据汇总、映射和清洗的指南。 （3）记录业务事件发生而随之进行的数据抽取工作时间安排。 （4）记录并检测系统数据一致性的要求和执行情况。 （5）评估数据质量。","categories":[],"tags":[{"name":"数仓","slug":"数仓","permalink":"http://www.a2data.cn/tags/%E6%95%B0%E4%BB%93/"}]},{"title":"数据仓库架构的设计","slug":"DataBase/数据仓库/数据仓库架构的设计","date":"2020-11-11T00:49:45.000Z","updated":"2025-05-04T18:37:40.531Z","comments":true,"path":"posts/c54e1e5.html","link":"","permalink":"http://www.a2data.cn/posts/c54e1e5.html","excerpt":"数据仓库架构到底是怎么设计的，意义是什么?","text":"数据仓库架构到底是怎么设计的，意义是什么? 概述架构是数据仓库建设的总体规划，从整体视角描述了解决方案的高层模型，描述了各个子系统的功能以及关系，描述了数据从源系统到决策系统的数据流程。业务需求回答了要做什么，架构就是回答怎么做的问题。 数据仓库架构数据仓库的核心功能从源系统抽取数据，通过清洗、转换、标准化，将数据加载数据仓库中,通过后续加工到BI平台，进而满足业务用户的数据分析和决策支持 层设施底层设施为架构提供了基础，底层设施包括硬件、数据库平台、网络。 硬件主要指服务器硬件，主要有数据库服务器、ETL服务器、调度服务器、报表服务器、BI门户服务器、接口服务器。 平台分为二大类：联机事务处理OLTP（on-line transaction processing）、联机分析处理OLAP（On-Line Analytical Processing），OLAP是为数据分析而设计的数据库管理系统。主要有Oracel，MySQL，Teradata, Greenplum，Hive。 网络是底层设施的基础，特别是大数据时代对网络的要求越来越高。 数据架构数据架构主要描述数据从源系统抽取数据，然后经过清洗、规范化、提交形成标准模型，最终提交给业务用户，以及对数据的管理。 源系统: 数据仓库一般会面临多个、异构数据源的问题，主要分为结构化，半结构化以及非结构化数据。为了便于管理需要对源系统建立元数据信息。 抽取: 因为源系统的多样性，源抽取阶段一般选择使用工具。在抽取之前还要做以下工作： 数据剖析是对数据的技术性分析，对数据的内容、一致性和结构进行描述。对源系统的数据质量进行评估。 由于面临多个、异构的源系统,抽取方式不尽相同,例如:数据库直连抽取,kettle抽取,Informatica抽取,ftp抽取文件,生成表结构文件,java方式抽取,sqludr2抽取 抽取的数据类型也有区分,数据加载入库方式将在后续内容中讲到: 数据转换: 数据从源系统抽取过来之后，就要进入数据转换阶段。 这一阶段是数据仓库开发核心阶段。主要有以下步骤： 清洗: 数据清洗是制定转换规则，筛选数据并纠正数据的过程。清洗的目的是改进源系统的数据质量，但是不要在数据仓库做过多的清洗，源系统的数据质量应该在源头处理。清洗的主要内容包括： 规范化: 规范化就是整合各个源系统的数据，把数据统一命名，统一取值，建立企业标准版本数据。主要内容包括： 提交: 提交就要根据维度模型生成维度表和事实表。 提交主要内容包括： 选择合适的缓慢变化维类型 为维表生成代理键 管理不同粒度的层次维 管理专项维 生成维度桥接表 生成代理键管道 选择合适的事实表类型 处理延迟到达的事实 生成维度表 生成事实表 聚集: 聚集是指根据事务事实表进行更高粒度的聚合以及生成相对应的维度表. 行轻度汇总企业数据模型的构建，能够涵盖业务的各个层面，包括交易数据、主数据和参考数据，为整个企业级的数据集成提供一个完整的一致的逻辑视图。为了确保模型对企业经营的映射和相对稳定，采用范式（3NF）化模型，进行定制,为系统间数据交换和使用提供公共汇总数据 例如在金融行业中,会根据Teradata 金融数据模型进行模型层开发 BI应用程序架构数据仓库是数据处理的后台，业务用户并不关心后台怎么处理。BI应用是数据呈现的前台，是业务用户进行查询的入口。BI应用程序的体验也是衡量数据仓库是否成功的主要因素。 数据服务接口查询: 在数据仓库中进行业务数据的轻度汇总,给第三方业务提供数据查询接口 即席查询: 业务用户根据自己的需求，自定义查询请求，后台自动组织SQL语句访问维度模型 报表展现: 根据业务用户的需求，进行定制报表 驾驶舱和仪表盘: 它是向企业展示度量信息和关键业务指标现状的数据可视化工具。 数据仓库架构图 数据仓库平台逐步从BI报表为主到分析为主、到预测为主、再到操作智能为目标。 数据仓库在系统中得定位数据仓库系统的作用： 能实现跨业务条线、跨系统的数据整合， 为管理分析和业务决策提供统一的数据支持。 数据仓库能够从根本上帮助你把公司的运营数据转化成为高价值的可以获取的信息（或知识），并且在恰当的时候通过恰当的方式把恰当的信息传递给恰当的人。","categories":[],"tags":[{"name":"数仓","slug":"数仓","permalink":"http://www.a2data.cn/tags/%E6%95%B0%E4%BB%93/"}]},{"title":"什么是需求？","slug":"DataBase/数据仓库/什么是需求","date":"2020-11-10T00:34:33.000Z","updated":"2025-05-04T18:37:40.530Z","comments":true,"path":"posts/6f521982.html","link":"","permalink":"http://www.a2data.cn/posts/6f521982.html","excerpt":"数仓需求的来源,以及流程。","text":"数仓需求的来源,以及流程。 需求 概述: 业务需求(business requirement)表示组织或客户高层次的目标 用户需求(user requirement)描述的是用户的目标,或是用户要求系统必须完成的任务 功能需求(functional requirement)规定开发人员必须在产品中实现的软件功能，用户利用这些功能来完成任务，满足业务需求。 需求是数仓的核心,无论从广度还是深度的层面上做好需求调研的工作,对数仓的建设百利而无一害 需求分类 项目需求:搭建数仓需要完成哪些基础目标,以模板作为导向 业务部门的需求:通过需求调研,了解业务部门希望在数仓搭建完成后,能对业务有多少实质性的帮助 需求调研步骤1.确定调研对象在数仓调研过程中,不可避免的会遇到业务人员以为某项功能可以很轻松的实现,而技术人员完全听不懂专业的业务术语,会影响整个项目进度,而且在需求不清晰地情况下盲目的进行工作,会给日后的工作留下很多隐患. 数仓团队中往往会存在一个业务咨询师的角色,主要就是负责技术和业务两方面的需求调研工作 我记得以前做过一个银行数仓的搭建项目,整个团队埋头苦干,一个星期整理的需求分析的可用度不高,公司调来了一位高级咨询师,只用了三天,就把大致的需求分析做完了. 术业有精通,这就是提高了整个项目的工作效率,数据仓库团队在进行需求调研时,需要把业务人员、技术人员和类似业务咨询师的项目成员召集起来一起反复谈论需求的细节 2.了解源系统需要了解业务的源系统,包括源系统的所有者,源系统的业务流程,源系统的数据规范,源系统的数据存储方式,源系统的数据流程,源系统是否存在更新换代情况,源系统的数据库类型,源系统的源表等等,可以按照下图进行源系统文档的整理. 3.需求调研需求调研的目标是发现问题以及找到现阶段未发现的边界范围 调查系统需求,主要是通过面谈、问卷调查法、观察法、体验法等方式,了解用户对系统的期待性功能,从而找到系统对应的相关事件,需求调研的重点应该放在业务过程上,而不是侧重于业务部门,例如有三个部门在某一个业务上存在交叉,那这个时候就不应该把部门需求放在第一位,首先应该梳理业务需求,数据服务于部门,而不是部门服务于业务. 如果基于业务部门建立数据仓库总线矩阵雏形,会造成很多数据的重复性和交叉性,无法完成在数据应用上的目标. 需要先对源数据进行初步评估,以便日后进行源数据处理 4.需求分析的内容需求分析的内容主要可以分为下面三步: 1.对象 拿到一个需求之后首先要分析的就是这个需求的主体是什么，关键对象是什么，然后再来分析于此相关联的对象都有什么，是否有什么漏洞 2.约束 每一个需求之间都多多少少有关联，而需求分析的难点就在于把众多业务联系在一个平面上，从而解决数据搭建过程中的边界问题。需求的约束有哪些？限制有哪些？这些问题才是重点。 例如：在银行数仓大环境中，同一个业务名称的指标在不同的业务部门之间会有不同的逻辑，对于A指标，财务部和风险部对其定义可能存在不一样的逻辑，这个时候就需要在需求分析过程中对该指标进行细化调研，搞明白该指标在不同的部门中的逻辑约束关系，为何会出现一个指标，而存在不同逻辑。当这些搞清楚后，对于轻度化汇总的宽表设计会有很大帮助。 3.关系 需求之间的关系往往错综复杂，一层套一层。即便不能搞清楚数仓搭建过程中所有的需求关系，但是重要的指标需求一定要搞清楚，避免给以后留下坑。 例如：A部门的一个需求指标可能是由其他部门的指标加工而来的，或许还存在一些人工录入的数据，搞清楚这些后，可以解决基础层数据存储和模型层逻辑加工的很多问题。 银行数仓中，有很多指标是交叉的，例如存量贷款这个词在财务中可能只需要未核销未结清的贷款部分，而在风险部中不仅需要这部分，还需要90天转表外的不良贷款金额，而这部分的金额是记录在外部账中，不始于财务的统计规则。 5.编写需求文档经过以上步骤产出的文档主要有需求规格文档、源系统跟踪报告、总线矩阵文档、数据评估报告。 下边大概为大家分享总结一些流程以及文档规范。 需求流程 分析需求可行性分析：数据产品经理主导，邀请设计、数据安全与合规人员，对需求进行评估。 需求合理性：评估该需求的合理性。 数据可行性：评估当前已有数据能否支撑需求开发，如果缺少数据，则需要另行规划缺失数据的抽取方案。同时建议进行深入的数据探查，包括但不限于数据完整性、字段离散值分布情况、空值、零值、重复值占比等情况。 技术可行性：评估当前已有数据模型能否支撑需求开发，如果不能，则需要规划模型改造方案，并充分评估其影响。同时在测试环境进行模型测试。 数据仓库业务模板 单元测试报告 数据评估报告","categories":[],"tags":[{"name":"数仓","slug":"数仓","permalink":"http://www.a2data.cn/tags/%E6%95%B0%E4%BB%93/"}]},{"title":"任务栏调整神器","slug":"Tools/任务栏调整神器","date":"2020-11-09T02:00:55.000Z","updated":"2025-05-04T18:37:40.532Z","comments":true,"path":"posts/5c0875d6.html","link":"","permalink":"http://www.a2data.cn/posts/5c0875d6.html","excerpt":"任务栏调整神器–7+ taskbar tweaker","text":"任务栏调整神器–7+ taskbar tweaker 7+ Taskbar Tweaker 是Windows任务栏自定义设置即优化调整实用工具，允许用户通过配置任务栏程序行为、分组&amp;合并方式以及其他任务栏鼠标操作选项来自定义属于自己的 Windows 任务栏的各个方面 7+ TaskBarblog7+ Taskbar Tweakerhttps://rammichael.com/7-taskbar-tweaker 中文截图 小编调整效果 两列 任意大小调节其实可以更小的，弄成一列也OK 大家根据自己的需求调一调吧。如图所示为任意调整任务栏大小设置项 更改参数 如图所示： 瘦成闪电：","categories":[],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://www.a2data.cn/tags/Windows/"},{"name":"任务栏神器","slug":"任务栏神器","permalink":"http://www.a2data.cn/tags/%E4%BB%BB%E5%8A%A1%E6%A0%8F%E7%A5%9E%E5%99%A8/"}]},{"title":"数据仓库是什么","slug":"DataBase/数据仓库/何为数据仓库","date":"2020-11-09T00:56:46.000Z","updated":"2025-05-04T18:37:40.530Z","comments":true,"path":"posts/19a88b12.html","link":"","permalink":"http://www.a2data.cn/posts/19a88b12.html","excerpt":"数据仓库是什么?","text":"数据仓库是什么? 数据仓库到底是什么？ ###一、逻辑层次和概念层次数据库和数据仓库在一定程度上具有相通性，都是通过数据库软件去管理数据，但是数据库更关注业务交易处理过程中数据的存储~ 数据仓库的着重点 1、对于业务的存储数据进行分析。数据库通常追求业务交易的数据，交易数据的完整性，数据的一致性，在遵从三大范式的情况下，减少数据的冗余性，使得在数据存储性能上实现最优解。 2、数据分析的效率、复杂语句查询的速度，数据之间的相互关联，在数仓中，更偏向通过对业务源数据的理解，加工出适合开发的多维数据模型，从而提高数据分析的效率。 二、数据的保留性传统的关系性数据库 （例如oracle，mysql，DB2）在数据存储方面，侧重点在实时的数据，每次只是针对行式数据进行处理，如果说数据库是空军基地，那么数据仓库可以说是航空母舰，数仓可以进行更远范围内的任务处理。在数仓中，往往可以存储更久远的数据，前提是历史数据在一定时间内不被处理，数据空间足够支撑数据存储，以空间换取数据处理能力。 例如： 我跟随的第一个一期数仓项目，每天省联社都会下发当天的实时数据，不同表采用不同的入库存储方式，虽然这次项目的银行数据量相比五大行的数据量差的很多，但是也达到了百亿的级别了，各种业务一点也不少，对于历史数据保留至当前，只要省联社能下发的数据，在数仓中都能找到历史数据。 三、功能点侧重数据库是面向事务的设计它只要保证数据能完整的存储，实现引用的完整性。而数据仓库则是面向主题设计的，将数据进行集成处理，反应历史变化的数据集合，用于决策支持系统。 数据仓库系统体系结构 数据源：是数据仓库系统的基础，是整个系统的数据源泉，包含内部信息和业务经营性信息。 数据的存储和管理：数仓真正的意义就在于数据的存储和管理，于是乎数据的存储和管理就与传统型数据产生了很大的差异，针对各个业务系统的数据进行抽取和清理，根据对象的不同，就产生了不同的管理组织方式。将根据源数据的不同下发方式（全量，增量，变量），也产生了不同的入库存储方式，这就要求在处理数据时，要分门别类。 多维数据模型建立：通过对不同的业务维度进行数据模型的建立，我将其称之为模型层，该层主要是为了方便做数据分析时，部分数据能够快速的获取和进行sql语句的编写，其实我所在的项目这一层都是用的公司原有的架构设计，从某种角度讲有一部分的模型设计已经不能够满足目前的需求，很多数据从源数据中处理后，往往不适合业务的需求，目前我能够独立开发新的模型，来满足报表业务需求。 数据缓冲层（STA）：服务于逻辑算法，存储过程速度快，代码简单。（四种入库方式+marge） 全量：参数表，只会增加，不会删除； 快照：切片式存储，数据量变化不大，但是数值变化大；按日期删除追加（增量）； 拉链 关于模型：分类整理 集市应该是按照业务需求的不同（不再以数据作为驱动），进一步对数仓进行分类整理，应该避免在业务层面上有交叉性，独立且有针对性。 仓库应该是大而全，集市应该是分类精选。 数据仓库的数据应用 报表展示 报表几乎是每个数据仓库的必不可少的一类数据应用，将聚合数据和多维分析数据展示到报表，提供了最为简单和直观的数据。 即时查询 理论上数据仓库的所有数据（包括细节数据、聚合数据、多维数据和分析数据）都应该开放即时查询，即时查询提供了足够灵活的数据获取方式，用户可以根据自己的需要查询获取数据。 数据分析 数据分析大部分基于构建的业务模型展开，当然也可以使用聚合的数据进行趋势分析、比较分析、相关分析等，而多维数据模型提供了多维分析的数据基础；同时从细节数据中获取一些样本数据进行特定的分析也是较为常见的一种途径。 数据挖掘 数据挖掘用一些高级的算法可以让数据展现出各种令人惊讶的结果。数据挖掘可以基于数据仓库中已经构建起来的业务模型展开，但大多数时候数据挖掘会直接从细节数据上入手，而数据仓库为挖掘工具诸如SAS、SPSS等提供数据接口。 接下来的几天，会从数仓整体来进行学习，主要涵盖以下几部分： 需求 架构 元数据管理 数据质量管理 ETL开发、建模和任务调度。","categories":[],"tags":[{"name":"数仓","slug":"数仓","permalink":"http://www.a2data.cn/tags/%E6%95%B0%E4%BB%93/"}]},{"title":"Day16.文件","slug":"Python/Python入门/Day16文件","date":"2020-09-18T05:58:27.000Z","updated":"2020-09-18T06:01:30.456Z","comments":true,"path":"posts/53d1dcfb.html","link":"","permalink":"http://www.a2data.cn/posts/53d1dcfb.html","excerpt":"文件操作。","text":"文件操作。 例题引导： 尝试导入本地的txt文件到python中，并读取该txt文件的第一行内容到一个字符串； 将python执行的输出结果保存到本地新建/现有的txt文件中；尝试导入本地的csv文件到python中，并读取csv文件内容； 这道题思路简单，主要是对今天学习内容的应用。 参考答案： #读取txt f = open(&#39;test.txt&#39;,encoding = ‘utf-8’) line = f.readline() #新建并存入txt文件： with open(&#39;文件名.txt&#39;,&#39;a&#39;,encoding=&#39;utf-8&#39;) as a: a.write() #写入现有的txt文件： with open(&#39;文件名.txt&#39;,&#39;w+&#39;,encoding=&#39;utf-8&#39;) as a: a.write() #读取csv import csv f = open(&#39;文件夹路径&amp;文件名&#39;, &#39;r&#39;,encoding = ‘utf-8’) csvreader = csv.reader(f) line = list( a for a in csvreader) 学习引导： 打开文件 关闭文件 文件读写 文件打开文件open() 方法Python open() 方法用于打开一个文件，并返回文件对象，在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 OSError。 注意：使用 open() 方法一定要保证关闭文件对象，即调用 close() 方法。 open() 函数常用形式是接收两个参数：文件名(file)和模式(mode) 完整的语法格式如下： open(file, mode=&#39;r&#39;, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None) 关闭文件调用close()方法关闭文件 文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的： f.close() 文件读写文件读取的方式有三种: 1)read()read：如果指定了参数 size，就按照该指定长度从文件中读取内容，否则，就读取全文。被读出来的内容，全部塞到一个字符串里面。这样有好处，就是东西都到内存里面了，随时取用；但如果文件内容太多了，内存会吃不消。注意换行符也为占用一个内存,缺点需要知道光标的位置，以及每一行的大小SIZE。 f = open(r&#39;C:\\Users\\WJF\\test.txt&#39;, &#39;r&#39;,encoding=&#39;gbk&#39;) #这里的文本文件，大家可以自己写一个，没有硬性要求。 # f.read(10) f.read(5) &#39;DataS&#39; 2)readline()readline() 方法用于从文件读取整行，包括 “\\n” 字符。从字面意思可以看出，该方法每次读出一行内容。所以，读取时占用内存小，比较适合大文件，该方法返回一个字符串对象。如果指定了一个非负数的参数，则返回指定大小的字节数，包括 “\\n” 字符。 语法：fileObject.readline(); f = open(r&#39;C:\\Users\\WJF\\test.txt&#39;, &#39;r&#39;,encoding=&#39;gbk&#39;) while True: line=f.read() if not line:#到 EOF，返回空字符串，则终止循环 break print(line) DataScience 专注数据科学领域 分享python、Java、大数据学习干货；职场面经、求职指南等 不定期组织免费学习计划 欢迎加入我们~~~ DataScience 官方博客：https://www.a2data.cn/#indexCard这一行是新加的内容。 3) readlines()readlines() 方法用于读取所有行(直到结束符 EOF)并返回列表，该列表可以由 Python 的 for… in … 结构进行处理。当文件太大时，内存可能不够用。 如果碰到结束符 EOF 则返回空字符串。 如果碰到结束符 EOF 则返回空字符串。 语法：fileObject.readlines( ); f = open(r&#39;C:\\Users\\WJF\\test.txt&#39;, &#39;r&#39;,encoding=&#39;gbk&#39;) print(f.readlines()) [&#39;DataScience\\n&#39;, &#39;\\n&#39;, &#39;专注数据科学领域\\n&#39;, &#39;分享python、Java、大数据学习干货；职场面经、求职指南等\\n&#39;, &#39;不定期组织免费学习计划\\n&#39;, &#39;欢迎加入我们~~~\\n&#39;, &#39;\\n&#39;, &#39;DataScience 官方博客：https://www.a2data.cn/#indexCard这一行是新加的内容。\\n&#39;] #遍历每行打印 f = open(r&#39;C:\\Users\\WJF\\test.txt&#39;, &#39;r&#39;,encoding=&#39;gbk&#39;) for line in f.readlines(): print(line) &#39;&#39;&#39; DataScience 专注数据科学领域 分享python、Java、大数据学习干货；职场面经、求职指南等 不定期组织免费学习计划 欢迎加入我们~~~ DataScience 官方博客：https://www.a2data.cn/#indexCard这一行是新加的内容。 &#39;&#39;&#39; 小总结其实关于文件的打开有很多种模式，这里我们用一个表格总结一下 模式 概述 t 文本模式 (默认)。 x 写模式，新建一个文件，如果该文件已存在则会报错。 b 二进制模式。 + 打开一个文件进行更新(可读可写)。 U 通用换行模式（不推荐）。 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。 w 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 w+ 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 以上为文件打开的所有方式，但实际应用中常用的就其中几种，大家不必硬记，根据自己的需求记住几个常用的就好。 小作业： 语文老师将古诗存在poem.txt文档里，一句一行。他需要修改特定诗句为空白让学生默写。请使用如下诗歌为例，帮助老师实现功能： 锦瑟无端五十弦，一弦一柱思华年。庄生晓梦迷蝴蝶，望帝春心托杜鹃。沧海月明珠有泪，蓝田日暖玉生烟。此情可待成追忆，只是当时已惘然。","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python入门","slug":"Python/Python入门","permalink":"http://www.a2data.cn/categories/Python/Python%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"Day15.异常","slug":"Python/Python入门/Day15异常","date":"2020-09-18T05:57:51.000Z","updated":"2020-09-18T06:01:30.442Z","comments":true,"path":"posts/2a327ad2.html","link":"","permalink":"http://www.a2data.cn/posts/2a327ad2.html","excerpt":"异常","text":"异常 例题引导：编写一个计算减法的方法，自己输入两个数，当第一个数小于第二个数时，抛出“被减数不能小于减数”的异常。 解题思路：首先需要一个判断的语句，比较两个数大小，其次需要定义异常，主要掌握try/except语句 参考答案： def jianfa(a,b): if a&lt;b: raise BaseException(&#39;被减数不能小于减数&#39;) #return 0 else: return a-b try: a=int(input()) b=int(input()) print(jianfa(a, b)) print(&quot;没遇到自己定义的错误&quot;) #不打印 except: print(&quot;被减数不能小于减数&quot;) finally: print(&quot;OK&quot;) 学习引导： 语法错误 处理异常 异常else 异常finally 自定义异常 异常在我们刚接触python的时候，肯定遇到过无数次的报错。python中有两种错误很容易辨认：语法错误和异常。 语法错误python的语法错误又称为解析错，多数是语法格式上出现问题。比如： print（&#39;Hello World&#39;） #这里的括号为中文格式下的，所以报错 File &quot;&lt;ipython-input-1-f552c294b592&gt;&quot;, line 1 print（&#39;Hello World&#39;） ^ SyntaxError: invalid character in identifier 处理异常即使python程序的语法是正确的，在运行它时也可能报错。 运行过程中出现的错误称为异常。 大多数的异常不会被程序自动处理，因此产生错误信息（即报错） 异常捕捉可以用try/except语句： while True: try: x=int(input(&#39;请输入一个数字：&#39;)) break except ValueError: print(&#39;您输入的不是数字，请再次尝试输入！&#39;) &#39;&#39;&#39; 请输入一个数字：s 您输入的不是数字，请再次尝试输入！ 请输入一个数字：3 &#39;&#39;&#39; try 语句按照如下方式工作； 首先，执行 try 子句（在关键字 try 和关键字 except 之间的语句）。 如果没有异常发生，忽略 except 子句，try 子句执行后结束。 如果在执行 try 子句的过程中发生了异常，那么 try 子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的 except 子句将被执行。 如果一个异常没有与任何的 except 匹配，那么这个异常将会传递给上层的 try 中。 捕获指定异常：try: &lt;语句&gt; except&lt;异常名&gt;: print(&#39;异常说明&#39;) 一个例子： try: f = open(&quot;file-not-exists&quot;, &quot;r&quot;) #试图打开一个本不存在的文件 except IOError as e: #IOErro：指要打开的文件不存在的错误提示，Try语句的错误与expect匹配，执行print语句。 print(&quot;open exception: %s: %s&quot; %(e.errno, e.strerror)) #open exception: 2: No such file or directory 捕获多个异常捕获多个异常有两种方式，第一种是一个except同时处理多个异常，不区分优先级： try: &lt;语句&gt; except (&lt;异常名1&gt;, &lt;异常名2&gt;, ...): print(&#39;异常说明&#39;) 第二种是区分优先级的： try: &lt;语句&gt; except &lt;异常名1&gt;: print(&#39;异常说明1&#39;) except &lt;异常名2&gt;: print(&#39;异常说明2&#39;) except &lt;异常名3&gt;: print(&#39;异常说明3&#39;) 实例如下： import sys try: f = open(&#39;myfile.txt&#39;) #打开文件 s = f.readline() #按行读取 i = int(s.strip()) #都成整数类型 except OSError as err: print(&quot;OS error: &#123;0&#125;&quot;.format(err)) #文件读取错误优先解决 except ValueError: print(&quot;Could not convert data to an integer.&quot;) except: print(&quot;Unexpected error:&quot;, sys.exc_info()[0]) raise #OS error: [Errno 2] No such file or directory: &#39;myfile.txt&#39; 该种异常处理语法的规则是： 执行try下的语句，如果引发异常，则执行过程会跳到第一个except语句。 如果第一个except中定义的异常与引发的异常匹配，则执行该except中的语句。 如果引发的异常不匹配第一个except，则会搜索第二个except，允许编写的except数量没有限制。 如果所有的except都不匹配，则异常会传递到下一个调用本代码的最高层try代码中。 异常的else如果判断完没有某些异常之后还想做其他事，就可以使用下面这样的else语句。 try: &lt;语句&gt; except &lt;异常名1&gt;: print(&#39;异常说明1&#39;) except &lt;异常名2&gt;: print(&#39;异常说明2&#39;) else: &lt;语句&gt; # try语句中没有异常则执行此段代码 异常的finallytry…finally…语句无论是否发生异常都将会执行最后的代码。 try: &lt;语句&gt; finally: &lt;语句&gt; 一个实例如下： str1 = &#39;hello world&#39; try: int(str1) except IndexError as e: print(e) except KeyError as e: print(e) except ValueError as e: print(e) else: print(&#39;try内没有异常&#39;) finally: print(&#39;无论异常与否,都会执行我&#39;) #invalid literal for int() with base 10: &#39;hello world&#39; #无论异常与否,都会执行我 自定义异常自定义类继承Exception你可以通过创建一个新的异常类来拥有自己的异常。异常类继承自 Exception 类，可以直接继承，或者间接继承。 在try语句块中，抛出用户自定义的异常后执行except部分，变量 e 是用于创建MyError类的实例。 实例如下： class MyError(Exception): def __init__(self, value): self.value = value def __str__(self): return repr(self.value) try: raise MyError(2*2) except MyError as e: print(&#39;My exception occurred, value:&#39;, e.value) #My exception occurred, value: 4 raise MyError(&#39;oops!&#39;) MyError Traceback (most recent call last) &lt;ipython-input-16-3e3ae366964f&gt; in &lt;module&gt; ----&gt; 1 raise MyError(&#39;oops!&#39;) MyError: &#39;oops!&#39; 在上述例子中，类 Exception 默认的 __ init__() 被覆盖。 当创建一个模块有可能抛出多种不同的异常时，一种通常的做法是为这个包建立一个基础异常类，然后基于这个基础类为不同的错误情况创建不同的子类: class Error(Exception): &quot;&quot;&quot;Base class for exceptions in this module.&quot;&quot;&quot; pass class InputError(Error): &quot;&quot;&quot;Exception raised for errors in the input. Attributes: expression -- input expression in which the error occurred message -- explanation of the error &quot;&quot;&quot; def __init__(self, expression, message): self.expression = expression self.message = message class TransitionError(Error): &quot;&quot;&quot;Raised when an operation attempts a state transition that&#39;s not allowed. Attributes: previous -- state at beginning of transition next -- attempted new state message -- explanation of why the specific transition is not allowed &quot;&quot;&quot; def __init__(self, previous, next, message): self.previous = previous self.next = next self.message = message 大多数的异常的名字都以”Error”结尾，就跟标准的异常命名一样。 raise自定义异常类raise语法格式如下： raise [Exception [, args [, traceback]]] 语句中Exception是异常的类型（例如ValueError），参数是一个异常参数值。该参数是可选的，如果不提供，异常的参数是”None”。最后一个参数是跟踪异常对象，也是可选的（在实践中很少使用）。 def not_zero(num): try: if num == 0: raise ValueError(&#39;参数错误&#39;) return num except Exception as e: print(e) not_zero(0) #参数错误 小作业： 简述如下各常见异常的含义并举例：SyntaxError、KeyError、IndexError、AttributeError、OSError、TypeError","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python入门","slug":"Python/Python入门","permalink":"http://www.a2data.cn/categories/Python/Python%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"Day14.模块和包","slug":"Python/Python入门/Day14模块和包","date":"2020-09-16T04:16:55.000Z","updated":"2020-09-16T04:18:38.866Z","comments":true,"path":"posts/5144bcf.html","link":"","permalink":"http://www.a2data.cn/posts/5144bcf.html","excerpt":"模块和包","text":"模块和包 模块什么是模块？定义：逻辑上就是一组功能的组合；实质上一个模块就是一个包含了python定义和声明的文件，文件名就是模块名字加上.py后缀。 import加载的模块分为四个通用类别： 使用python编写的代码（.py文件） 已被编译为共享库或DLL的C或C++扩展； 包好一组模块的包； 使用C编写并链接到python解释器的内置模块； 如何使用模块？想要使用模块，必须先要将模块加载进来，可以通过关键字 import 或 from进行加载；需要注意的是模块和当前文件在不同的命名空间中。 模块的构成模块可以包含可执行的语句和函数的定义，这些语句的目的是初始化模块，它们只在模块名第一次遇到导入import语句时才执行（import语句是可以在程序中的任意位置使用的,为了避免同一个模块重复导入，python的优化手段是：第一次导入后就将模块名加载到内存了，后续的import语句仅是对已经加载大内存中的模块对象增加了一次引用，不会重新执行模块内的语句） 模块导入的过程import 语句 想使用 Python 源文件，只需在另一个源文件里执行 import 语句，语法如下： import moduels(模块名字） 导入整个模块，这种导入方式比较占用内存 import moduels (模块名字) as XX这里是导入整个模块的同时给它取一个别名，因为有些模块名字比较长，用一个缩写的别名代替在下次用到它时就比较方便 from modules(模块名字) import func(方法）从一个模块里导入方法，你要用到模块里的什么方法就从那个模块里导入那个方法，这样占用的内存就比较少 也可以用别名表示 ： from modules(模块名字) import func(方法）as XX from package.modules import func(方法）从一个包的模块里导入方法 这个方法跟上面那种基本一样，占用的内存也比较少 也可以用别名表示，from modules(模块名字) import func(方法）as XX from…..import *表示导入模块中所有的不是以下划线(_)开头的名字都导入到当前位置，大部分情况下我们的python程序不应该使用这种导入方式，因为*你不知道你导入什么名字，很有可能会覆盖掉你之前已经定义的名字。而且可读性极其的差，在交互式环境中导入时没有问题。 还有一点要说的是，如果使用* 的方式进行了导入，这时只想使用里面的某个或某些功能时，可以使用__ all__来进行约束； 注意：__ all__只是用来约束* 方式的，其他方式导入的话，不会生效； #直接导入 import pandas #加别名 import pandas as pd # #看一下from.....import 的使用 from sys import modules print(modules) # #再看一下使用as引用这个模块的某个功能； from matplotlib import pyplot as plt #这样在之后我们要调用这个模块只需要用plt即可，相当于起别名。 包包是一种组织管理代码的方式，包里放着模块 用于将模块包含在一起的一个文件夹 假如一个模块的名称是 A.B，那么他表示一个包 A中的子模块B 。 包的结构 /— 包 #顶层包 /—/— init.py 包的 #初始化顶层包 /—/— 模块1 /—/— 模块2 /—/— 子包 /—/—/— init.py 包的标志文件 /—/—/— 子包的模块1 包的导入操作包的导入分为import和from…import…两种，但是无论哪种方式，在导入时必须都遵循一个原则：凡是在导入时带点的，点的左边必须是一个包，否则非法。在导入后使用时，就没有这些规则了，点的左边可以是包、模块、函数等（他们可以用点的方式调用自己的属性）。 包的本质就是文件夹，导入包就相当于导入包下的__ init__.py文件 下面我们具体看下包的导入有哪些方式 import package_name直接导入一个包，可以直接使用__ init__.py的内容 eg.import time， 用import直接导入python的time模块 import package name as p具体用法跟作用方法，跟上面一致，相当于起别名 注意的是此方法默认是对 __ init__.py的内容进行导入 from … import …导from package import module,module2….. eg. from random import randint 即导入random包中的randint函数 ​ from time import time,localtima 即从time包导入time函数和localtime函数 from package import *导入指定包的所有内容 包和模块区别包是比模块更高层的概念，模块一般是一个文件，包是一个目录，一个包中可以包含很多个模块。 包的all 定义在init.py文件中，模块的all定义在模块文件的开头 以下包用P表示，模块用M表示，方法用F表示 #在Python中引入模块可以用 import M from M import * from M import F #引入包的方式可以是 import P from P import M from P import * from P.M import F from P1.P2.M import F 另外，包的init.py文件不能少。 概念说明这里理清python中模块、库、包之间的概念差异 模块(module)其实就是py文件，里面定义了一些函数、类、变量等。 包(package)是多个模块的聚合体形成的文件夹，里面可以是多个py文件，也可以嵌套文件夹。 库是参考其他编程语言的说法，是指完成一定功能的代码集合，在python中的形式就是模块和包。","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python入门","slug":"Python/Python入门","permalink":"http://www.a2data.cn/categories/Python/Python%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"Day13.继承和多态","slug":"Python/Python入门/Day13继承和多态","date":"2020-09-16T04:15:29.000Z","updated":"2020-09-16T04:18:38.863Z","comments":true,"path":"posts/8f19a96e.html","link":"","permalink":"http://www.a2data.cn/posts/8f19a96e.html","excerpt":"继承 和多态","text":"继承 和多态 继承什么是继承？ 继承是一种创建新的类的方式，新创建的叫子类，继承的叫父类、超类、基类。 特点：子类可以使用父类的属性（特征、技能） 继承是类与类之间的关系 为什么要继承？ 减少代码冗余、提高重用性 如何使用继承？继承分为单继承和多继承 我们先看单继承 class A(object): def pp(self): print(&#39;pp A&#39;) class B(A): def pp(self): super().pp() print(&quot;pp B&quot;) b = B() b.pp() #pp A #pp B super（）常用的方法是在__ init __()方法中确保父类被正确的初始化了： super(cls,inst).__ init__() #cls,init 可以省略 class A(object): def __init__(self): self.x = 1 class B(A): def __init__(self): super(B,self).__init__() self.x = self.x +1 print(self.x) b = B() #2 也可以直接调用父类的一个方法 ： A.__ init__(self) class A(object): def __init__(self): self.x = 1 class B(A): def __init__(self): A.__init__(self) self.x = self.x +1 print(self.x) b = B() #2 多继承例子： class A(object): def __init__(self): print(&quot;Enter A&quot;) class B(A): def __init__(self): print(&#39;Enter B&#39;) super(B,self).__init__() print(&#39;Leave B&#39;) class C(A): def __init__(self): print(&#39;Enter C&#39;) super(C, self).__init__() print(&#39;Leave C&#39;) class D(B,C): def __init__(self): print(&#39;Enter D&#39;) super(D,self).__init__() print(&quot;Leave D&quot;) d = D() &#39;&#39;&#39; Enter D Enter B Enter C Enter A Leave C Leave B Leave D &#39;&#39;&#39; 使用__ bases__方法可以获取子类继承的类 class Parent2(): print(&#39;我是第二个爹&#39;) class Parent(): print(&#39;我是第一个爹&#39;) class SubClass(Parent, Parent2): print(&#39;我是子类&#39;) print(SubClass.__bases__) #注意，如果sub = SubClass(),sub是没有__bases__方法的 &#39;&#39;&#39; 我是第二个爹 我是第一个爹 我是子类 (&lt;class &#39;__main__.Parent&#39;&gt;, &lt;class &#39;__main__.Parent2&#39;&gt;) &#39;&#39;&#39; super()的用法：super()的本质 先说说python中如何实现继承———对于你定义的每一个类，Python会计算出一个所谓的方法解析顺序(MRO)列表。 这个MRO列表就是一个简单的所有基类的线性顺序表。为了实现继承，Python会在MRO列表上从左到右开始查找基类，直到找到第一个匹配这个属性的类为止。 而这个MRO列表的构造是通过一个C3线性化算法来实现的。 我们不去深究这个算法的数学原理，它实际上就是合并所有父类的MRO列表并遵循如下三条准则： 子类会先于父类被检查 多个父类会根据它们在列表中的顺序被检查 如果对下一个类存在两个合法的选择，选择第一个父类 虽然名义上来说super是用来调用父类中的方法，但是super实际上是在MRO表中找到下一个匹配的类。super原型如下： def super(cls, inst): mro = inst.__class__.mro() return mro[mro.index(cls) + 1] 两个参数 cls 和 inst 分别做了两件事： inst 负责生成 MRO 的 list 通过 cls 定位当前 MRO 中的 index, 并返回 mro[index + 1] 关于super的概念大家不用深究，只要掌握其语法会用了就行。 多态 一个操作的意义取决于被操作对象类型，相同的消息给与不同的对象会引发不同的动作。 多态意味着变量并不知道引用的对象是什么，根据引用对象的不同，表现不同的行为方式。 在处理多态对象时，只需要关注他的接口即可。 同一个操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。 注意：多态和多态性是两种不同的概念多态： 传统意义上的多态指一类事物有多种形态，比如动物类，可以有猫，狗，猪等等。（一个抽象类有多个子类，因而多态的概念依赖于继承） 用代码表示如下： import abc class Animal(metaclass=abc.ABCMeta): #同一类事物：动物 @abc.abstractmethod def talk(self): pass class Cat(Animal): #动物的形态之一：猫 def talk(self): print(&#39;say miaomiao&#39;) class Dog(Animal): #动物的形态之二：狗 def talk(self): print(&#39;say wangwang&#39;) class Pig(Animal): def talk(self): print(&#39;say aoao&#39;) 多态性: 多态性是指具有不同功能的函数可以使用相同的函数名，这样就可以用一个函数名调用不同内容的函数。在面向对象方法中一般是这样表述多态性：向不同的对象发送同一条消息，不同的对象在接收时会产生不同的行为（即方法）。也就是说，每个对象可以用自己的方式去响应共同的消息。所谓消息，就是调用函数，不同的行为就是指不同的实现，即执行不同的函数。 import abc class Animal(metaclass=abc.ABCMeta): #同一类事物：动物 @abc.abstractmethod def talk(self): pass class Cat(Animal): #动物的形态之一：猫 def talk(self): print(&#39;say miaomiao&#39;) class Dog(Animal): #动物的形态之二：狗 def talk(self): print(&#39;say wangwang&#39;) class Pig(Animal): def talk(self): print(&#39;say aoao&#39;) c=Cat() d=Dog() p=Pig() def func(obj): obj.talk() func(c) func(d) func(p) #say miaomiao #say wangwang #say aoao 综上可以说，多态性是 : 一个接口,多种实现 多态性的好处: 增加了程序的灵活性,以不变应万变，不论对象千变万化，使用者都是同一种形式去调用，如func(obj) 增加了程序额可扩展性,通过继承animal类创建了一个新的类，使用者无需更改自己的代码，还是用func(obj)去调用 小作业：今天依旧没有新的小作业哦，第十二天的作业是综合性的哦~","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python入门","slug":"Python/Python入门","permalink":"http://www.a2data.cn/categories/Python/Python%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"Day12.方法的重写和魔法方法","slug":"Python/Python入门/Day12方法的重写和魔法方法","date":"2020-09-13T16:28:44.000Z","updated":"2020-09-14T15:13:15.583Z","comments":true,"path":"posts/b7cd6609.html","link":"","permalink":"http://www.a2data.cn/posts/b7cd6609.html","excerpt":"方法的重写和魔法方法","text":"方法的重写和魔法方法 例题引导：使用魔法方法__new__构造一个摄氏度转换为华氏度的类： 解题思路：构建类-调用魔法方法-表达函数功能 参考答案： class C2F(float): def __new__(cls,arg = 0.0): return float.__new__(cls,arg * 1.8 + 32) 学习引导： 魔法方法： ​ __ init__: ​ __ class__: ​ __ str__: 类的专有方法 方法重写如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法，实例如下： class Parent: #定义父类 def myMethod(self): print(&#39;调用父类方法&#39;) class Child(Parent): #定义子类 def myMethod(self): print(&#39;调用子类方法&#39;) c=Child() #子类实例 c.myMethod() #子类调用重写方法 super(Child,c).myMethod() #用子类对象调用父类已被覆盖的方法 #super()是用于调用父类（超类）的一个方法。 #调用子类方法 #调用父类方法 魔法方法在python中，有一些内置好的特定的方法，这些方法在进行特定的操作时会自动被调用，称之为魔法方法，下面介绍几种常见的魔法方法。 __ new__(cls[,* argv]) __ new__ 是在一个对象实例化的时候所调用的第一个方法，它的第一个参数是这个类，其他的参数是用来直接传递给 __ init__ 方法 __ new__ 决定是否要使用该 __ init__ 方法，因为 __ new__ 可以调用其他类的构造方法或者直接返回别的实例对象来作为本类的实例，如果 __ new__ 没有返回实例对象，则 __ init__ 不会被调用 __ new__ 主要是用于继承一个不可变的类型比如一个 tuple 或者 string cls：代表一个类的名称 self：代表一个实例对象的名称 class myMethod(str): def __new__(cls,string): string=string.upper() return str.__new__(cls,string) X=myMethod(&#39;DataScience&#39;) print(X) #DATASCIENCE __ init__：初始化函数，在创建实例对象为其赋值时使用，在__ new__ 之后，__ init __ 必须至少有一个参数self，就是这个 __ new__ 返回的实例，__ init__ 是在 __ new__ 的基础上可以完成一些其它初始化的动作，__ init__不需要返回值。 class Dog: def __init__(self,color,brand): self.color=color self.brand=brand puppy=Dog(&#39;黑色&#39;,&#39;拉布拉多&#39;) print(puppy) #&lt;__main__.Dog object at 0x0000028EC0609DC8&gt; 下面再来一个结合__ init__ 和__ new__两个魔法方法的例子： class A(object): pass class B(A): def __init__(self): print(&#39;__init__被调用&#39;) def __new__(cls): print(&#39;__new__被调用&#39;) print(id(cls)) return object.__new__(A) #注意此处采用了参数A而不是cls，__new__没有正确返回当前类cls的实例 b=B() print(b) print(type(b)) #类型所继承的基类 print(id(A)) print(id(B)) &#39;&#39;&#39; __new__被调用 2812126085768 &lt;__main__.A object at 0x0000028EC0574108&gt; &lt;class &#39;__main__.A&#39;&gt; 2812126083880 2812126085768 &#39;&#39;&#39; 从运行结果可以看出，__ new__ 中的参数cls和B的id是相同的，表明__ new__ 中默认的参数cls就是B类本身，而在return时，并没有正确返回当前类cls的实例，而是返回了其父类A的实例，因此__ init__ 这一魔法方法并没有被调用，此时__ new__虽然是写在B类中的，但其创建并返回的是一个A类的实例对象。 现在将return中的参数A变为cls，再来看一下运行结果： class A(object): pass class B(A): def __init__(self): print(&#39;__init__被调用&#39;) def __new__(cls): print(&#39;__new__被调用&#39;) print(id(cls)) return object.__new__(cls) #注意此处采用了参数A而不是cls，__new__没有正确返回当前类cls的实例 b=B() print(b) print(type(b)) #类型所继承的基类 print(id(A)) print(id(B)) &#39;&#39;&#39; __new__被调用 2812126087656 __init__被调用 &lt;__main__.B object at 0x0000028EC057C148&gt; &lt;class &#39;__main__.B&#39;&gt; 2812126086712 2812126087656 &#39;&#39;&#39; 可以看出，当__ new__ 正确返回其当前类cls的实例对象时，__ init__被调用了，此时创建并返回的是一个B类的实例对象。 __ class__：获得已知对象的类 ( 对象.__ class__)。 基础格式如下： class My: pass a=A() print(a.__class__) #&lt;class &#39;__main__.A&#39;&gt; __ class__在下面这种情况中是有用的：即当一个类中的某个成员变量是所有该类的对象的公共变量时. 下面看一个例子： class My: count=0 def addcount(self): self.__class__.count +=1 a=My() a.addcount() print(a.count) print(&#39;*&#39;*50) b=My() b.addcount() print(b.count) #1 #************************************************** #2 从运行结果可以看出，虽然a和b是两个不同的My类的实例对象，但采用了__ class__ 之后，分别调用两个对象的addcount方法之后，获取到的对象的count属性却是在不断累加的，此时self.__ class__ .count不再是单纯的某个对象私有的属性，而是类的所有实例对象的共有属性,它相当于self.A.count。若将self.__ class__ .count += 1变为self.count += 1,此时__ class__的效果就十分明显了。 class My: count=0 def addcount(self): self.count +=1 a=My() a.addcount() print(a.count) print(&#39;*&#39;*50) b=My() b.addcount() print(b.count) #1 #************************************************** #1 __ str__：在将对象转换成字符串 str(对象) 测试的时候，打印对象的信息，__ str__ 方法必须要return一个字符串类型的返回值，作为对实例对象的字符串描述，__ str__ 实际上是被print函数默认调用的，当要print（实例对象）时，默认调用__ str__ 方法，将其字符串描述返回。如果不是要用str()函数转换。当你打印一个类的时候，那么print首先调用的就是类里面的定义的__ str__。 class My(): def __init__(self,name): self.name=name def __str__(self): return(&#39;我是My类的实例对象my，我的名字叫%s&#39;%self.name) my=My(&#39;小王&#39;) print(My) print(my) #&lt;class &#39;__main__.My&#39;&gt; #我是My类的实例对象my，我的名字叫小王 类的专有方法 __ init__ : 构造函数，在生成对象时调用 __ del__ : 析构函数，释放对象时使用 __ repr__ : 打印，转换 __ setitem__ : 按照索引赋值 __ getitem__: 按照索引获取值 __ len__: 获得长度 __ cmp__: 比较运算 __ call__: 函数调用 __ add__: 加运算 __ sub__: 减运算 __ mul__: 乘运算 __ truediv__: 除运算 __ mod__: 求余运算 __ pow__: 乘方 做一个总结： 修改类方法和属性，会影响实例方法和属性 一个实例属性的修改，不会影响另一个实例属性 类方法可以修改，但实例方法不允许修改 小作业​ 今天没有小作业，昨天的作业完成情况如何？","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python入门","slug":"Python/Python入门","permalink":"http://www.a2data.cn/categories/Python/Python%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"Day11.封装","slug":"Python/Python入门/Day11封装","date":"2020-09-13T16:27:05.000Z","updated":"2020-09-13T16:31:31.315Z","comments":true,"path":"posts/80bb221f.html","link":"","permalink":"http://www.a2data.cn/posts/80bb221f.html","excerpt":"Python 的封装学习。","text":"Python 的封装学习。 例题引导：构造一个名为Vector的类，用来储存一个平面坐标系中的向量(例如(1,2))； 在类中构造向量的相加、相减和相乘三种方法，并分别返回计算结果的向量； 再构造一个输出向量的方法，按照(x,y)的格式输出向量； 最后使用main函数输入两个向量，输出他们的加、减、乘计算结果。 解题思路：关于类的创建以及函数的创建及调用 参考答案： class Vector(object): def __init__(self, x, y): self.x = x self.y = y def __add__(self, other): #加 x = self.x + other.x y = self.y + other.y return Vector(x, y) def __sub__(self, other): #减 x = self.x - other.x y = self.y - other.y return Vector(x, y) def __mul__(self, times): #乘 return Vector(self.x * times, self.y * times) def __repr__(self): #格式化输出 return &#39;Vector(&#123;&#125;, &#123;&#125;)&#39;.format(self.x, self.y) def main(): v1 = Vector(3, 5) v2 = Vector(4, 5) v3 = v1 + v2 v4 = v3 * 2 v5 = v2 - v1 print(v3) print(v4) print(v5) if __name__ == &#39;__main__&#39;: main() 学习引导： 类定义 类对象 类属性与方法 类和对象为了更好的理解本节内容，你首先需要了解什么是面向对象。 python语言是一种面向对象的语言，因此在python中创建一个类和对象是很容易的。 下面简单介绍一下面向对象中的一些基本概念： 类(class):类是抽象的概念，它是一种数据结构，就好比一个模型，该模型是生活中具有相同属性（特征）和方法（动作）的同一类事务，可以用它来生产真实的物体（实例），对象是类的实例。 对象：对象就是具有类属性和方法的具体事物（就是基于类而创建的一个具体的事物），python中一切皆对象。对象包括两个数据成员（类变量和实例变量）和方法。对象的属性一般指主要的特征和参量，而方法主要指函数。 类与对象的关系：对象是有类产生的。一个类为它的全部对象给出了一个统一的定义，而他的每个对象则是符合这种定义的一个实体，因此类和对象的关系就是抽象和具体的关系 实例化：创建一个类的实例，类的具体对象。 实例化对象：由类生产的一个具体对象就叫实例化对象，也就是对象。 方法：类中定义的函数。 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。 数据成员：类变量或实例变量用于处理类及其实例对象的相关数据。 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程称为方法的覆盖（override重写）。 局部变量：定义在方法中的变量，只作用于当前实例的类。 实例变量：在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用self修饰的变量。 继承：即一个派生类(derived class)继承基类(base class)的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。 和其它编程语言相比，Python 在尽可能不增加新的语法和语义的情况下加入了类机制。 Python中的类提供了面向对象编程的所有基本功能：类的继承机制允许多个基类，派生类可以覆盖基类中的任何方法，方法中可以调用基类中的同名方法。 对象可以包含任意数量和类型的数据。 面向对象编程的特征： 封装：对外部隐藏对象的工作细节 继承：子类自动共享父类之间数据和方法的机制 多态：可以对不同类的对象调用相同的方法，产生不同的结果 类定义类实例化后，可以使用其属性。创建一个类之后，可以通过类名访问其属性。 语法格式如下： class ClassName(): #类的命名一般首字母大写，括号中参数可带可不带,带只能带继承的基类名称 &#39;这里可写类的说明文档&#39; &lt;statement-1&gt; . . . &lt;statement-N&gt; 类对象类对象支持两种操作：属性引用和实例化。 属性引用：使用和python中所有的属性引用一样的标准语法：obj.name。 类对象创建后，类命名空间中所有的命名都是有效属性名。 class MyClass: &quot;演示一个简单的类实例&quot; i=&#39;DataScience&#39; def func(self): return &#39;Hello World&#39; #实例化类 x=MyClass() #访问类的属性和方法 print(&#39;MyClass类的属性i为：&#39;,x.i) print(&#39;MyClass类的方法func输出为&#39;,x.func()) #MyClass类的属性i为： DataScience #MyClass类的方法func输出为 Hello World 类有一个名为 __ init__() 的特殊方法（构造方法），该方法在类实例化时会自动调用。 语法格式如下： def __init__(self): self.data=[] __ init__ () 方法可以有参数，参数通过 __ init__() 传递到类的实例化操作上。例如: class Special: def __init__(self,realpart,imagpart): self.r=realpart self.i=imagpart x=Special(&#39;welcome&#39;,12) print(x.r,x.i) #welcome 12 selfself 代表类的实例，而非类。 类的方法与普通的函数有一个区别—它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self。 class Test: def test(self): print(self) print(self.__class__) t=Test() t.test() #&lt;__main__.Test object at 0x000002698B8C56C8&gt; #&lt;class &#39;__main__.Test&#39;&gt; 从执行结果可以很明显的看出，self 代表的是类的实例，代表当前对象的地址，而 self.class 则指向类。 self 不是 python 关键字，我们把他换成 datascience 也是可以正常执行的: class Test: def test(datascience): print(datascience) print(datascience.__class__) t = Test() t.test() #&lt;__main__.Test object at 0x000002698B8CC448&gt; #&lt;class &#39;__main__.Test&#39;&gt; 类属性与方法 类中的函数叫方法 类中的变量叫属性 类的私有属性__private_attrs:两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时self. private_attrs。 类的方法在类的内部，使用def关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数self，且为第一个参数，self代表的是类的实例。 注意：self这个名字不是定死的，也可以使用this，但最好还是用常用的self。 类的私有方法__ private_method：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。self. __private_methods。 实例私有属性的实例如下“ class PrivateEX: __secretCount = 0 # 私有变量 publicCount = 0 # 公开变量 def count(self): self.__secretCount += 1 self.publicCount += 1 print (self.__secretCount) counter = PrivateEX() counter.count() counter.count() print (counter.publicCount) print (counter.__secretCount) # 报错，实例不能访问私有变量 #1 #2 #2 --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-1-f0d64b9d6654&gt; in &lt;module&gt; 12 counter.count() 13 print (counter.publicCount) ---&gt; 14 print (counter.__secretCount) # 报错，实例不能访问私有变量 AttributeError: &#39;PrivateEX&#39; object has no attribute &#39;__secretCount&#39; 类的私有方法实例如下： class Private: def __init__(self, name, url): self.name = name # public self.__url = url # private def who(self): print(&#39;name : &#39;, self.name) print(&#39;url : &#39;, self.__url) def __foo(self): # 私有方法 print(&#39;这是私有方法&#39;) def foo(self): # 公共方法 print(&#39;这是公共方法&#39;) self.__foo() x = Private(&#39;DataScience&#39;, &#39;https://www.a2data.cn/#indexCard&#39;) x.who() # 正常输出 x.foo() # 正常输出 x.__foo() # 报错 外部不能调用私有方法 &#39;&#39;&#39; name : DataScience url : https://www.a2data.cn/#indexCard 这是公共方法 这是私有方法 &#39;&#39;&#39; --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-8-0696acdddb15&gt; in &lt;module&gt; 18 x.who() # 正常输出 19 x.foo() # 正常输出 ---&gt; 20 x.__foo() # 报错 外部不能调用私有方法 AttributeError: &#39;Private&#39; object has no attribute &#39;__foo&#39; 通过类的实例化，可以创建多个实例对象。 下面的例子为多个对象的实例化： class my_class(): num=100 def print_num(self): print(&#39;num is %d&#39;%(self.num)) class_1=my_class() #实例化 class_2=my_class() #实例化 class_1.print_num() class_2.print_num() #num is 100 #num is 100 class_1.num=10 #修改实例属性 my_class.num=50 #修改类属性 class_1.print_num() class_2.print_num() #num is 10 #num is 50 class_1.num2=5 #新增类属性 print(class_1.num2) #5 类增加/修改属性从外部添加/修改属性 class Example(): pass Example.num=100 print(Example.num) #100 从内部添加/修改属性 class Example(): @classmethod def add_num(cls): cls.num=input(&#39;请输入：&#39;) print(cls.num) Example.add_num() #请输入：2 #2 在这里我们介绍一下上段代码所用到的@classmethod 一般来说，要使用某个类的方法，需要先实例化一个对象再调用方法。 而使用@staticmethod或@classmethod，就可以不需要实例化，直接类名.方法名()来调用。这有利于组织代码，把某些应该属于某个类的函数给放到那个类里去，同时有利于命名空间的整洁,既然@staticmethod和@classmethod都可以直接类名.方法名()来调用，那他们有什么区别呢？ 现从他们使用区别来看： @staticmethod不需要表示自身对象的self和自身类的cls参数，就跟使用函数一样。 @classmethod也不需要self参数，但第一个参数需要是表示自身类的cls参数。 如果在@staticmethod中要调用到这个类的一些属性方法，只能直接类名.属性名或类名.方法名。 而@classmethod因为持有cls参数，可以来调用类的属性，类的方法，实例化对象等，避免硬编码。 类方法不但能调用类属性，还能直接调用类中的其他方法 下面为一个成绩录入的例子 class List(): @classmethod def enter(cls): cls.name=input(&#39;请输入学生姓名：&#39;) cls.grade=int(input(&#39;请输入考试成绩：&#39;)) @classmethod def count(cls): if cls.grade&gt;=60: return &#39;及格&#39; else: return &#39;不及格&#39; @classmethod def result(cls): print(cls.count()) List.enter() List.result() &#39;&#39;&#39; 请输入学生姓名：xiaowang 请输入考试成绩：32 不及格 &#39;&#39;&#39; 小作业： 本次的习题可能难度稍大，涉及后面的知识，大家可以慢慢来。 构造四个类，其需要包含的属性和方法如下： people类：公开的属性（名字，年龄），私有属性（体重），构造方法，普通方法（输出名字和年龄）； student类（继承people类）：公开的属性（年级），继承父类的构造方法并加入自身的属性，普通方法（输出名字、年龄和年级）； speaker类：公开的属性（演讲主题，姓名），构造方法，普通方法（输出名字和演讲主题）； introduction类（同时继承speaker和student）：继承父类的构造方法。 尝试调用你的函数中各类和方法。 开发一把枪:1）判断是否有子弹，没有子弹无法射击 2）使用 print 提示射击，并且输出子弹数量 承接上面的枪的类,现改良ak47加强版,冒蓝火的,装弹量增加30","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python入门","slug":"Python/Python入门","permalink":"http://www.a2data.cn/categories/Python/Python%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"Day10.高阶函数","slug":"Python/Python入门/Day10高阶函数","date":"2020-09-11T09:08:50.000Z","updated":"2020-09-12T10:51:45.921Z","comments":true,"path":"posts/8b540f5a.html","link":"","permalink":"http://www.a2data.cn/posts/8b540f5a.html","excerpt":"高阶函数 定义 内置的有哪些","text":"高阶函数 定义 内置的有哪些 例题引导：用reduce()函数和lambda表达式，求:1+2+…100 本题要点： ​ 函数格式：reduce(func,iter1) ​ 参数介绍： ​ func:函数,有且只有两个参数 ​ iter1:可迭代对象 ​ 功能:将可迭代对象中的元素依次取出,并作用func函数,把作用的结果作为下一次参数继续运算。 参考答案： from functools import reduce print(reduce(lambda x,y: x+y,range(1,101))) 学习引导： 高阶函数定义 内置高阶函数介绍 高阶函数什么是高阶函数？变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。比如: def add(x,y,f): return f(x) + f(y) op = add(1,1,abs) #这里把python内置函数abs作为参数传递给add print (op) #2 内置函数：一般都是因为使用频率比较频繁或是是元操作，所以通过内置函数的形式提供出来，通过对python的内置函数分类分析可以看出来：基本的数据操 作基本都是一些数学运算（当然除了加减乘除）、逻辑操作、集合操作、基本IO操作，然后就是对于语言自身的反射操作，还有就是字符串操作，也是比较常用 的，尤其需要注意的是反射操作。 比如常用的常用的abs、round等 内置高阶函数 filter函数filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。 语法：filter(function, iterable) 参数：function—- 判断函数，iterable – 可迭代对象 返回值：返回列表 实例如下 def is_odd(n): return n % 2 == 1 alist = filter(is_odd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) print(list(alist)) #[1, 3, 5, 7, 9] map函数接收一个函数 f 和一个或多个序列list，并通过把函数 f 依次作用在 序列list 的每个元素上，得到一个新的 list 并返回。 语法：map(function, iterable, …) 参数：function – 函数，iterable – 一个或多个序列 返回值：Python 2.x 返回列表/Python 3.x 返回迭代器 实例如下 list_=[1,2,3,4,5] def square(x) : # 计算平方数 return x ** 2 list_2=list(map(square,list_)) # 计算列表各个元素的平方 print(list_2) #[1, 4, 9, 16, 25] 使用 lambda 匿名函数 list_3=list(map(lambda x: x ** 2, list_)) # 使用 lambda 匿名函数 print(list_3) [1, 4, 9, 16, 25] 实例2 # 提供了两个列表，对相同位置的列表数据进行相加 list_4=list(map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10])) print(list_4) #[3, 7, 11, 15, 19] reduce函数reduce()函数接收的参数和 map()类似，但是行为不同。reduce() 函数会对参数序列中元素进行累积。reduce()传入的函数 f 必须接收两个参数,用传给 reduce 中的函数 f（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 f 函数运算，最后得到一个结果。 语法：reduce(function, iterable[, initializer]) 参数：function – 函数，有两个参数。iterable – 可迭代对象。initializer – 可选，初始参数 实例如下 from functools import reduce #自 Python3 之后，这个函数从全局命名空间中移除，放在了 functools模块，因为如果想正确执行，必须这样 def add(x,y): #两数想家 return x+y reduce(add, [1,2,3,4,5]) #15 &gt;&gt;&gt; reduce(lambda x, y: x+y, [1,2,3,4,5]) # 使用 lambda 匿名函数 #15 def f(a,b): return a+b print(reduce(f,list_,10)) #这里的第三个参数是做为初始值的 #25 小作业： 请尝试用filter()删除1~100的素数，输出剩余的整数。 利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。 例如.输入：[‘xandra’, ‘William’, ‘ELIZABETH’]，输出：[‘Xandra’, ‘William’, ‘Elizabeth’]","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python入门","slug":"Python/Python入门","permalink":"http://www.a2data.cn/categories/Python/Python%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"Day9.函数下","slug":"Python/Python入门/Day9函数下","date":"2020-09-11T09:08:27.000Z","updated":"2020-09-11T09:19:13.464Z","comments":true,"path":"posts/b572816f.html","link":"","permalink":"http://www.a2data.cn/posts/b572816f.html","excerpt":"匿名函数 函数嵌套 函数递归 作用域","text":"匿名函数 函数嵌套 函数递归 作用域 例题引导： 一个由元组构成的列表：a = [(‘b’,3), (‘a’,2), (‘d’,4), (‘c’,1)] 要求：使用lambda表达式和函数sorted()，分别按照元组第一个元素排序(即abcd排序)，按照元组第二个元素排序(即1234排序)，输出相应的列表结果。 要点：了解lambda表达式和排序函数sorted()用法 参考答案： a = [(&#39;b&#39;,3), (&#39;a&#39;,2), (&#39;d&#39;,4), (&#39;c&#39;,1)] print(sorted(a, key=lambda x:x[0])) print(sorted(a, key=lambda x:x[1])) 学习引导： 匿名函数 函数的返回值 函数的说明文档 函数的嵌套 变量作用域 函数递归 匿名函数 python可以使用lambda来创建匿名函数 所谓匿名，即不再使用def这样的标准语句来专门定义函数 lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda中封装有限的逻辑进去。 lambda函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间中的参数。 有名函数的定义规则为【def+函数名+参数】；而匿名函数则是用【lambda+参数+表达式】的方式定义函数 lambda的语法只包含一个语句，格式如下： lambda [arg1[,arg2,...,argN]]:expression 下面用几个例子对两种函数进行对比，以便大家理解。 用def格式写 #用def格式写 def func(x,y): return x*y func(2,3) #6 用匿名函数写 #用匿名函数写 func=lambda x,y:x*y func(3,4) #12 从上面例子可以看出匿名函数相较标准函数的优点有： 不用取名称，因为给函数取名是比较头疼的一件事，特别是函数比较多的时候可以直接在使用的地方定义，如果需要修改，直接找到修改即可，方便以后代码的维护工作 语法结构简单 函数的返回值return[表达式]语句用于退出函数，选择性的向调用方返回一个表达式。不带参数值的return语句返回None。 下面演示一下return语句的用法： def sum(arg1,arg2): &quot;返回两个参数的和&quot; total=arg1+arg2 print(&#39;函数内：&#39;,total) return total #调用sum函数 total=sum(23,32) print(&#39;函数外：&#39;,total) #函数内： 55 #函数外： 55 函数的说明文档 定义：即对函数进行简单的解释说明（一般对参数和返回值进行说明） 作用：方便他人理解和自己日后的复读 语法结构如下： def 函数名（参数）: &#39;函数的说明文档内容&#39; 函数体 return 返回值 对于函数的内置函数，可以使用help()函数查看其内置文档。 函数的嵌套在函数中再定义一个函数 语法结构如下： def outer(): def inner(): print(&#39;inner&#39;) print(&#39;outer&#39;) inner() outer() # inner() #该句会报错 #outer #inner 一个案例 #一个案例 def outer(): str=&#39;Hello World&#39; def inner(): print(str) return inner info=outer() info() #Hello World 变量作用域一个标识符的可见范围，就是标识符的作用域。一般常说的是变量的作用域。 函数中的局部作用域：local 嵌套函数中父级函数的局部作用域：enclosing 全局作用域：global 系统内置的变量：如 int、str、list 等关键字 局部变量：在某个函数内部定义，作用在函数内部。生命周期：从变量被创建开始到函数结束死亡。 全局变量：定义在.py模块内部，作用在整个.py模块。生命周期：从变量被创造开始到.py模块结束死亡。 案例演示 def Demo1(): num=1 print(num) Demo1() print(num) #该句报错。因为num是局部作用，所以在函数外面是找不到num这个变量的。 #1 --------------------------------------------------------------------------- NameError Traceback (most recent call last) &lt;ipython-input-56-d3aaf0ba8dea&gt; in &lt;module&gt; 5 6 Demo1() ----&gt; 7 print(num) NameError: name &#39;num&#39; is not defined 对上例的解释 num = 0 def Demo1(): num = 1 print(&quot;在demo1中的结果:&quot;,num) def Demo2(): print(&quot;在demo2中的结果:&quot;,num) Demo1() Demo2() #在demo1中的结果: 1 #在demo2中的结果: 0 从结果可以看出，我们在demo1中num = 1，只在demo1内部起作用，而全局变量num仍然是0；因为在python中，在函数内部改变全局变量的值，会默认的在函数内部创建一个新的变量，全局变量并没有改变。 要想要改变全局变量的值，需要在函数内部用global声明。 现修改上面代码如下： num = 0 def Demo1(): global num num = 1 print(&quot;在demo1中的结果:&quot;,num) def Demo2(): print(&quot;在demo2中的结果:&quot;,num) Demo1() Demo2() print(&quot;在函数外面中的结果:&quot;,num) #在demo1中的结果: 1 #在demo2中的结果: 1 #在函数外面中的结果: 1 还有一种情况是当全局变量是可变数据类形，我们可以通过修改可变数据类型的方法，修改可变类型的内容，从而实现修改全局变量。（这里因为可变数据类型改变时，会在内存中改变数据的值） num_list = [1,2,3] def Demo1(demo1_list): demo1_list.append(4) print(&quot;在demo1中的结果:&quot;,demo1_list) def Demo2(): print(&quot;在demo2中的结果:&quot;,num_list) Demo1(num_list) Demo2() print(&quot;在函数外面中的结果:&quot;,num_list) #在demo1中的结果: [1, 2, 3, 4] #在demo2中的结果: [1, 2, 3, 4] #在函数外面中的结果: [1, 2, 3, 4] 列表 += 与 + 的区别 #+： num_list = [1,2,3] def Demo1(demo1_list): demo1_list = demo1_list + [4,5,6] print(&quot;在demo1中的结果:&quot;,demo1_list) def Demo2(): print(&quot;在demo2中的结果:&quot;,num_list) Demo1(num_list) Demo2() print(&quot;在函数外面中的结果:&quot;,num_list) #在demo1中的结果: [1, 2, 3, 4, 5, 6] #在demo2中的结果: [1, 2, 3] #在函数外面中的结果: [1, 2, 3] #+=： num_list = [1,2,3] def Demo1(demo1_list): demo1_list += [4,5,6] print(&quot;在demo1中的结果:&quot;,demo1_list) def Demo2(): print(&quot;在demo2中的结果:&quot;,num_list) Demo1(num_list) Demo2() print(&quot;在函数外面中的结果:&quot;,num_list) #在demo1中的结果: [1, 2, 3, 4, 5, 6] #在demo2中的结果: [1, 2, 3, 4, 5, 6] #在函数外面中的结果: [1, 2, 3, 4, 5, 6] 因为： 对于+号操作，可变对象和不可变对象调用的都是__add__操作 对于+=号操作，可变对象调用add__，不可变对象调用的是__iadd(不可变对象没有iadd) __iadd__是原地修改 函数递归 定义：在调用一个函数的过程中直接或间接的调用该函数本身，称之为递归调用。 递归调用最多能调用999层。 #基础模型一 def func(): print(&#39;from func&#39;) func() #直接调用自身 func() #基础模型二 def func(): print(&#39;from func&#39;) bar() #间接调用自身 def bar(): print(&quot;from bar&quot;) func() func() 虽然以上两中方式为函数递归的基础模型，但往往不能直接这样使用。因为没有一个函数的结束条件，仅仅相当于一个死循环。 递归分为两个重要的阶段: 递推+回溯 递推：函数不断减少问题规模直至最终的终止条件。 回溯：拿到最终明确的值后，返回给上次调用进行处理，直至初始层。 下面为一个练习题：解决年龄问题，求出Jack的年龄 &quot;&quot;&quot; Jack 他比小王 大两岁。 4 age(3) + 2 小王 他比大枫 大两岁。 3 age(2) + 2 大枫 他比美丽 大两岁。 2 age(1) + 2 美丽：我今年18. 1 18 &quot;&quot;&quot; def age(n): if n == 1: return 18 else: return age(n-1) + 2 print(age(4)) #24 注意在Python： 1、递归调用必须有一个明确的结束条件 2、在python中没有尾递归优化,递归调用的效率不高 3、进入下一次递归时,问题的规模必须降低 再来一个例子输入任意一个数，让其除以2，直到不能再除 def cal(num): if num%2==0:#先判断能不能整除 num=num//2 return cal(num) else: return num print(cal(8)) #1 小作业： 定义并调用两个函数*fib(n)和PrintFN(m,n)*，输出指定的斐波那契数信息(斐波那契数列：1,1,2,3,5,8,…不了解的自行百度)。函数要求： fib(n)*：返回斐波那契数列的第n个值 PrintFN(m,n)*：用列表返回[m, n]中的所有斐波那契数。 例如输入：20 100 6，输出： fib(6) = 13 4 解决汉诺塔问题（汉诺塔规则请自行百度）： 有ABC三根柱子，将A柱上的n个盘子移动到C柱。控制台输入盘子个数n，输出移动的所有步骤，格式样例“A–&gt;C”。 假设你正在爬楼梯。需要 n 阶你才能到达楼顶（给定n为正整数），每次可以爬 1 或 2 个台阶。编写函数，返回有多少种不同的方法可以爬到楼顶。 def climbStairs(n): dp = [] dp.append(1) # 初始状态，只有1阶的时候有一种走法 dp.append(2) # 有2阶的时候有两种走法 if n==1: #终止条件 return 1 if n==2: #终止条件 return 2 for i in range(2,n): dp.append(dp[i-1]+dp[i-2]) #递归 return dp[-1] 以下代码是否能执行，原因是？如何修改？ def fun1(): x = 3 def fun2(): x *= x return x return fun2() print(fun1()) 写出以下代码的执行结果： def fun2(): print(2) def fun3(): print(6) print(4) fun3() print(8) print(3) fun2() print(5)","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python入门","slug":"Python/Python入门","permalink":"http://www.a2data.cn/categories/Python/Python%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"Day8.函数上","slug":"Python/Python入门/Day8函数上","date":"2020-09-11T09:08:12.000Z","updated":"2020-09-11T09:18:46.325Z","comments":true,"path":"posts/3fb6e39.html","link":"","permalink":"http://www.a2data.cn/posts/3fb6e39.html","excerpt":"函数 概念 定义 创建 参数","text":"函数 概念 定义 创建 参数 例题引导： 【模拟轮盘抽奖游戏】 轮盘分为三部分: 一等奖, 二等奖和三等奖;轮盘转的时候是随机的,奖项设置如下：如果范围在[0,0.08)之间,代表一等奖,如果范围在[0.08,0.3)之间,代表2等奖,如果范围在[0, 1.0)之间,代表3等奖, 要求：假设本次活动1000人参加, 模拟游戏时各等级奖品个数需要准备多少个。 解题思路：定义游戏规则（用字典表达）-构建函数-生成随机数-编写游戏逻辑-调用函数-遍历1000名用户-打印输出 参考答案： import random #导入随机数模块 rewardDict = &#123; &#39;一等奖&#39;: (0, 0.08), &#39;二等奖&#39;: (0.08, 0.3), &#39;三等奖&#39;: (0.3, 1) &#125; #因为该值为一对一映射，所以想到用字典定义得奖范围 def rewardFun(): #开始构建函数 &quot;&quot;&quot;用户得奖等级&quot;&quot;&quot; # 生成一个0～1之间的随机数 num = random.random() # 判断随机转盘转的数是几等奖 for k, v in rewardDict.items(): # 这里的v是元组 if v[0] &lt;= num &lt; v[1]: return k # print rewardFun() resultDict = &#123;&#125; for i in range(1000): # res:本次转盘的等级(一/二/三等奖) res = rewardFun() #调用函数 if res not in resultDict: resultDict[res] = 1 else: resultDict[res] = resultDict[res] + 1 for k, v in resultDict.items(): print k, &#39;----------&gt;&#39;, v 学习引导： 函数概念 函数定义 函数调用 参数调用 参数传递 函数函数的概念函数是将具有独立功能的代码块组织成为一个整体，使其具有特殊功能的代码集。它是编辑好的、可直接调用的、可重复使用的，用来实现单一或相关联功能的代码段 优点： 提高程序的模块性； 使程序变得可扩展； 减少重复代码； 使程序变得可维护； 函数的定义函数必须先创建才可以使用，该过程称为函数定义，使用函数的过程称为函数调用。 函数可以根据自己的需求来定义，但有一些规则需要注意： 函数代码块必须以def开头，后接函数标识符名称和圆括号()； 任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数； 函数的第一行语句可以选择性的使用文档字符-用于存放函数说明； 函数内容以冒号起始，并且缩进； 函数名称的命名应符合标识符的命名规则；（可由字母、下划线和数字组成；不能以数字开头；不能与关键字重名） return[表达式]结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回None 函数定义的一般格式： #函数定义的一般格式： def 函数名 (参数列表)： 函数体 #实例1 def hello(): print(&#39;Hello World&#39;) hello() #Hello World 实例2-计算圆的面积,带参数 #实例2-计算圆的面积,带参数 def area(r): pi=3.412 return pi*(r^2) r=5 print(&#39;圆的面积为:&#39;,area(r)) #圆的面积为: 23.884 函数调用即使用函数的过程 简单的调用应用 #函数功能：打印该字符串 def println(str): print(str) return #调用函数 println(&#39;调用上述函数&#39;) println(&#39;打印这段字符串&#39;) println(&#39;多次调用函数&#39;) #调用上述函数 #打印这段字符串 #多次调用函数 参数调用参数分为形参、实参 形参：函数定义时括号内的参数 实参：函数调用时括号内的参数 形参相当于变量，实参相当于变量的值 在实际代码中表示如下： #定义时： def func(a,b,c): pass 其中 a,b,c 为形参 #调用时： func(1,2,3) 其中1，2，3为实参 形参：只在被调用时，才分配存储单元。调用结束，立刻释放所分配的内存。 形参只在函数内部有效 实参：可以是：常量、变量、表达式、函数 进行函数调用时，实参必须是确定的值 位置参数： 位置形参：函数定义时，从左往右写的参数，比如上面的 a, b , c 位置实参：函数调用时，从左往右写的参数, 比如上面的 1，2，3 位置形参定义多少个，调用时位置实参必须写上多少个，多一个少一个都不行。 位置参数必须以正确的顺序传入函数。调用时的数量必须和声明时的一样。 def func(a,b,c): return a+b+c #调用 print(func(2,3,4)) #9 错误演示： def func(a,b,c): return a+b+c #调用 print(func(2,3)) #实参数量不对应，报错 --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-21-38b482e25fef&gt; in &lt;module&gt; 3 4 #调用 ----&gt; 5 print(func(2,3)) TypeError: func() missing 1 required positional argument: &#39;c&#39; 关键参数： 正常情况下，给函数传参数，要按顺序。如果不想按顺序，就用关键参数。 指定参数名的参数，就叫做关键参数。 函数调用时：func(a=1, b=2), 这种指定了参数名的参数，就是关键参数。 调用函数时，关键参数可以和位置参数一起用，但是关键参数必须在位置参数的后面。不然会报错。 def func(a,b,c): return a+b+c #调用 print(func(4,c=3,b=2)) #9 默认参数： 函数定义时，默认参数必须在位置形参的后面。 函数调用时，指定参数名的参数，叫关键参数。 而在函数定义时，给参数名指定值的时候，这个参数叫做默认参数。 关键参数，和默认参数两个参数写法一样，区别在于： 关键参数是在函数调用时，指定实参的参数名，也可以说指定值的参数名。 默认参数是在函数定义时，指定参数名的值。 写法： def (a, b=100): pass 定义时，有默认参数的话，调用时，这个实参可以不写。如果实参不写的话，这个形参的参数值是他的默认值。 实例演示： def info(name,age=18): print(&#39;名字:&#39;,name) print(&#39;年龄:&#39;,age) return #调用 info(age=22,name=&#39;Jack&#39;) print(&#39;****************&#39;) info(name=&#39;Jack&#39;) &#39;&#39;&#39; 名字: Jack 年龄: 22 ***************** 名字: Jack 年龄: 18 &#39;&#39;&#39; 动态参数： * args ** kwargs当你需要一个函数能处理很多参数，超过已声明的参数数量，这时就需要动态参数。与上述两中参数不同的是，该参数声明不需要命名。 * args一个’* ‘的参数会以元组(tuple)的形式导入，存放未命名的变量参数 #函数定义 def printinfo(arg1,*vartuple): print(&#39;输出：&#39;) print(arg1) print(vartuple) #调用 printinfo(34,45,32,12) #输出： #34 #(45, 32, 12) 如果函数调用时没有指定参数，动态参数则表现为空元组。 #函数定义 def printinfo(arg1,*vartuple): print(&#39;输出：&#39;) print(arg1) print(vartuple) #调用 printinfo(34) #输出： #34 #() ** kwargs还有一种动态参数,加了两个星号则以字典的形式导入 #函数定义 def printinfo(arg1,**vardict): print(&#39;输出：&#39;) print(arg1) print(vardict) #调用 printinfo(34,a=45,b=32,c=12) #输出： #34 #&#123;&#39;a&#39;: 45, &#39;b&#39;: 32, &#39;c&#39;: 12&#125; 声明函数时，参数中的* 可以单独出现。 如果* 单独出现，后面的参数必须以关键字传入 def func(a,b,*,c): return a+b-c func(3,2,4) #非关键字传入报错 --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-34-f69556d382a4&gt; in &lt;module&gt; 2 return a+b-c 3 ----&gt; 4 func(3,2,4) TypeError: func() takes 2 positional arguments but 3 were given 关键字传入正确 func(3,4,c=5) #2 参数传递 python语言中，类型属于对象，变量是没有类型的,例如: a=[1,2,3] a=’DataScience’ 其中[1,2,3]是list类型，’DataScience’是string类型，变量a没有类型，它只是一个对象的引用（一个指针），可以指向list类型对象也可以指向string类型对象 可更改(mutable)与不可更改(immutable)对象 在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。 不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。 可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。 python 函数的参数传递： 不可变类型：类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。 可变类型：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响 python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。 #传不可变对象实例 # #函数定义 def changeInt(a): a=10 #函数调用 b=5 changeInt(b) print(b) #5 实例中有 int 对象 2，指向它的变量是 b，在传递给 ChangeInt 函数时，按传值的方式复制了变量 b，a 和 b 都指向了同一个 Int 对象，在 a=10 时，则新生成一个 int 值对象 10，并让 a 指向它。 #传可变对象实例 def changelist(List): #对传入的列表进行扩展 List.append([1,2,3,4]) print(&#39;函数内取值:&#39;,List) return #函数调用 List=[&#39;datascience&#39;] changelist(List) print(&#39;函数外取值:&#39;,List) #函数内取值: [&#39;datascience&#39;, [1, 2, 3, 4]] #函数外取值: [&#39;datascience&#39;, [1, 2, 3, 4]] 可变对象在函数里修改了参数，那么在调用这个函数的函数里，原始的参数也被改变了。 传入函数的和在末尾添加新内容的对象用的是同一个引用。 小作业 1.构造一个describe_pet函数，调用该函数输入以下2只宠物的信息： I have a cat. My cat’s name is Monkey. I have a lizard. My lizard’s name is Cola. 编写函数, 接收一个列表(包含10个整形)和一个整形k, 返回一个新列表，要求: \\- 将列表下标k之前对应(不包含k)的元素逆序; \\- 将下标k及之后的元素逆序; 请用函数实现一个判断用户输入的年份是否是闰年的程序 构造一个greeting函数，调用函数并使用循环，对输入的参数返回整理后的greeting信息。 例如，在控制台分别输入名字“Mary”和姓“Chen”，调用函数后输出”Hello, Mary Chen!”，并提示输入下一组姓和名。直到控制台输入姓或名为“end”时，程序结束。","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python入门","slug":"Python/Python入门","permalink":"http://www.a2data.cn/categories/Python/Python%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"Day7.集合","slug":"Python/Python入门/Day7集合","date":"2020-09-11T09:07:40.000Z","updated":"2020-09-11T09:18:46.328Z","comments":true,"path":"posts/1d1dff0b.html","link":"","permalink":"http://www.a2data.cn/posts/1d1dff0b.html","excerpt":"集合: 创建 增加 转化 删除 遍历 运算","text":"集合: 创建 增加 转化 删除 遍历 运算 例题引导： 有两个班英语班和数学班，需要统计这两个班中报名情况，例如统计既报名了英语班又报名数学班的同学名字,即统计为交集。 english_c =&#123;&quot;ZhangSan&quot;,&quot;LiSi&quot;,&quot;James&quot;,&quot;Alex&quot;&#125; math_c =&#123;&quot;WangWu&quot;,&quot;LiuDeHua&quot;,&quot;James&quot;,&quot;Alex&quot;&#125; 解题思路：统计两个集合中相同的元素 ，应想到利用集合的相关函数来实现，这道题没什么套路，只需要掌握知识点，会用即可。 参考答案： english_c =&#123;&quot;ZhangSan&quot;,&quot;LiSi&quot;,&quot;James&quot;,&quot;Alex&quot;&#125; math_c =&#123;&quot;WangWu&quot;,&quot;LiuDeHua&quot;,&quot;James&quot;,&quot;Alex&quot;&#125; #1、交集--&gt; in a and in b #统计既报了英语班又报了数学班的同学print(english_c &amp; math_c) print(english_c.intersection(math_c)) #输出为：&#123;&#39;Alex&#39;, &#39;James&#39;&#125; #2、并集--&gt; in a or in b #统计报名了两个班的所有同学print(english_c | math_c) print(english_c.union(math_c)) #输出为：&#123;&#39;James&#39;, &#39;ZhangSan&#39;, &#39;LiuDeHua&#39;, &#39;LiSi&#39;, &#39;Alex&#39;, &#39;WangWu&#39;&#125; #3、差集--&gt; in a not in b #统计只报名英语班的同学print(english_c - math_c) print(english_c.difference(math_c)) #输出为：&#123;&#39;LiSi&#39;, &#39;ZhangSan&#39;&#125; 4、交差补集 #统计只报名一个班的同学 print(english_c ^ math_c) #输出为：&#123;&#39;LiuDeHua&#39;, &#39;ZhangSan&#39;, &#39;WangWu&#39;, &#39;LiSi&#39;&#125; 学习引导： 数据类型-集合 创建 增删 循环 关系运算 数据类型-集合特点： 里面的元素不可变，不能在集合中存放列表或字典，而字符串、元组、数字等不可变类型可以存放 天生去重，在集合中无法存放相同的元素 无序。不能像列表一样通过索引来标记其元素在列表中的位置，例如{1，2，3}和{2，1，3}是同一个集合。 集合的创建#集合的创建 s=&#123;1,2,3,&#39;32&#39;,&#39;data&#39;,&#39;文字&#39;,&#39;d&#39;,&#39;f&#39;&#125; s #&#123;1, 2, 3, &#39;32&#39;, &#39;d&#39;, &#39;data&#39;, &#39;f&#39;, &#39;文字&#39;&#125; type(s) #查看类型 #set 列表转集合#列表转集合 l=[1,2,3,&#39;df&#39;,&#39;ffd&#39;] l #[1, 2, 3, &#39;df&#39;, &#39;ffd&#39;] set(l) #&#123;1, 2, 3, &#39;df&#39;, &#39;ffd&#39;&#125; 集合的新增 add#新增 s.add(&#39;科学&#39;) s #&#123;1, 2, 3, &#39;32&#39;, &#39;d&#39;, &#39;data&#39;, &#39;f&#39;, &#39;文字&#39;, &#39;科学&#39;&#125; 集合的删除 discard/remove/pop法一 #删除 s.discard(&#39;32&#39;) s #&#123;1, 2, 3, &#39;d&#39;, &#39;data&#39;, &#39;f&#39;, &#39;文字&#39;, &#39;科学&#39;&#125; 法二 s.remove(2) s #&#123;1, 3, &#39;d&#39;, &#39;data&#39;, &#39;f&#39;, &#39;文字&#39;, &#39;科学&#39;&#125; 法三 s.pop() #1 s #&#123;3, &#39;d&#39;, &#39;data&#39;, &#39;f&#39;, &#39;文字&#39;, &#39;科学&#39;&#125; 集合的循环#循环 for i in s: print(i) &#39;&#39;&#39; 3 科学 文字 data d f &#39;&#39;&#39; 集合的关系运算#集合的关系运算 s=&#123;1,2,3,&#39;32&#39;,&#39;data&#39;,&#39;文字&#39;,&#39;d&#39;,&#39;f&#39;&#125; s2=&#123;&#39;science&#39;,&#39;学长&#39;,&#39;学员&#39;,&#39;e&#39;,&#39;f&#39;,3,2,6,7&#125; 交集 s&amp;s2 #&#123;2, 3, &#39;f&#39;&#125; 并集 #并集 s | s2 #&#123;1, 2, 3, &#39;32&#39;, 6, 7, &#39;d&#39;, &#39;data&#39;, &#39;e&#39;, &#39;f&#39;, &#39;science&#39;, &#39;学员&#39;, &#39;学长&#39;, &#39;文字&#39;&#125; 差集 #差集 s-s2 #&#123;1, &#39;32&#39;, &#39;d&#39;, &#39;data&#39;, &#39;文字&#39;&#125; 对称差集 #对称差集 s ^ s2 #&#123;1, &#39;32&#39;, 6, 7, &#39;d&#39;, &#39;data&#39;, &#39;e&#39;, &#39;science&#39;, &#39;学员&#39;, &#39;学长&#39;, &#39;文字&#39;&#125; 判断两个集合是否包含相同的元素，不包含返回true，包含返回false s.isdisjoint(s2) #False s.isdisjoint(&#123;123&#125;) #True 子集 #是否为子集的判断 s.issubset(s2) #False &#123;1,2,3&#125;.issubset(&#123;1,2,3,4,5&#125;) #True 小作业 以下代码输出结果是： s = &#123;1,2,3&#125; print(s[1]) A. 1 B. 2 C. 无法输出 集合的特性有哪些?","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python入门","slug":"Python/Python入门","permalink":"http://www.a2data.cn/categories/Python/Python%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"Day6.字典","slug":"Python/Python入门/Day6字典","date":"2020-09-11T09:07:06.000Z","updated":"2020-09-11T09:18:46.331Z","comments":true,"path":"posts/71dd948a.html","link":"","permalink":"http://www.a2data.cn/posts/71dd948a.html","excerpt":"字典 创建 增加 删除 修改 查询 遍历","text":"字典 创建 增加 删除 修改 查询 遍历 例题引导： 【数字重复统计,以字典形式输出】 随机生成1000个数,统计20-100以内的数字,并统计出现次数 参考答案： 解题思路：先制造1000个随机数—整理随机数以便统计(排序)—构造字典—遍历随机数，通过key值确定value值—打印输出 import random #导入随机数模块 all_nums = [] #定义空列表存储数字 for item in range(1000): #列表长度为1000 all_nums.append(random.randint(20,100)) #选择20-100内的随机数 # print(all_nums) #可以先打印看一下生成的随机数 # print(&#39;**********&#39;) sorted_nums = sorted(all_nums) #排序 num_dict = &#123;&#125; #定义空字典 for num in sorted_nums: #循环遍历，通过key值找value if num in num_dict: num_dict[num] += 1 else: num_dict[num] = 1 print(num_dict) 学习引导： 数据类型-字典 创建 增删改查 循环 数据类型-字典关键点： 健与值用冒号：分开 项与项用逗号，分开 特性： key-value结构； key必须是不可变类型，唯一性； 可存放多个value，可修改，不唯一； 无序； 查询速度快，不受dict大小影响； 字典的创建#直接给出key和value info=&#123;&#39;name&#39;:&#39;小王&#39;, &#39;num&#39;:&#39;20192812&#39;, &#39;gender&#39;:&#39;女&#39;&#125; info #&#123;&#39;name&#39;: &#39;小王&#39;, &#39;num&#39;: &#39;20192812&#39;, &#39;gender&#39;: &#39;女&#39;&#125; 法二 #key和value分别赋值 keys=[1,2,3,4,5] &#123;&#125;.fromkeys(keys) #&#123;1: None, 2: None, 3: None, 4: None, 5: None&#125; &#123;&#125;.fromkeys(keys,100) #&#123;1: 100, 2: 100, 3: 100, 4: 100, 5: 100&#125; 字典的增加#字典的增加 info[&#39;age&#39;]=&#39;20&#39; info #&#123;&#39;name&#39;: &#39;小王&#39;, &#39;num&#39;: &#39;20192812&#39;, &#39;gender&#39;: &#39;女&#39;, &#39;age&#39;: &#39;20&#39;&#125; 字典的删除 pop/del/clear法一 #字典的删除 info.pop(&#39;gender&#39;) info #&#123;&#39;name&#39;: &#39;小王&#39;, &#39;num&#39;: &#39;20192812&#39;, &#39;age&#39;: &#39;20&#39;&#125; 法二 del info[&#39;name&#39;] info #&#123;&#39;num&#39;: &#39;20192812&#39;, &#39;age&#39;: &#39;20&#39;&#125; 法三 info.clear() info #&#123;&#125; 字典的修改 update#字典的修改 dic=&#123;&#39;name&#39;:&#39;小王&#39;, &#39;num&#39;:&#39;20192898&#39;, &#39;gender&#39;:&#39;男&#39;&#125; dic2=&#123;&#39;name&#39;:&#39;小王&#39;, &#39;num&#39;:&#39;20192812&#39;, &#39;gender&#39;:&#39;女&#39;, &#39;age&#39;:&#39;20&#39;&#125; dic2 #&#123;&#39;name&#39;: &#39;小王&#39;, &#39;num&#39;: &#39;20192812&#39;, &#39;gender&#39;: &#39;女&#39;, &#39;age&#39;: &#39;20&#39;&#125; dic.update(dic2) #合并后重合的key被覆盖 dic #&#123;&#39;name&#39;: &#39;小王&#39;, &#39;num&#39;: &#39;20192812&#39;, &#39;gender&#39;: &#39;女&#39;, &#39;age&#39;: &#39;20&#39;&#125; 查操作#查操作 &#39;age&#39;in dic #判断该元素是否在字典中 #True &#39;age2&#39;in dic #False dic.get(&#39;name&#39;) #读取name的值 #&#39;小王&#39; dic.keys() #获取所有key值 #dict_keys([&#39;name&#39;, &#39;num&#39;, &#39;gender&#39;, &#39;age&#39;]) dic.values() #获取所有value值 #dict_values([&#39;小王&#39;, &#39;20192812&#39;, &#39;女&#39;, &#39;20&#39;]) dic.items() #以列表返回可遍历的(键, 值) 元组数组 #dict_items([(&#39;name&#39;, &#39;小王&#39;), (&#39;num&#39;, &#39;20192812&#39;), (&#39;gender&#39;, &#39;女&#39;), (&#39;age&#39;, &#39;20&#39;)]) 字典的循环 三种第一种 for i in dic: print(i) #遍历Key值 &#39;&#39;&#39; name num gender age &#39;&#39;&#39; 第二种 for i in dic.items(): #遍历字典 print(i) &#39;&#39;&#39; (&#39;name&#39;, &#39;小王&#39;) (&#39;num&#39;, &#39;20192812&#39;) (&#39;gender&#39;, &#39;女&#39;) (&#39;age&#39;, &#39;20&#39;) &#39;&#39;&#39; 第三种 for i,j in dic.items(): #遍历字典 print(i,j) &#39;&#39;&#39; name 小王 num 20192812 gender 女 age 20 &#39;&#39;&#39; 小作业 交换字典的key和value 构造一个字典，存储以下两位客人所点pizza order： first: ​ guest_surname: Grand ​ crust: thin ​ toppings: mushrooms cheese onion second: ​ guest_surname: Suzu ​ crust: thick ​ toppings: mushrooms onion peppers 按上述显示格式输出该字典（注意输出格式的缩进和换行）","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python入门","slug":"Python/Python入门","permalink":"http://www.a2data.cn/categories/Python/Python%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"Day5.布尔元组字符串","slug":"Python/Python入门/Day5布尔元组字符串","date":"2020-09-11T08:48:34.000Z","updated":"2020-09-11T09:18:46.333Z","comments":true,"path":"posts/f9586000.html","link":"","permalink":"http://www.a2data.cn/posts/f9586000.html","excerpt":"数据类型-元组-字符串-布尔","text":"数据类型-元组-字符串-布尔 例题引导: 把True变为False，把False变为True后输出： 参考答案： print not True print not False 学习引导： 数据类型-布尔 数据类型-元组 数据类型-字符串 bool布尔类型布尔类型取值只有两种情况，表示真假值，即 yes or no python 中布尔值使用常量True 和 False来表示；注意大小写 比较运算符&lt; &gt; == 等返回的类型就是bool类型； 布尔类型通常在 if （判断）和 while （循环）语句中应用 下面是一个简单的案例演示 print(True==1) print(False==0) print(2&gt;1) print(0&gt;3) &#39;&#39;&#39; True True True False &#39;&#39;&#39; 小测试：请列举布尔值是false的值： 数据类型-元组和列表很相似，区别在于 不可修改 用小括号框 其余用法基本一致 下面我们直接演示一些元组的方法 #索引、长度、切片、循环 a=[2,3,4,5,&#39;32&#39;,&#39;你好&#39;] a #[2, 3, 4, 5, &#39;32&#39;, &#39;你好&#39;] a[4] #元组中第5个元素 #&#39;32&#39; len(a) #元组a的长度 #6 a[0:3] #取该元组中第一个到第三个的值 #[2, 3, 4] 遍历元组for i in a: print(i) 2 3 4 5 32 你好 查询判断&#39;32&#39; in a #判断字符串32是否在元组a中 #True 32 in a #判断整数32是否在元组a中 #False 如果不可变的元组中包含可变的元素（例如列表），则元组可变 tuple_=(3,4,2,&#39;元组&#39;,[3,4,&#39;d&#39;,&#39;2&#39;],&#39;32&#39;) tuple_ #(3, 4, 2, &#39;元组&#39;, [3, 4, &#39;d&#39;, &#39;2&#39;], &#39;32&#39;) #更改数据会报错 tuple_[3]=1 tuple_ --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-9-13fb7bda7784&gt; in &lt;module&gt; ----&gt; 1 tuple_[3]=1 2 tuple_ TypeError: &#39;tuple&#39; object does not support item assignment #更改元组中的列表部分 tuple_[4][0]=&#39;数据&#39; tuple_ #(3, 4, 2, &#39;元组&#39;, [&#39;数据&#39;, 4, &#39;d&#39;, &#39;2&#39;], &#39;32&#39;) string字符串 和列表操作类似 切片 索引 特点是不可变性 python中单引号和双引号使用完全相同。使用三引号(‘’’或”””)可以指定一个多行字符串。 print(&#39;data science&#39;) print(&quot;data science&quot;) print(&#39;&#39;&#39;this is data science Learning together&#39;&#39;&#39;) print(&quot;&quot;&quot;this is data science Learning together&quot;&quot;&quot;) &#39;&#39;&#39; data science data science this is data science Learning together this is data science Learning together &#39;&#39;&#39; 转义符 ‘’:反斜杠可以用来转义，使用r可以让反斜杠不发生转义。 如 r”data science \\n” 则\\n会显示，并不是换行。 按字面意义级联字符串，如”this “ “is “ “data science”会被自动转换为this is data science。 转义字符演示 print(&#39;data\\nscience&#39;) #表示换行 print(r&#39;data\\nscience&#39;) #加r则无特殊意义，正常输出 print(&#39;this&#39;,&#39;is&#39;,&#39;DataScience&#39;) #逐个输出字符串 &#39;&#39;&#39; data science data\\nscience this is DataScience &#39;&#39;&#39; 字符串可以用 ‘+’运算符连接在一起，用 ‘*’ 运算符重复。 str=&#39;DataScience&#39; print(str+&#39;你好&#39;) #连接两个字符串 print(str*5) #打印该字符串5次 #DataScience你好 #DataScienceDataScienceDataScienceDataScienceDataScience Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。 索引演示： str=&#39;DataScience&#39; print(str[1]) #打印该字符串中第一个元素 print(str[2:-1]) #打印该字符串中第三个元素到倒数第二个元素 #a #taScienc Python中的字符串不能改变。 str=&#39;DataScience&#39; str[0]=&#39;s&#39; print(str[0]) --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-31-f432ac1ed2d2&gt; in &lt;module&gt; 1 str=&#39;DataScience&#39; ----&gt; 2 str[0]=&#39;s&#39; 3 print(str[0]) TypeError: &#39;str&#39; object does not support item assignment Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。字符串的截取的语法格式如下：变量[头下标:尾下标:步长] str=&#39;welcome to the DataScience&#39; print(str[0:13:2]) #wloet h 关于字符串的内容，后面有一节会详细讲解。 今天没有很多小练习，建议复习一下之前的学习内容。","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python入门","slug":"Python/Python入门","permalink":"http://www.a2data.cn/categories/Python/Python%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"1.Git使用","slug":"Git/Git使用","date":"2020-09-11T08:37:06.000Z","updated":"2025-05-05T06:07:54.179Z","comments":true,"path":"posts/ff995e29.html","link":"","permalink":"http://www.a2data.cn/posts/ff995e29.html","excerpt":"Git 快速学习。","text":"Git 快速学习。 0、查看本机公钥 步骤： 1、进入.ssh目录 cd ~/.ssh 2、找到id_rsa.pub文件 ls / ll 3、查看文件 cat id_rsa.pub JackFeng@JackFeng MINGW64 ~/Desktop $ cd ~/.ssh JackFeng@JackFeng MINGW64 ~/.ssh $ ls config id_rsa id_rsa.pub id_rsa_sql id_rsa_sql.pub known_hosts JackFeng@JackFeng MINGW64 ~/.ssh $ cat id_rsa.pub 1、配置多个git仓库多仓库之间 &#39;ssh-key切换&#39; #1、生成客户端自己的密钥对 ssh-keygen ---- 一顿回车即可 # 实际操作 换成你的邮箱即可 ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 可以在客户端的家目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥。 生成新的ssh-key #second@mail.com 工作邮箱地址 ssh-keygen -t rsa -C &#39;second@mail.com&#39; -f id_rsa_second 配置多个仓库 在.ssh目录创建config文本文件并完成相关配置(最核心的地方)每个账号单独配置一个Host，每个Host要取一个别名，每个Host主要配置HostName和IdentityFile两个属性即可 Host的名字可以取为自己喜欢的名字，不过这个会影响git相关命令，例如： HostName 这个是真实的域名地址IdentityFile 这里是id_rsa的地址PreferredAuthentications 配置登录时用什么权限认证–可设为publickey,password publickey,keyboard-interactive等User 配置使用用户名 config # 配置github.com Host github.com HostName github.com IdentityFile ~\\.ssh\\id_rsa PreferredAuthentications publickey User yinjie.feng # 配置SQLSQ Host SQL HostName github.com IdentityFile ~\\.ssh\\id_rsa_sql PreferredAuthentications publickey User yinjie.feng 测试是否调通 JackFeng@JackFeng MINGW64 ~/.ssh $ vim config JackFeng@JackFeng MINGW64 ~/.ssh $ ssh -T git@github.com Hi A2Data! You&#39;ve successfully authenticated, but GitHub does not provide shell access. JackFeng@JackFeng MINGW64 ~/.ssh $ vim config JackFeng@JackFeng MINGW64 ~/.ssh $ ssh -T git@SQL Hi MineData-SQL! You&#39;ve successfully authenticated, but GitHub does not provide shell access. git add、git commit、git remote add、git push需要说明的一点，在git commit 时需要一次身份验证，正确输入你的用户名和邮箱就可以了。 另外注意：github根据配置文件的user.email来获取github帐号显示author信息，所以对于多帐号用户一定要记得将user.email改为相应的email(monster@mail.com)。 总结一下:其实建立第二个密钥对的区别就在于对第二密钥对的声明，因此需要在.ssh目录下添加config文件，添加语句dentityFile ~/.ssh/id_rsa_sql声明这是第二个密钥对。这条连接命令就体现出来了。 查看用户名git config user.name git config user.email 修改用户名git config --global user.name &quot;xxx&quot; git config --global user.email &quot;xxx&quot; 2、从远程项目拉取git clone 项目地址 3、提交代码到远程仓库常规操作 ##添加 git add . . #查看状态 git status # 提交 git commit -m &quot;代码描述&quot; # 再次查看状态 git status # 拉取最新代码 git pull # 提交 git push 4、git分支操作Git初始化 解决 fatal: Not a git repository (or any of the parent directories): .git 问题 git init git clone --- 克隆项目 JackFeng@JackFeng MINGW64 /d/Practice $ git clone git@github.com:MineData-SQL/SQL.git Cloning into &#39;SQL&#39;... remote: Enumerating objects: 3, done. remote: Counting objects: 100% (3/3), done. remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 Receiving objects: 100% (3/3), done. 创建分支git branch &lt;branch_name&gt; #指定分支名称 git checkout -b [&quot;分支名&quot;] 查看分支git branch # 查看所有分支,* 号所属代表当前分支 git branch # 查看分支详情，包括分支指向得commitid及提交信息 切换分支git checkout &lt;branch_name&gt; #切换到指定分支 git checkout -b &lt;branch_name&gt; #创建并切换到指定分支 删除分支git branch -d &lt;branch_name&gt; .#删除一个干净的分支(即相对当前分支而言该分支没有新的提交记录) git branch -D &lt;branch_name&gt; .#强制删除一个分支，该分支有没有合并到当前分支的提交记录 注意：删除分支前都需要先切换到其他分支才能进行删除操作 分支恢复 思路：对于已经有提交记录的分支删除后，实际上只是删除指针，commit记录还保留，如果想恢复，需要使用git reflog查找该分支指向的 commitId，然后根据commitId创建新的分支 HEAD@&#123;1&#125; git reflog git branch &lt;branch_name&gt; &lt;hash_val&gt; #根据指定commit创建新分支 分支改名git branch -m &lt;branch_name&gt; newname JackFeng@JackFeng MINGW64 /d/Practice/SQL (master-two) $ git branch -m master-one master-O JackFeng@JackFeng MINGW64 /d/Practice/SQL (master-two) $ git branch master master-O * master-two 分支合并 git merge #将指定分支合并到当前分支如果两个分支没有产生分叉情况，那么会进行快速合并，即fast-forward方式，它并不会产生新的commitId，只是改变了指针的指向，产生分叉合并可能会有冲突情况。 示例： 合并master-O分支到master分支，此时合并为fast-forward方式 分支合并细节 git merge -ff -m &quot;msg&quot; #合并分支时禁用Fast forward模式 如果使用fast-forward方式进行分支合并，只是简单改变了分支指针，而不会产生新的commit记录。 为了保证合并数据的完整性，我们也可以在合并时指定不使用fast-forward方式，使用 --ff 选项。这样，在merge时就会生成一个新的commit，从日志上就可以看到分支合并记录了。 示例：我们在master-two分支上新增一次提交，然后合并到master分支上，git log查看最新一次的提交记录，显示的正是我们合并分支时的记录 git log --pretty=oneline -1 JackFeng@JackFeng MINGW64 /d/Practice/SQL (master) $ git checkout master-two Switched to branch &#39;master-two&#39; JackFeng@JackFeng MINGW64 /d/Practice/SQL (master-two) $ echo &quot; thank you for attention DataScience &quot; &gt;&gt; a2data.txt JackFeng@JackFeng MINGW64 /d/Practice/SQL (master-two) $ git add a2data.txt warning: LF will be replaced by CRLF in a2data.txt. The file will have its original line endings in your working directory JackFeng@JackFeng MINGW64 /d/Practice/SQL (master-two) $ git commit -m &quot; add file&quot; [master-two 59a8816] add file 1 file changed, 1 insertion(+) create mode 100644 a2data.txt JackFeng@JackFeng MINGW64 /d/Practice/SQL (master-two) $ git checkout master Switched to branch &#39;master&#39; Your branch is up to date with &#39;origin/master&#39;. JackFeng@JackFeng MINGW64 /d/Practice/SQL (master) $ git merge --ff -m &quot;meger master-two branch&quot; master-two Updating ab83ffb..59a8816 Fast-forward (no commit created; -m option ignored) a2data.txt | 1 + 1 file changed, 1 insertion(+) create mode 100644 a2data.txt JackFeng@JackFeng MINGW64 /d/Practice/SQL (master) $ git log --pretty=oneline -1 59a88161e630f0853b852946fddb6c7e787906fe (HEAD -&gt; master, master-two) add file 冲突解决 当对分叉分支进行合并时，如果两个分支都对同一文件进行了修改，那么合并时就有可能会产生冲突情况。 如果两个分支对同一文件的修改是有规律的，比如对不同地方的修改，那么git工具可以实现自动合并. 如果无法自动合并，则需要对冲突文件进行手动修改，修改完成后使用git add表示冲突已经解决，然后使用git commit进行提交 示例：在master分支上对两个文件进行修改提交. a2data.txt和*DataScience。 然后切换到master-O分支上对两个文件进行修改提交. 文件由于修改的是不同地方，所以自动合并。 我们查看DataScience文件的内容，==上面和下面的内容分别代表了不同分支的修改内容，将冲突标记去掉，然后内容根据需求进行恰当的修改，然后进行一次提交即完成了冲突的解决。 修改文件相同则会产生合并冲突 (merge conflict) master master-O 合并分支 分支同步 主要是 自己的分支与主分支保持同步。 步骤： 1、git remote add master &#103;&#105;&#116;&#x40;&#x67;&#105;&#x74;&#104;&#117;&#x62;&#46;&#99;&#111;&#109;:A2Data/A2Data.github.io.git // 主分支master 2、 git branch -v 查看是否添加 3、git fetch master // 获取主分支的最新修改到本地 4、git merge master/master-O // 将master分支修改内容merge到本地个人分支； // 该步骤或者可以分成2步： 1） # git checkout master-O； // checkout到master-O分支 2） # git merge master； //合并主分支修改到本地master分支； 5、git push //本地分支提交到github上的个人分支 分支暂存 git stash #将工作暂存git stash list #列出所有的暂存状态 从暂存区之中进行恢复，有两种处理方式：1.先恢复，而后再删除暂存git stash applygit stash drop2.恢复的同时也将stash内容删除git stash pop 当我们在分支上进行代码开发时，有可能会接到突发需求，而当前的代码尚未完成，所以还**不能直接提交。** 为了解决这样的问题，git就提供了分支暂存的机制，可以将开发一半的分支进行保存，在适当的时候进行代码恢复。 示例：在master-two分支上新建文件，然后添加到暂存区表示尚未完成的任务，对当前分支进行暂存，git status显示工作空间是干净的。 5、git命令问题 GitBash 中按下 Ctrl+C 无法中断 webpack-dev-server 解决办法： 打开 cmd 复制 taskkill /F /IM node.exe 然后粘贴运行 搞定 这是 GitBash 的一个 BUG，不知何时修复。 欢迎关注","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://www.a2data.cn/tags/Git/"}]},{"title":"Hello World","slug":"Hexo/hello-world","date":"2020-09-11T08:29:48.927Z","updated":"2025-05-05T06:07:54.181Z","comments":true,"path":"posts/4a17b156.html","link":"","permalink":"http://www.a2data.cn/posts/4a17b156.html","excerpt":"Hexo 初始页面。","text":"Hexo 初始页面。 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.a2data.cn/tags/Hexo/"}]},{"title":"Python数据类型-列表","slug":"Python/Python入门/Day4数据类型-列表","date":"2020-09-03T12:51:46.000Z","updated":"2020-09-11T08:26:08.609Z","comments":true,"path":"posts/8c0ed688.html","link":"","permalink":"http://www.a2data.cn/posts/8c0ed688.html","excerpt":"Python数据类型-列表！！！","text":"Python数据类型-列表！！！ 例题引导： 三个小盆友 Candy,Mandy,Sandy 分别拿着玩具 Teddy bear,Barbie,Lego。 建立列表存储上述变量，并依次输出每位小盆友拿着什么玩具(xxx is holding xxx.)。 参考答案： kids = [&#39;candy&#39;,&#39;mandy&#39;,&#39;sandy&#39;] toys = [&#39;Teddy bear&#39;,&#39;Barbie&#39;,&#39;Lego&#39;] #先建立两个列表 for i in range(0,3): #遍历输出 print(kids[i].title()+&#39; is holding &#39;+toys[i]+&#39;.&#39;) 学习引导： 数据类型-列表 增加 插入 嵌套 删除 修改 …… 数据类型-列表List（列表） 是 Python 中使用最频繁的数据类型。 列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。 列表是写在方括号 [] 之间、用逗号分隔开的元素列表。 和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。 列表截取的语法格式如下：变量[头下标：尾下标] 列表中的元素是可以改变的，很多操作和字符串类似 下面演示部分列表常用的操作 a=[&#39;123&#39;,&#39;datascience&#39;,&#39;4345&#39;,&#39;f&#39;,&#39;3&#39;] b=[&#39;ppp&#39;] print(a[2]) #输出第三个元素 a[0]=321 #讲列表a中的第一个元素替换 print(a[0]) #打印a中第一个元素 print(a[0:3]) #打印a中第一个到第三个元素。注意：python语言取左不取右 print(a[2:-1]) #打印a中第三个到倒数第二个元素 print(a+b) #将列表a，b相加 print(b*3) #将列表b乘以三 &#39;&#39;&#39; 4345 321 [321, &#39;datascience&#39;, &#39;4345&#39;] [&#39;4345&#39;, &#39;f&#39;] [321, &#39;datascience&#39;, &#39;4345&#39;, &#39;f&#39;, &#39;3&#39;, &#39;ppp&#39;] [&#39;ppp&#39;, &#39;ppp&#39;, &#39;ppp&#39;] &#39;&#39;&#39; 列表的特点： 可存放多个值 有序。按照从左到右的顺序定义列表元素，下标从0开始按顺序访问 可修改指定索引位置的值，是可变的。 增加 appendnames=[&#39;data&#39;,&#39;science&#39;] names #[&#39;data&#39;, &#39;science&#39;] names.append(&#39;excellent&#39;) names #[&#39;data&#39;, &#39;science&#39;, &#39;excellent&#39;] 插入 insert/extendnames.insert(2,&quot;数据科学&quot;) names #[&#39;data&#39;, &#39;science&#39;, &#39;数据科学&#39;, &#39;excellent&#39;] name=[&#39;数据科学&#39;,&#39;学姐&#39;,&#39;学长&#39;] names.extend(name) names #[&#39;data&#39;, &#39;science&#39;, &#39;数据科学&#39;, &#39;excellent&#39;, &#39;数据科学&#39;, &#39;学姐&#39;, &#39;学长&#39;] 嵌套 insertnames #[&#39;data&#39;, &#39;science&#39;, &#39;数据科学&#39;, &#39;excellent&#39;, &#39;数据科学&#39;, &#39;学姐&#39;, &#39;学长&#39;] names.insert(2,[0,0,4]) names #[&#39;data&#39;, &#39;science&#39;, [0, 0, 4], &#39;数据科学&#39;, &#39;excellent&#39;, &#39;数据科学&#39;, &#39;学姐&#39;, &#39;学长&#39;] 直接删除 delnames #[&#39;data&#39;, &#39;science&#39;, [0, 0, 4], &#39;数据科学&#39;, &#39;excellent&#39;, &#39;数据科学&#39;, &#39;学姐&#39;, &#39;学长&#39;] del names[2] names #[&#39;data&#39;, &#39;science&#39;, &#39;数据科学&#39;, &#39;excellent&#39;, &#39;数据科学&#39;, &#39;学姐&#39;, &#39;学长&#39;] pop 删除names #[&#39;data&#39;, &#39;science&#39;, &#39;数据科学&#39;, &#39;excellent&#39;, &#39;数据科学&#39;, &#39;学姐&#39;, &#39;学长&#39;] names.pop() #默认删除最后一个元素并返回被删除的值 names.pop(1) names #[&#39;data&#39;, &#39;数据科学&#39;, &#39;excellent&#39;, &#39;数据科学&#39;, &#39;学姐&#39;] clear 清空name #[&#39;数据科学&#39;, &#39;学姐&#39;, &#39;学长&#39;] name.clear() name #[] 修改names #[&#39;data&#39;, &#39;数据科学&#39;, &#39;excellent&#39;, &#39;数据科学&#39;, &#39;学姐&#39;] names[0]=&#39;data2&#39; names[-1]=&#39;Shon&#39; names #[&#39;data2&#39;, &#39;数据科学&#39;, &#39;excellent&#39;, &#39;数据科学&#39;, &#39;Shon&#39;] 查操作 index /count/removenames #[&#39;data2&#39;, &#39;数据科学&#39;, &#39;excellent&#39;, &#39;数据科学&#39;, &#39;Shon&#39;] names.index(&#39;excellent&#39;) #返回从左开始匹配到的第一个excellent的索引 #2 names.count(&#39;数据科学&#39;) #返回元素“excellent”的个数 #2 &#39;data2&#39; in names #True names #[&#39;data2&#39;, &#39;数据科学&#39;, &#39;excellent&#39;, &#39;数据科学&#39;, &#39;Shon&#39;] names.remove(&#39;Shon&#39;) names #[&#39;data2&#39;, &#39;数据科学&#39;, &#39;excellent&#39;, &#39;数据科学&#39;] 切片操作就像切面包，一片一片的把列表切开 切片操作是列表操作中 a=[&#39;123&#39;,&#39;987&#39;,&#39;3&#39;,&#39;dc&#39;,&#39;真的&#39;,&#39;r&#39;] a #[&#39;123&#39;, &#39;987&#39;, &#39;3&#39;, &#39;dc&#39;, &#39;真的&#39;, &#39;r&#39;] a[0:2] #[&#39;123&#39;, &#39;987&#39;] a[4:-1] #[&#39;真的&#39;] a[0:-1] #[&#39;123&#39;, &#39;987&#39;, &#39;3&#39;, &#39;dc&#39;, &#39;真的&#39;] a[4:] #[&#39;真的&#39;, &#39;r&#39;] #步长 a[0:4:2] #[&#39;123&#39;, &#39;3&#39;] a[0::2] #[&#39;123&#39;, &#39;3&#39;, &#39;真的&#39;] a[-1:-6:-1] #[&#39;r&#39;, &#39;真的&#39;, &#39;dc&#39;, &#39;3&#39;, &#39;987&#39;] a[0::] #[&#39;123&#39;, &#39;987&#39;, &#39;3&#39;, &#39;dc&#39;, &#39;真的&#39;, &#39;r&#39;] 反转a[::-1] #[&#39;r&#39;, &#39;真的&#39;, &#39;dc&#39;, &#39;3&#39;, &#39;987&#39;, &#39;123&#39;] a[::-2] #[&#39;r&#39;, &#39;dc&#39;, &#39;987&#39;] 排序b=[4,90,54,23,44,456,1,4] b #[4, 90, 54, 23, 44, 456, 1, 4] b.sort() b #[1, 4, 4, 23, 44, 54, 90, 456] m=&#39;数据科学&#39; m #&#39;数据科学&#39; m[::-1] #&#39;学科据数&#39; 循环列表while循环 for循环 for i in b: print(i) &#39;&#39;&#39; 1 4 4 23 44 54 90 456 &#39;&#39;&#39; 今日小作业 输入n个整数，用空格分开，输出这些整数中的最大值及最大值的下标，如对应多个下标，返回最小下标。 例如输入3 4 7 2 5 7，输出7 2 判断季节,输入一个月份,判断该季节属于哪个季节 敏感词替换习题,模仿评论中出现敏感词后,替换成*,将不敏感的词以列表形式输出 用range()函数创建一个1到100的正整数数列：[1, 2, 3, …, 100]请利用切片从上述数列中分别取出： 前10个数； 后10个偶数； 3的倍数； 不大于50的5的倍数。 将输入的一行字符串构造为列表（每个字母为一个元素），依次做如下操作并输出结果： 1） 将第2个元素（元素个数从0开始计算）直到末尾替换为op； 2） 将第3个元素替换为ui； 3） 从第2个元素开始直到末尾，每隔一个元素，替换一个元素，依次替换为wo","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python入门","slug":"Python/Python入门","permalink":"http://www.a2data.cn/categories/Python/Python%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"Day3.Python判断与循环语句","slug":"Python/Python入门/Day3判断&循环语句","date":"2020-09-03T02:12:36.000Z","updated":"2020-09-11T09:16:40.665Z","comments":true,"path":"posts/901b8cd5.html","link":"","permalink":"http://www.a2data.cn/posts/901b8cd5.html","excerpt":"Python判断与循环语句！！！","text":"Python判断与循环语句！！！ 例题引导： Q：输入3个整数，按从小到大依次输出，用“-&gt;”符号相连： 例如：输入4，2，6，输出2 -&gt; 4 -&gt; 6 A： a = int(input(&#39;请输入第一个整数：&#39;)) b = int(input(&#39;请输入第二个整数：&#39;)) c = int(input(&#39;请输入第三个整数：&#39;)) if (a &gt; b): x = b b = a a = x if (a &gt; c): x = c c = a a = x if (b &gt; c): x = c c = b b = x print(a,&#39;-&gt;&#39;,b,&#39;-&gt;&#39;,c) 学习引导： if判断语句 while循环 continue、break的用法 for语句 判断语句if判断语句该语句的语法格式如下： #单条件判断： if condition_1: result_1 else: result_2 #多条件判断： if condition_1: result_1 elif: result_2 elif: result_3 else: result_4 &#39;&#39;&#39; 现在我们做一个成绩评级的小程序 要求：按照90-100/80-89/60-79/40-59/小于39 划分五个等级 &#39;&#39;&#39; score=eval(input(&quot;请输入成绩:\\n&quot;)) #eval是Python的一个内置函数，这个函数的作用是，返回传入字符串的表达式的结果。 if (score&gt;90)&amp;(score&lt;=100): print(&#39;该同学成绩为优&#39;) elif (score&gt;80)&amp;(score&lt;=89): #多条件判断 print(&#39;该同学成绩为良&#39;) elif (score&gt;60)&amp;(score&lt;=79): print(&#39;该同学成绩为良&#39;) elif (score&gt;40)&amp;(score&lt;=59): print(&#39;该同学成绩为不及格&#39;) elif (score&lt;39)&amp;(score&gt;0): print(&#39;该同学请自行退学&#39;) &#39;&#39;&#39; 请输入成绩: 34 该同学请自行退学 &#39;&#39;&#39; 小测试： 在日常编码中if的使用率会很高,但是过度臃肿的if条件会增加代码的理解难度,导致最后只能自己看懂一些 for a in Data: if a.b: if a.c: if a.d: # do sth... for a in balabala: if not a.b: continue if not a.c: continue if not a.d: continue # do sth.. 如上两端代码,进行测试的时候其中的值可以随意,虽然判断逻辑不尽相同,但是目的是一样的,这时候执行效率会有差别吗?那么if这种不可能避免的代码怎么才能进行优化,提高执行效率呢? 体质指数(BMI)=体重(kg)÷身高^2(m)，请根据公式构造一段代码，输入体重和身高，输出BMI指数结果：低于18.5：过轻18.5-25：正常25-28：过重28-32：肥胖高于32：严重肥胖 将一个正整数分解质因数。例如：输入90,打印出90=233*5 循环语句while 循环while语句格式： while condition(判断条件): statements(执行语句) 实例：计算1-100的和 #简单一点的写法 n=0 sum=0 while n&lt;=100: sum +=n n+=1 print(sum) #规范一点的写法 # n = 100 # sum = 0 # counter = 1 # while counter &lt;= n: # sum = sum + counter # counter += 1 # # print(&quot;1 到 %d 之和为: %d&quot; % (n,sum)) #5050 下面做一个小游戏，猜一下随机数 这里用到了random这个随机数模块，这个模块用于生成随机数。 其中random.randint(a,b)用于生成指定范围内的整数，参数a是下限，参数b是上限，生成的随机数介于二者之间。 import random n=random.randint(0,10) user_guess=int(input(&quot;Input your guess:&quot;)) if user_guess&gt;n: print(&#39;try smaller...&#39;) elif user_guess&lt;n: print(&#39;try bigger...&#39;) else: print(&#39;Bingo!You got it!&#39;) print(n) &#39;&#39;&#39; Input your guess:9 try smaller... 1 &#39;&#39;&#39; 上面的这串程序只能猜一次，那如果我们想要猜出结果呢?这个时候就要用到循环。下面我们对上面的代码进行优化 import random n = random.randint(0, 10) user_guess = int() while user_guess != n: user_guess = int(input(&quot;Input your guess:&quot;)) if user_guess &gt; n: print(&#39;try smaller...&#39;) elif user_guess &lt; n: print(&#39;try bigger...&#39;) else: print(&#39;Bingo!You got it!&#39;) print(n) &#39;&#39;&#39; Input your guess:3 try smaller... Input your guess:1 Bingo!You got it! 1 &#39;&#39;&#39; 小测试： 丑数是只包含质因数 2, 3, 5 的正整数。控制台输入一个正整数，判断其是否为丑数。 有n个人围成一圈，顺序排号。从第一个人开始报数（从1到3报数），凡报到3的人退出圈子，问最后留下的是原来的第几号。 使用while循环输出1-2+3-4+5…..+99的和。 continue、break的用法 continue是终止本次循环 break是终止循环 #continue举例 #输出十以内小于等于4和大于等于7的数 count=0 while count&lt;10: count +=1 if count&gt;4 and count&lt;7: continue print(count) &#39;&#39;&#39; 1 2 3 4 7 8 9 10 &#39;&#39;&#39; continue + else 的用法 count=0 while count&lt;10: count +=1 if count&gt;4 and count&lt;7: #当数字满足上述条件时，执行continue，终止本次循环，不执行打印语句。 continue print(count) else: print(&#39;循环正常结束&#39;) &#39;&#39;&#39; 1 2 3 4 7 8 9 10 循环正常结束 &#39;&#39;&#39; break的用法 count=0 while count&lt;10: count +=1 if count&gt;4: #当数字大于4的时候执行break，终止循环 break print(count) else: print(&#39;循环正常结束&#39;) &#39;&#39;&#39; 1 2 3 4 &#39;&#39;&#39; 小测试 定义用户名“python”和密码“666666”，控制台提示用户输入用户名和密码，判断用户名和密码是否正确。 输入正确则跳出循环，输出“你好！”，不正确则提示“验证失败，请重新输入！”并继续提示用户输出用户名和密码，直到用户输入正确的信息，程序结束。 for语句for循环可以遍历任何序列的所有元素 for语句的一般格式如下： for variable(变量) in [sequence(序列)]: statements(执行语句) else: statements(执行语句) 循环实例： a=[&#39;welcome&#39;,&#39;to&#39;,&#39;data&#39;,&#39;science&#39;] for i in a: #遍历数组内的每一个元素并且打印 print (i) for i in &#39;DataScience&#39;: #遍历该字符串的每一个元素且打印 print (i) print(&#39;遍历结束&#39;) &#39;&#39;&#39; welcome to data science D a t a S c i e n c e 遍历结束 &#39;&#39;&#39; for…else…语句#判断一个数是不是质数 n=int(input(&#39;请随机输入一个实数：&#39;)) for i in range(2,n): if n%i == 0: #判断是否能整除，如能，打印输出，终止循环；若不能，执行else语句 print(n,&#39;能被&#123;&#125;整除，不是质数&#39;.format(i)) #format的用法，之前的课程我们有讲到 break # continue else: print (n,&#39;是一个质数&#39;) &#39;&#39;&#39; 请随机输入一个实数：4 4 能被2整除，不是质数 &#39;&#39;&#39; 循环嵌套for 循环嵌套和while 循环嵌套的案例演示 for 循环嵌套格式 for variable in seuqence: for veriable_ in sequence_: statements_ statements #while 循环嵌套格式 while condition: while condition_: statements_ statements #for 和 while 也可相互嵌套 判断1-20之间哪些是质数 i = 2 while(i &lt; 20): j = 2 while(j &lt;= (i/j)): if not(i%j): break j = j + 1 if (j &gt; i/j): print (i, &quot; 是质数&quot;) i = i + 1 print (&quot;结束!&quot;) &#39;&#39;&#39; 2 是质数 3 是质数 5 是质数 7 是质数 11 是质数 13 是质数 17 是质数 19 是质数 结束! &#39;&#39;&#39; 小测试 在一行中输入8个人的身高（按空格分隔），输出8人的身高平均值和身高超过平均值的数： 例如：输入166 178 192 188 173 169 170 172，输出： avg = 176.0 178 192 188 将一笔零钱换成5分、2分和1分的硬币，要求每种硬币至少有一枚，有几种不同的换法？ 输入待换的零钱数额x∈(8,100)。 要求按5分、2分和1分硬币的数量依次从大到小的顺序，输出各种换法。每行输出一种换法，格式为：“fen5:5分硬币数量, fen2:2分硬币数量, fen1:1分硬币数量, total:硬币总数量”。最后一行输出“count = 换法个数”。 例如，输入13，输出如下： fen5:2, fen2:1, fen1:1, total:4 fen5:1, fen2:3, fen1:2, total:6 fen5:1, fen2:2, fen1:4, total:7 fen5:1, fen2:1, fen1:6, total:8 count = 4 输入行数，输出高度为该行数的等边三角形，每行个数递增1。例如输入3，输出： * * * * * * 计算10到20000之间,所有质数,并思考执行时间(在进行大数据量运算时,代码执行效率会影响很多) 一个数如果恰好等于它的因子之和，这个数就称为”完数”。例如6=1＋2＋3。编程找出1000以内的所有完数。","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python入门","slug":"Python/Python入门","permalink":"http://www.a2data.cn/categories/Python/Python%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"Day2.Python变量和运算符","slug":"Python/Python入门/Day2变量和运算符","date":"2020-09-02T15:58:05.000Z","updated":"2020-09-11T08:26:08.606Z","comments":true,"path":"posts/80ca38c0.html","link":"","permalink":"http://www.a2data.cn/posts/80ca38c0.html","excerpt":"Python变量与运算符！！！","text":"Python变量与运算符！！！ 我们还是用一个问题来引出今天的学习内容,同样是计算成绩。 Q：给定学生三门成绩 (1)计算该学生的平均成绩并打印平均成绩保留两位小数点 (2)计算该学生语文成绩占总成绩的百分之多少？并打印，百分比也保留两位小数 Chinese = 92 Math = 98.5 English = 93 A： # ID 生成唯一UUID Chinese = 92 Math = 98.5 English = 93 # 总成绩 SumScore = Chinese + Math + English # 平均成绩 AvgScore = SumScore / 3 # 百分比 ChinesePercent = ( Chinese / SumScore ) * 100 print(&quot;%s的平均成绩为%.2f&quot; %(ID,AvgScore)) #输出 9fde9178-ec75-11ea-9d07-a0510bfd82f6 9fde9178-ec75-11ea-9d07-a0510bfd82f6的平均成绩为94.50 学前引导： 变量&amp;运算符(本文重点)： 变量 转义字符 运算符 初识判断语句 关于变量变量的创建过程首先，当我们定义了一个变量**name = ‘Data’**的时候，在内存中其实是做了这样一件事。 程序开辟了一块内存空间，将’Data’存储进去，再让变量名name指向’Data’所在的内存地址。如下所示： #通过下列方法可以查看这个变量在内存中的地址 name = &#39;Data&#39; print(id(name)) 2720846969904 变量的修改一般我们认为修改一个变量就是用新值把就旧值覆盖掉 实际的原理是什么样的呢？ 程序先申请了一块内存空间来存储’Data’，让name变量名指向这块内存空间，往下执行name = ‘Science’之后，又申请了另一块内存空间来存储’Science’，并让原本指向’Data’内存的链接断开，让name再指向’Science’。 #案例演示 name = &#39;Data&#39; print(id(name)) name = &#39;Science&#39; print(id(name)) 2720846969904 2718733174640 变量的指向关系当执行name2 = name1时，事实上时让name2指向了’Data’所在的内存地址。 修改name1的值，相当于断开了name1到’Data’的链接，重新建立name1和’Science’之间的链接。 在这个过程中，始终没有影响到name2和’Data’之间的关系，因此name2还是’Data’，而name1变成了’Science’ #案例演示 name1 = &#39;Data&#39; name2 = name1 print(name1, name2) name1 = &#39;Science&#39; print(name1, name2) Data Data Science Data 变量小测试：1、以下可以作为python标识符是___。 A.2morrow B.your-name C._study D.abc*123 2、如下示例:字符串str1的值赋值给str2时,str2的变量地址是否改变?如果是字典赋值呢? str1= &#39;python&#39; str2= &#39;pandas&#39; str2= str1 运算符 算术运算符 运算优先级 赋值运算符 复合赋值运算符 算术运算符即基本的算术运算：加+、 减- 、乘* 、除/ 、取余% 、幂** 、取整除// 下面以a=10 ,b=20为例进行计算 运算符 描述 实例 + 加 两个对象相加 a + b 输出结果 30 - 减 得到负数或是一个数减去另一个数 a - b 输出结果 -10 * 乘 两个数相乘或是返回一个被重复若干次的字符串 a * b 输出结果 200 / 除 x除以y b / a 输出结果 2 % 取余 返回除法的余数 b % a 输出结果 0 ** 幂 返回x的y次幂 a**b 为10的20次方， 输出结果 100000000000000000000 // 取整除 返回商的整数部分 9//2 输出结果 4 , 9.0//2.0 输出结果 4.0 # 更多案例 a=21 b=3 c=4 print(a+b) print(a-b) print(a/b) print(a*b) print(c**3) print(a%c) print(a//c) print(45-a) 24 18 7.0 63 64 1 5 24 赋值运算符 运算符 描述 实例 = 赋值运算符 把=号右边的结果给左边的变量 num=1+2*3 结果num的值为7 直接赋值= 加法赋值运算符 += 减法赋值运算符 -= 乘法赋值运算符 *= 除法赋值运算符 /= 取余赋值运算符 %= 幂赋值运算符**= 取整除赋值运算符//= 其中比较常见的运算符有+=(自加)和-=(自减) a=3 b=2 c=10 # c+=a c/=b print(c) a+=4 print(a) 5.0 7 复合赋值运算符 运算符 描述 实例 += 加法赋值运算符 c += a 等效于 c = c + a -= 减法赋值运算符 c -= a 等效于 c = c - a *= 乘法赋值运算符 c *= a 等效于 c = c * a /= 除法赋值运算符 c /= a 等效于 c = c / a %= 取模赋值运算符 c %= a 等效于 c = c % a **= 幂赋值运算符 c ** = a 等效于 c = c ** a //= 取整除赋值运算符 c //= a 等效于 c = c // a 比较运算符比较运算符通常在条件判断中经常使用到 相等== 不相等！= 大于&gt; 小于&lt; 大于等于&gt;= 小于等于&lt;= 如下表 运算符 描述 示例 == 检查两个操作数的值是否相等，如果是则条件变为真。 如a=3,b=3则（a == b) 为 true. != 检查两个操作数的值是否相等，如果值不相等，则条件变为真。 如a=1,b=3则(a != b) 为 true. &lt;&gt; 检查两个操作数的值是否相等，如果值不相等，则条件变为真。 如a=1,b=3则(a &lt;&gt; b) 为 true。这个类似于 != 运算符 &gt; 检查左操作数的值是否大于右操作数的值，如果是，则条件成立。 如a=7,b=3则(a &gt; b) 为 true. &lt; 检查左操作数的值是否小于右操作数的值，如果是，则条件成立。 如a=7,b=3则(a &lt; b) 为 false. &gt;= 检查左操作数的值是否大于或等于右操作数的值，如果是，则条件成立。 如a=3,b=3则(a &gt;= b) 为 true. &lt;= 检查左操作数的值是否小于或等于右操作数的值，如果是，则条件成立。 如a=3,b=3则(a &lt;= b) 为 true. a=5 b=10 c=1 print(a&gt;b) if a&gt;b: print(&#39;a大于b&#39;) else: print(&#39;a小于b&#39;) False a小于b 逻辑运算符逻辑运算符为结果真假的与或非分别用and or not来表示，我们这里可以通过简单的赋值来体会这个逻辑关系。 运算符 逻辑表达式 描述 实例 and x and y 布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 (a and b) 返回 20。 or x or y 布尔”或” - 如果 x 是 True，它返回 True，否则它返回 y 的计算值。 (a or b) 返回 10。 not not x 布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not(a and b) 返回 False a = 10 b = 20 if a and b : #判断a和b是否都为真 print(&quot;a，b均为真&quot;) else: print(&quot;a,b中有一个不为真&quot;) ********************************** if a or b : print(&quot;a,b中至少有一个为真&quot;) else: print(&quot;a,b都不为真&quot;) *********************************** #修改变量 a 的值 a = 0 if a and b : print (&quot;a,b都为真&quot;) else: print(&quot;a,b中有一个不为真&quot;) *********************************** if a or b : print(&quot;a,b中至少有一个为真&quot;) else: print(&quot;a,b都不为真&quot;) ************************************ if not( a and b ): print(&quot;a,b中至少有一个为假&quot;) else: print(&quot;a,b都为真&quot;) a，b均为真 a,b中至少有一个为真 a,b中有一个不为真 a,b中至少有一个为真 a,b中至少有一个为假 位运算符按位运算符是把数字看作二进制来进行计算的。 ‘&amp;’表示为按位与 ‘|’表示为按位或 ‘^’表示按位异或 ‘~’表示按位取反 ‘&lt;&lt;’表示按位左移 ‘&gt;&gt;’表示按位右移 a = 60 # 60 = 0011 1100 b = 13 # 13 = 0000 1101 c = 0 c = a &amp; b; # 12 = 0000 1100 print(&quot; c 的值为：&quot;, c) c = a | b; # 61 = 0011 1101 print(&quot;c 的值为：&quot;, c) c = a ^ b; # 49 = 0011 0001 print (&quot;c 的值为：&quot;, c) c = ~a; # -61 = -0111101 print(&quot;c 的值为：&quot;, c) c = a &lt;&lt; 2; # 240 = 1111 0000 print(&quot;c 的值为：&quot;, c) c = a &gt;&gt; 2; # 15 = 0000 1111 print(&quot;c 的值为：&quot;, c) 条件(三元)运算符语法： ​ 语句1 if 条件表达式 else 语句2 执行流程： 条件运算符在执行时，会先对条件表达式进行求值判断 如果判断结果为True，则执行语句1，并返回执行结果 如果判断结果为False，则执行语句2，并返回执行结果 例子： a=10 b=5 if a&gt;15: c=a else: c=b print(c) 5 上面的运算可以用三元运算来表示，即： c=a if a&gt;15 else b print(c) 5 今日小作业1、控制台输入半径，计算圆的面积，圆周率取3.14。 输入格式： 系统提示the radius is，输入一个整数 输出格式（以半径2为例）： area=12.56 2、判断字符串”alpha”和”Beta”的大小： A.”alpha” &lt; “Beta” -B.”alpha” &gt; “Beta” 3、如下代码的运算结果是： 1 == 1 and not (&quot;apple&quot; == 1 or 1 == 0) A. True B. False C. 1 D. 0 4、如下代码的运算结果是： not 2 &gt; 1 and 3 &lt; 4 or 4 &gt; 5 and 2 &gt; 1 and 9 &gt; 8 or 7 &lt; 6 A. True B. False C. 无法输出 5、控制台输入两个整数，输出两数之和，要求不得使用 “+”、“-”、“*”、“/” 四则运算符号。 6、输入三个整数，用三目运算符输出其中的最大值","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python入门","slug":"Python/Python入门","permalink":"http://www.a2data.cn/categories/Python/Python%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"Day1.Python基本操作与格式规范","slug":"Python/Python入门/Day1基本操作与格式规范","date":"2020-09-01T01:58:45.000Z","updated":"2025-05-04T18:37:40.534Z","comments":true,"path":"posts/fbd6efa0.html","link":"","permalink":"http://www.a2data.cn/posts/fbd6efa0.html","excerpt":"Python基本操作与格式规范！！！","text":"Python基本操作与格式规范！！！ 在开始学习之前，我们做一道题，来作为大家今天的开场白！！ Q：现有信息学号为u20201111的学生，数学成绩为85，化学成绩为82.46，请按下方格式输出该信息 u20201111 的数学分数是 85 u20201111 的化学分数是 82.46 A: uid = &#39;u20201111&#39; Math = 85 Chemistry = 82.46 Sum = Math + Chemistry print(&quot;%s 的数学成绩是 %d&quot; %(uid,Math)) print(&quot;%s 的化学成绩是 %.2f&quot; %(uid,Chemistry)) print(&quot;%s 的总成绩是 %d&quot;%(uid,Sum)) &#39;&#39;&#39; 上面的小例题大家看懂了吗？没看懂的要亲手敲一下哦~ &#39;&#39;&#39; 学前引导： 基本操作和格式规范（本文重点） 编码规范 注释 打印 格式化输出 format用法 转义字符 编码规范国际惯例，文件编码和 Python 编码格式全部为 utf-8 例如：在 Python 代码的开头，要统一加上 # – coding: utf-8 –。 命名规范变量和标识符，变量和标识符在命名规则上都遵循以下原则， 只能由字母、数字和下划线组成，且不能以数字开头 命名要做到见名知意：一般来说，只要是自定义的名字都可以被称为标识符，包括变量、函数名、类名、模块名、包名，所以变量其实只是标识符的一个子类。 变量常见的命名风格有三种： 单词全部纯小写，单词之间使用下划线隔开，例如：data_science 小驼峰式命名，第一个单词字母全小写，其他单词首字母大写，例如：dataScience 大驼峰式命名，每个单词的首字母均大写，例如：DataScience 以上这些命名规范不仅仅适用于变量，同时也适用于函数、类等； 在Python中，方法和变量名一般采用第一种方式，类名采用第三种方式，第二种方式在Java声明函数时比较常见。 切记，标识符的名字不能和Python的关键字冲突(可以使用keyword.kwlist查看Python所有的关键字) 注释Python2-3输出区别 Python3 使用 print 必须要以小括号包裹打印内容，比如 print(&#39;hi&#39;) Python2 既可以使用带小括号的方式，也可以使用一个空格来分隔打印内容，比如 print &#39;hi&#39; 现在都是以python3为主 Python中单行注释以 # 开头，实例如下： #我的第一行代码 print(&#39;hello world&#39;) #我的第二个注释 hello world 多行注释可以用多个 # 号，还有 ‘’’ 和 *”””*： &#39;&#39;&#39; 我真的 可以 注释 很多行 &#39;&#39;&#39; &quot;&quot;&quot; 我也能 注释 很多行 &quot;&quot;&quot; print(&#39;hello world&#39;) hello world 格式化输出**拼接符 ‘+’ ** print(‘变量名：’+变量) 注意：变量必须为字符串类型 拼接符’,’ print(‘变量名：’，变量) 格式化符号整数输出： %o —— oct 八进制 %d —— dec 十进制 %x —— hex 十六进制 print(&#39;%o&#39; % 20) #以八进制输出20 print(&#39;%d&#39; % 20) #以十进制输出20 print(&#39;%x&#39; % 20) #以十六进制输出20 24 20 14 浮点数输出 %f ——保留小数点后面六位有效数字 %.3f，保留3位小数位 %e ——保留小数点后面六位有效数字，指数形式输出 %.3e，保留3位小数位，使用科学计数法 %g ——在保证六位有效数字的前提下，使用小数方式，否则使用科学计数法 %.3g，保留3位有效数字，使用小数或科学计数法 下面做一系列的演示： print(&#39;%f&#39; % 1.11) # 默认保留6位小数 print(&#39;%.1f&#39; % 1.11) # 取1位小数 print(&#39;%e&#39; % 1.11) # 默认6位小数，用科学计数法 print(&#39;%.3e&#39; % 1.11) # 取3位小数，用科学计数法 print(&#39;%g&#39; % 1111.1111) # 默认6位有效数字 print(&#39;%.7g&#39; % 1111.1111) # 取7位有效数字 print(&#39;%.2g&#39; % 1111.1111) # 取2位有效数字，自动转换为科学计数法 1.110000 1.1 1.110000e+00 1.110e+00 1111.11 1111.111 1.1e+03 format的用法format的用法很常见，并且实用，大家可以根据案例多进行模仿与演示。 format就是变量之间的映射，它有三种形式 （1）不带编号，即“{}” （2）带数字编号，可调换顺序，即“{1}”、“{2}” （3）带关键字，即“{a}”、“{tom}” 映射案例如下： print(&#39;&#123;&#125; &#123;&#125;&#39;.format(&#39;hello&#39;,&#39;world&#39;)) # 不带字段 print(&#39;&#123;0&#125; &#123;1&#125;&#39;.format(&#39;hello&#39;,&#39;world&#39;)) # 带数字编号 print(&#39;&#123;0&#125; &#123;1&#125; &#123;0&#125;&#39;.format(&#39;hello&#39;,&#39;world&#39;)) # 打乱顺序 print(&#39;&#123;1&#125; &#123;1&#125; &#123;0&#125;&#39;.format(&#39;hello&#39;,&#39;world&#39;)) print(&#39;&#123;a&#125; &#123;tom&#125; &#123;a&#125;&#39;.format(tom=&#39;hello&#39;,a=&#39;world&#39;)) # 带关键字 hello world hello world hello world hello world world hello world hello world 格式化字符串 f-string，亦称为格式化字符串常量（formatted string literals），是Python3.6新引入的一种字符串格式化方法。 f-string在形式上是以 f 或 F 修饰符引领的字符串（f’xxx’ 或 F’xxx’），以大括号 {} 标明被替换的字段； f-string在本质上并不是字符串常量，而是一个在运行时运算求值的表达式。 先尝试一下str、int类型的变量 name = &quot;小风&quot; age = 18 print(f&quot;姓名：&#123;name&#125;，年龄：&#123;age&#125;&quot;) 姓名：小风，年龄：18 再试一下字典 one_dict = &#123;&quot;name&quot;: &quot;小风&quot;, &quot;age&quot;: 18, &quot;hobby&quot;: [&quot;running&quot;, &quot;singing&quot;]&#125; print(f&quot;姓名：&#123;one_dict[&#39;name&#39;]&#125;,爱好：&#123;one_dict[&#39;hobby&#39;]&#125;&quot;) 姓名：小风,爱好：[&#39;running&#39;, &#39;singing&#39;] 格式规范：代码块快捷键: CTRL+ALT+L 转义字符转义字符‘\\’可以转义很多字符 ‘\\n’表示换行 ’\\t‘表示制表符 字符’\\‘本身也要转义，所以‘\\’表示的字符就是‘\\’ 下面为‘\\’在输出过程中可能出现的情况; print(&#39;I\\&#39;m ok.&#39;) I&#39;m ok. print(&#39;I\\&#39;m learning\\nPython.&#39;) I&#39;m learning Python. print(&#39;\\\\\\n\\\\&#39;) 小作业 学号为u20201111的学生，数学成绩为85，化学成绩为82.46，按格式输出： ​ u20201111 的数学分数是 85 ​ u20201111 的化学分数是 82.46 ​ 并且求出该学号学生的总成绩，以及平均分 给定两个整数A和B，输出从A到B的所有整数以及这些数的和。 输入格式： 输入在一行中给出2个整数A和B，其中−100≤A≤B≤100，以空格分隔。 输出格式： 首先顺序输出从A到B的所有整数，每5个数字占一行，每个数字占5个字符宽度，向右对齐。最后在一行中按Sum = X的格式输出全部数字的和X。 给定学生三门成绩 (1)计算该学生的平均成绩并打印平均成绩保留两位小数点 (2)计算该学生语文成绩占总成绩的百分之多少？并打印，百分比也保留两位小数 Chinese = 92 Math = 98.5 English = 93 用转义字符，输出一张todo list，包含4条内容并用制表符对齐。格式如下： This is todo list for today: * Meeting at 11:00 * lunch with Mike * buy milk * do yoga 分别用多种格式输出,答案不限,输入参数为like,learning:I like Python, and I’am learning（注意上引号） 进阶题： 编辑完成以下名片的显示： ================================== 姓名: 努力赚钱的小风 QQ:xxxxxxx 手机号:185xxxxxx 公司地址:北京市xxxx Blog:www.a2data.cn ================================== #思考，如何格式化输出？换行？ #进阶思路，如果姓名年龄是否可以是变量传入，或者外部输入呢？","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python入门","slug":"Python/Python入门","permalink":"http://www.a2data.cn/categories/Python/Python%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"2.Git多平台同步","slug":"Git/Git多平台同步","date":"2020-08-31T08:10:46.000Z","updated":"2025-05-05T06:07:54.189Z","comments":true,"path":"posts/88fead8.html","link":"","permalink":"http://www.a2data.cn/posts/88fead8.html","excerpt":"Git 将一个项目同步到多平台上。","text":"Git 将一个项目同步到多平台上。 Git 同时提交到多平台适用背景： 同一项目同步到多个平台上 Github Gitee 项目实战 以MockData项目为例子。 MockData ： 常规操作我们可以先把项目代码 push 到 gitee上。 1、克隆在Gitee创建好的空项目# 创建一个文件夹 # 再该文件夹下边 使用Git进行如下操作 git clone git@github.com:A2Data/mockdata.git 就会得到如图所示: 2、然后我们可以把本地的项目文件放到该目录下 3、使用git上传该项目到 Gitee上git add. #添加 git commit -m &quot;更新信息&quot; git push # 提交 详细运行过程如下： JackFeng@JackFeng MINGW64 /d/学习/DataDict/mock-data (master) $ ll total 41 drwxr-xr-x 1 JackFeng 197121 0 7月 12 22:09 __pycache__/ -rw-r--r-- 1 JackFeng 197121 746 7月 12 22:07 config_all.conf -rwxr-xr-x 1 JackFeng 197121 8779 6月 28 21:15 FakerData.py* -rwxr-xr-x 1 JackFeng 197121 1848 6月 29 14:21 FunctionClassConfig.py* -rw-r--r-- 1 JackFeng 197121 0 8月 31 14:34 LICENSE -rwxr-xr-x 1 JackFeng 197121 168 7月 12 22:00 main.py* -rwxr-xr-x 1 JackFeng 197121 6644 7月 12 22:49 mock.py* -rw-r--r-- 1 JackFeng 197121 3006 7月 12 21:56 Mock数据使用说明.md drwxr-xr-x 1 JackFeng 197121 0 7月 8 12:26 pools/ -rw-r--r-- 1 JackFeng 197121 1008 8月 31 14:34 README.en.md -rw-r--r-- 1 JackFeng 197121 1227 8月 31 14:38 README.md JackFeng@JackFeng MINGW64 /d/学习/DataDict/mock-data (master) $ git add . JackFeng@JackFeng MINGW64 /d/学习/DataDict/mock-data (master) $ git commit -m &quot;mockdata&quot; [master 8e72f4b] mockdata 16 files changed, 1519 insertions(+) create mode 100644 .idea/inspectionProfiles/profiles_settings.xml create mode 100644 .idea/misc.xml create mode 100644 .idea/mockdata-kath.iml create mode 100644 .idea/modules.xml create mode 100644 .idea/workspace.xml create mode 100644 FakerData.py create mode 100644 FunctionClassConfig.py create mode 100644 &quot;Mock\\346\\225\\260\\346\\215\\256\\344\\275\\277\\347\\224\\250\\350\\257\\264\\346\\230\\216.md&quot; create mode 100644 __pycache__/FakerData.cpython-37.pyc create mode 100644 __pycache__/FunctionClassConfig.cpython-37.pyc create mode 100644 __pycache__/mock.cpython-37.pyc create mode 100644 config_all.conf create mode 100644 main.py create mode 100644 mock.py create mode 100644 pools/majors.csv JackFeng@JackFeng MINGW64 /d/学习/DataDict/mock-data (master) $ git push Enumerating objects: 24, done. Counting objects: 100% (24/24), done. Delta compression using up to 8 threads Compressing objects: 100% (20/20), done. Writing objects: 100% (22/22), 21.43 KiB | 1.19 MiB/s, done. Total 22 (delta 1), reused 0 (delta 0) remote: Powered by GITEE.COM [GNK-5.0] To gitee.com:sqlsq_admin/mock-data.git 562b3ee..8e72f4b master -&gt; master JackFeng@JackFeng MINGW64 /d/学习/DataDict/mock-data (master) 4、查看Gitee提交记录此时发现已经不是空项目了。 Github 创建完成之后的Github项目，也是空项目！ 这边就不演示了。 多平台配置上边只演示 如何项目同步到单个平台，如何同步到多个平台的不同仓库下呢？ Github： &#x67;&#x69;&#116;&#64;&#103;&#x69;&#x74;&#104;&#x75;&#98;&#x2e;&#x63;&#111;&#109;:A2Data/MockData.git Gitee： &#103;&#105;&#x74;&#64;&#103;&#x69;&#116;&#x65;&#101;&#x2e;&#x63;&#111;&#x6d;:sqlsq_admin/mock-data.git 1、通过命令添加# 添加第一个仓库 git remote add origin git@gitee.com:sqlsq_admin/mock-data.git # 默认情况下 就是origin # 添加第二个仓库 git remote set-url --add origin git@github.com:A2Data/MockData.git # 如果还有其他，则可以像添加第二个一样继续添加其他仓库。 # 提交 git push origin --all 2、仓库状态查看git log git status 3、 .git/config , 配置可以看到目前只有一个！也可以直接打开**.git/config** 这个文件进行配置。 git remote set-url --add origin git@github.com:A2Data/MockData.git git remote git remote -v 4、配置方式方法一: 使用 git remote add 命令# 1、本地仓库与远程仓库关联起来，再查看一下远程仓库情况 git remote add origin git@gitee.com:sqlsq_admin/mock-data.git git remote -v # 2、使用如下命令再添加另一个远程仓库 git remote add github git@github.com:A2Data/MockData.git # 3、 再次查看远程仓库的情况，可以看到已经有两个远程仓库了。然后再使用相应的命令 push 到对应的仓库就行了。*这种方法的缺点是每次要* push *两次。* git push origin master:master git push github master:master 方法二: 使用 git remote set-url 命令# 1、删除方法一的 sundyn 远程仓库。 git remote rm mockdata # 2、使用如下命令添加远程仓库。 git remote set-url --add origin git@github.com:A2Data/MockData.git # 3、查看远程仓库情况。可以看到 github 远程仓库有两个 push 地址。*这种方法的好处是每次只需要* push *一次就行了。* git remote -v git push origin master:master 异常配置的方式就是两种，这个异常的原因 是因为github 和gitee 账号不用。key不同链接失效。 解决方案：git push origin master:master -f # 强制推。 后续优化之后，再进行升级。","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://www.a2data.cn/tags/Git/"}]},{"title":"Anaconda镜像","slug":"Python/Anaconda/Anaconda镜像源","date":"2020-08-31T03:23:00.000Z","updated":"2025-05-05T06:09:14.863Z","comments":true,"path":"posts/2b36786b.html","link":"","permalink":"http://www.a2data.cn/posts/2b36786b.html","excerpt":"anaconda 镜像源 。","text":"anaconda 镜像源 。 anaconda下载源1.清华源 CMD输入以下命令： conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/win-64/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/win-64/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2/win-64/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/mro/win-64/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/pro/win-64/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r/win-64/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/numba/label/dev/win-64/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/win-64/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/win-64/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/win-64/ conda config --set show_channel_urls yes &gt; conda config --set show_channel_urls yes &gt; 删除源 &gt; conda config --remove-key $channels 设置搜索时显示通道地址 conda config –set show_channel_urls yes Linux/MAC下 直接修改~/.condaarc文件在”channels”中添加即可 channels: https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ defaultsshow_channel_urls: true","categories":[],"tags":[{"name":"Anaconda","slug":"Anaconda","permalink":"http://www.a2data.cn/tags/Anaconda/"}]},{"title":"Python环境搭建","slug":"Python/Python环境搭建","date":"2020-08-30T08:28:00.000Z","updated":"2021-01-24T13:53:55.342Z","comments":true,"path":"posts/62910.html","link":"","permalink":"http://www.a2data.cn/posts/62910.html","excerpt":"人生苦短，我用Python。","text":"人生苦短，我用Python。 Python 环境搭建Anaconda这是一个支持 Linux, Mac, Windows系统的python发行版本，占空间约600MB。如对空间要求严格的用户，Miniconda是一种选择。 Windows系统 https://www.anaconda.com/distribution/ 首先打开这个网址 本文以作者系统为例， 双击安装文件 Anaconda3-2019.10-Windows-x86_64.exe，进入安装界面，点击 Next。 点击 I Agree，同意 Anaconda 的协议。 一般选择 Just Me，这也是建议安装选项，当然，选 All Users，为电脑上的所有用户安装也未尝不可。选好了以后点击 Next 继续。 在下图显示的界面选择安装目录，建议不要存C盘，这样以后会更多。 默认第一个勾选框是没有选中的，需要自己点选，这个选项说的是把 Anaconda 添加为 PATH 环境参数 。 后边基本没太多需要注意的。Install 安装到如下界面，可以选择安装，也可以跳过。我这里跳过了。 下一步，Finish 到此，安装完成。其实这个安装很简单。一般都会。 Pycharm开发者最爱之一的编译器。诸多便利之处。等待你 细细体会。 这里作者安装的是最新的IDEA 2019.02 这里不说明，具体安装教程。 主要说破解部分。 https://www.jetbrains.com/pycharm/ 下载之后，双击exe文件。正常安装即可。 划重点，安装完成之后我们选择试用，然后进去Pycharm 进行破解 1、下载补丁文件 jetbrains-agent.jar并将它放置到 pycharm安装目录的\\bin目录下（位置可随意，放这里是怕误操作删除了破解文件）。 2、进入项目界面**“Evaluate for free”免费试用，然后再创建一个空项目，这样就可以进入到pycharm的工作页面 3、配置文件 点击Pycharm最上面的菜单栏中的 “Help” -&gt; “Edit Custom VM Options…”**，如果提示是否要创建文件，点“Create”**。 在打开的vmoptions编辑窗口末行添加：**-javaagent:你pycharm的安装目录\\jetbrains-agent.jar** （注：请仔细检查补丁路径是否正确，如果错误则会出现Pycharm打不开的情况，这时候可以删除用户配置目录下的pycharm）windwos：C:\\Users\\用户名\\ 修改完配置文件之后重启Pycharm修改完配置文件之后重启Pycharm修改完配置文件之后重启Pycharm （重要事情说三遍） 4、输入激活码重启pycharm之后，点击菜单栏中的 “Help” -&gt; “Register …”，这里有两种激活方式： 一、选择最后一种License server激活方式，地址填入：http://jetbrains-license-server （应该会自动填上），或者点击按钮：**”Discover Server”** 来自动填充地址，完成激活 二、如果服务器激活方式无法激活，还可以选择Activation code方式激活，复制下面激活码即可 重启Pycharm，选择自动激活，会自动识别网址进行激活。没有出现日期，就说明永久了。（激活码以及激活插件，请在公号内联系小编获取！） 划重点—- 本教程适用于所有idea，不仅限pycharm哦 – 看到就是赚到，转发一波吧！ Python,你好！ 也许会迟到，但绝对不会缺席！ Anaconda print(&quot;Hello world&quot;) 全宇宙最亲近一行代码 没有之一 这里我们通过执行Jupyter notebook ，启动方式有两种！ 1、点击 jupyter botebook 图标运行 2、Win+ R 在命令行中输入 Jupyter notebook 对于小白来说，你可能会遇到这样的问题？ 如图所示 默认进入： 更改工作路径之后的截图 恭喜进入Coding的世界 Pycharm1、使用默认安装的Python 2、 如何更改可以调用anaconda解释器呢？ 添加对应的路径即可。 因为anaconda 集成了很多库，不用再安装了。 注意事项： python需要选择 pythonw.exe Jupyter 高级配置Anaconda 配置 Flie：文件 Edit：编辑 View：视图 Cell： 单元格工具栏 Kernel 更改jupyter notebook工作空间方式1： 不是每次都好使 在其配置文件ipython_notebook_config.py中，有如下一句 # The directorytousefornotebooksandkernels. # c.NotebookApp.notebook_dir = u&#39;&#39; 该句就是用来指定其工作空间的，例如，默认的工作空间是：用户名文件夹，例如，现在想要将工作空间变为D:\\DataScience\\Jupyter，那么，需要做如下更改(要记得删掉注释#) # The directory to use for notebooks and kernels. c.NotebookApp.notebook_dir =u&#39;\\DataScience\\Jupyte&#39; 注意：路径最后一级后面不要加符号“\\” 如何找到该配置文件？ 1.在cmd中输入jupyter notebook –generate-config 如果该配置文件已经存在，那么，会出现如下信息,从中可以见到配置文件存在的位置，注意，此时，输入N，不要overwrite 如果该配置文件不存在，那么，将会初始化产生一个配置文件 在cmd中输入：ipython profile create 2.打开 jupyter_notebook_config.py 文件，找到 ## The directory to use for notebooks and kernels. #c.NotebookApp.notebook_dir = &#39;&#39; 将要指定的路径填入 #c.NotebookApp.notebook_dir = ‘ ‘ 中的 ‘ ‘ 中即可，同时注意将 #c 中的 # 删去，： c.NotebookApp.notebook_dir = &#39;D:\\DataScience\\Jupyte&#39; 3.保存，在命令行中再次输入 jupyter notebook 指令即可在指定的文件夹下启动。 方式2(绝招)： 进入工作目录文件夹 键盘Shift+鼠标右键-&gt;在此处打开命令窗口-&gt; 在弹出的命令窗口中输入：Jupyter Notebook 利用jupyter的cell是可以运行python文件的，即在cell中运行如下代码：%runfile.py 1 file.py为要运行的python程序，结果会显示在该cell中 为Jupyter Notebook添加目录功能利用Anaconda安装Jupyter Notebook extensions conda install -c conda-forge jupyter_contrib_nbextensions Jupyter notebook工具栏隐藏和jupyter notebook主题更改 注：有时候jupyter输出后，需要滚动条才能看全，执行下列命令，修改输出段的字号大小，就不需要滚动条了。 在cmd 命令行执行！！！ #jt -t monokai -f fira -fs 13 -cellw 90% -ofs 11 -dfs 11 -T -N #-f(字体) -fs(字体大小) -cellw(占屏比或宽度) -ofs(输出段的字号) -T(显示工具栏) -N(显示自己主机名) jt -t gruvboxl -f fira -fs 13 -cellw 90% -ofs 11 -dfs 11 -T -N # 主题更改 pip install --upgrade jupyterthemes jt -l jt -t chesterish -T # 主题列表 chesterish grade3 gruvboxd gruvboxl monokai oceans16 onedork solarizedd solarizedl 恢复默认主题,只需执行代码：jt -r，即可恢复至原来的白色背景。 Jupyter Notebook 的快捷键 Jupyter 编辑模式 命令模式 Jupyter Notebook 有两种键盘输入模式。编辑模式，允许你往单元中键入代码或文本；这时的单元框线是绿色的。命令模式，键盘输入运行程序命令；这时的单元框线是灰色。 命令模式 (按键 Esc 开启) Enter : 转入编辑模式 Shift-Enter : 运行本单元，选中下个单元 Ctrl-Enter : 运行本单元 Alt-Enter : 运行本单元，在其下插入新单元 Y : 单元转入代码状态 M :单元转入markdown状态 R : 单元转入raw状态 1 : 设定 1 级标题 2 : 设定 2 级标题 3 : 设定 3 级标题 4 : 设定 4 级标题 5 : 设定 5 级标题 6 : 设定 6 级标题 Up : 选中上方单元 K : 选中上方单元 Down : 选中下方单元 J : 选中下方单元 Shift-K : 扩大选中上方单元 Shift-J : 扩大选中下方单元 A : 在上方插入新单元 B : 在下方插入新单元 X : 剪切选中的单元 C : 复制选中的单元 Shift-V : 粘贴到上方单元 V : 粘贴到下方单元 Z : 恢复删除的最后一个单元 D,D : 删除选中的单元 Shift-M : 合并选中的单元 Ctrl-S : 文件存盘 S : 文件存盘 L : 转换行号 O : 转换输出 Shift-O : 转换输出滚动 Esc : 关闭页面 Q : 关闭页面 H : 显示快捷键帮助 I,I : 中断Notebook内核 0,0 : 重启Notebook内核 Shift : 忽略 Shift-Space : 向上滚动 Space : 向下滚动 编辑模式 ( Enter 键启动) Tab : 代码补全或缩进 Shift-Tab : 提示 Ctrl-] : 缩进 Ctrl-[ : 解除缩进 Ctrl-A : 全选 Ctrl-Z : 复原 Ctrl-Shift-Z : 再做 Ctrl-Y : 再做 Ctrl-Home : 跳到单元开头 Ctrl-Up : 跳到单元开头 Ctrl-End : 跳到单元末尾 Ctrl-Down : 跳到单元末尾 Ctrl-Left : 跳到左边一个字首 Ctrl-Right : 跳到右边一个字首 Ctrl-Backspace : 删除前面一个字 Ctrl-Delete : 删除后面一个字 Esc : 进入命令模式 Ctrl-M : 进入命令模式 Shift-Enter : 运行本单元，选中下一单元 Ctrl-Enter : 运行本单元 Alt-Enter : 运行本单元，在下面插入一单元 Ctrl-Shift– : 分割单元 Ctrl-Shift-Subtract : 分割单元 Ctrl-S : 文件存盘 Shift : 忽略 Up : 光标上移或转入上一单元 Down :光标下移或转入下一单元 Pycharm 常用配置1、Anaconda 和Python环境点击File，选择Settings/Preferences 选择如图： 2、字体大小调整pycharm在安装后，默认的字体很小，为了方便编写代码，都会调的大一些。 调整方式： Windows: File - Settings - Editor - Font Mac: Pycharm - Preferences - Editor - Font 3、常用快捷键 注释(取消注释)选择的行：ctrl + / 2）缩进/取消缩进选择的行： shift + Tab 3）在下方新建行并移到新行行首：Shift + Enter 查看选中函数/类的源码：ctrl + B 更多的快捷键使用可在网上搜索。也可以在pycharm的快捷键说明中查找。 4、设置代码模板在pycharm当中创建某些文件时，可以设置模板。 比如，创建python文件 ，在头部自带 作者/时间/文件名称等信息。 创建unittest文件，生成unittest用例模板。 配置路径： windows: Settings - Editor - File and Code Templates Mac: Preferences - Editor - File and Code Templates Pycharm 如何设置代码作者信息Pycharm 中 File -》Settings -》File and Code Templates》Python Script ### 版本1 # -*- coding: utf-8 -*- &quot;&quot;&quot; ------------------------------------------------- # @Project :$&#123;PROJECT_NAME&#125; # @File :$&#123;NAME&#125; # @Date :$&#123;DATE&#125; $&#123;TIME&#125; # @Author :作者名 # @Email :QQ号 # @Software :$&#123;PRODUCT_NAME&#125; # @Blog : www.a2data.cn ------------------------------------------------- &quot;&quot;&quot; ### 版本2 #!/usr/bin/env python # -*- coding: utf-8 -*- &quot;&quot;&quot; __title__ = &#39;$Package_name&#39; __author__ = &#39;$USER&#39; __mtime__ = &#39;$DATE&#39; ——blog__ = &#39;www.a2data.cn&#39; # 多做多看多想。 I love DataScience！ へ ／| /＼7 ∠＿/ / │ ／ ／ │ Z ＿,＜ ／ /`ヽ │ ヽ / 〉 Y ` / / ｲ● ､ ● ⊂⊃〈 / () へ | ＼〈 &gt;ｰ ､_ ィ │ ／／ / へ / ﾉ＜| ＼＼ ヽ_ﾉ (_／ │／／ 7 |／ ＞―r￣￣`ｰ―＿ ====== Start Succeed ===== &quot;&quot;&quot; 5、文件默认编码File Encodings&gt; IDE Encoding: UTF-8;Project Encoding: UTF-8; 6. 设置缩进符为制表符“Tab” File -&gt; Default Settings -&gt; Code Style -&gt; General -&gt; 勾选“Use tab character” -&gt; Python -&gt; 勾选“Use tab character” -&gt; 其他的语言代码同理设置 7、设置Python自动引入包先在 &gt;general &gt; autoimport -&gt; python :show popup 快捷键：Alt + Enter: 自动添加包 8. 代码自动整理设置原图： 去掉之后： 这里line breaks去掉√，否则bar, 和baz会分开在不同行，不好看。","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"}],"tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://www.a2data.cn/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}]},{"title":"Hexo命令","slug":"Hexo/Hexo","date":"2020-08-01T02:45:51.000Z","updated":"2025-05-05T06:07:54.188Z","comments":true,"path":"posts/47ce27c8.html","link":"","permalink":"http://www.a2data.cn/posts/47ce27c8.html","excerpt":"Hexo 常用基本命令","text":"Hexo 常用基本命令 Hexo语法 Hexo hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo new post --p 文件夹名/文件名 &quot;title&quot; hexo new post --p Hexo/hexo &quot;title&quot; hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server） hexo deploy #部署到GitHub hexo help # 查看帮助 hexo version #查看Hexo的版本 缩写hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy 组合命令hexo s -g #生成并本地预览 hexo d -g #生成并上传 上传插件# 在生成以及部署文章之前，需要安装一个扩展： 如下图 # mac 用户 需要加 `sudo` npm install hexo-deployer-git --save CheckBox 纯文本测试 支持简单的 markdown 语法 支持自定义颜色 绿色 + 默认选中 黄色 + 默认选中 青色 + 默认选中 蓝色 + 默认选中 增加 减少 叉 Radio 纯文本测试 支持简单的 markdown 语法 支持自定义颜色 绿色 黄色 青色 蓝色 密码验证码：这里没有验证码验证码：DataScience","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.a2data.cn/tags/Hexo/"}]},{"title":"1.认识Mysql","slug":"DataBase/Mysql/1、认识Mysql","date":"2020-06-15T16:16:16.000Z","updated":"2025-05-05T05:49:05.828Z","comments":true,"path":"posts/4354b039.html","link":"","permalink":"http://www.a2data.cn/posts/4354b039.html","excerpt":"认识mysql！","text":"认识mysql！ 背景介绍 数据库，就是数据的仓库。它是长期存储在计算机内，有组织、可共享的数据的集合。简而言之，即放置信息的文件柜。 数据库分类 当今互联网中，最常见的数据库模型主要为两种，即关系型数据库（SQL）和非关系型数据库（NoSQL 、Not Only SQL)。 关系型数据库 1、定义：指采用了关系模型来组织数据的数据库，其以行和列的形式存储数据，以便于用户理解，关系型数据库这一系列的行和列被称为表，一组表组成了数据库。 2、特点 （1）存储方式：以行和列的方式组成表格进行存储。 （2）扩展方式：只具备纵向扩展能力。 （3）查询方式：采用结构化查询语言（即SQL）进行查询。 （4）原子性：记录之前的版本，允许回滚。 （5）一致性：事务开始和结束之间的中间状态不会被其他事务看到。 （6）隔离性：适当的破坏一致性来提升性能与并行度。 （7）持久性：每一次的事务提交后就会保证不会丢失。 3、缺点：性能没有非关系型数据库好，一旦想更改存储结构，面对海量数据，操作起来会很复杂。 非关系型数据库 1、定义：数据存储不需要固定的表结构，通常也不存在连接操作。 2、特点 （1）不需要预定义模式：不需要事先定义数据模式，预定义表结构。 （2）无共享架构：相对于将所有数据存储的存储区域网络中的全共享架构。 （3）弹性可扩展：可以在系统运行的时候，动态增加或者删除结点。 （4）分区：相对于将数据存放于同一个节点，NoSQL数据库需要将数据进行分区，将记录分散在多个节点上面。 （5）异步复制：和RAID存储系统不同的是，NoSQL中的复制，往往是基于日志的异步复制。 （6）BASE：相对于事务严格的ACID特性，NoSQL数据库保证的是BASE特性。 3、适用场景 （1）数据模型比较简单。 （2）需要灵活性更强的IT系统。 （3）对数据库性能要求较高。 （4）不需要高度的数据一致性。 （5）对于给定key，比较容易映射复杂值的环境。 数据库管理系统 这又是啥？ 面对不同种类的数据库，如何精准获取数据库中的数据？智慧的人类创造了一个神奇的产品！！！ 数据库管理系统。数据库管理系统是为管理数据库而设计的电脑软件系统，一般具有存储、截取、安全保障、备份等基础功能。 MySQL 江湖地位！ MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。它是最流行的关系型数据库管理系统之一，它也是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。 为啥选 MySQL ? MySQL由于其体积小、速度快、总体拥有成本低，尤其是具有开放源码这一特点，一般中小型网站的开发都选择 MySQL 作为网站数据库。 MAC安装MYSQL：下载安装包：点击链接下载MYSQL安装包： https://dev.mysql.com/downloads/mysql/ 终端输入mysql,发现提示command not found，需要先设置环境路径； 终端输入*/user/local/mysql/bin*，查看mysql是否安装成功： 在终端加入环境路径：如果是bash,执行open ~/.bash_profile；如果是zsh,执行open ~/.zshrc； 在bash_profile或zshrc文件中添加语句PATH=$PATH:/usr/local/mysql/bin,并保存； 将更改立即生效：终端输入source ~/.bash_profile 或 source ~/.zshrc 注：如果没有zshrc文件，需要先创建空白文件，再将bash_profile的内容复制粘贴过来，包括上述语句，最后输入上述语句使修改生效 登录和退出MYSQL：登陆：终端输入mysql -uroot -p，输入密码 -u后是用户名，-p后是密码（如不是登陆本机的MYSQL，还有 -h后面加服务器主机地址）。 退出MYSQL：终端输入\\q; 或 quit; 或 exit;","categories":[],"tags":[]},{"title":"4.数据库操作-DCL","slug":"DataBase/Mysql/4、数据库操作-DCL","date":"2020-06-15T16:16:16.000Z","updated":"2025-05-05T05:49:05.834Z","comments":true,"path":"posts/f8d580eb.html","link":"","permalink":"http://www.a2data.cn/posts/f8d580eb.html","excerpt":"数据库操作DCL","text":"数据库操作DCL DCL DCL（Data Control Language），数据库控制语言。 主要用途：对数据库访问权限进行控制的指令。 操纵命令：GRANT、REVOKE GRANT：对用户进行赋权。 REVOKE：对用户权限进行回收。 用户管理MYSQL8.0后版本不支持grant语句直接创建用户，因此需要先创建用户，再进行赋权。 创建用户CREATE USER &#39;username&#39;@&#39;hostname&#39; IDENTIFIED BY &#39;密码&#39;; 案例： create user &#39;csg1&#39; identified by &#39;123&#39;; 用Create创建的用户仅有系统默认权限usage，无其他权限。 删除用户DROP USER &#39;username&#39;@&#39;hostname&#39;; 案例： drop user csg1; 权限管理赋权GRANT priviledge_name[(list_name1,list?_name2)] ON dbname.table_name FROM &#39;username&#39;@&#39;hostname&#39;; 案例： 对账号&#39;csg1&#39;添加数据库&#39;mysqlpractice&#39;所有表的&#39;select&#39;权限。 grant select on mysqlpractice.* to csg1; 案例： 对全库全表赋权所有权限。 grant all on *.* to dba@localhost; 查看权限查看指定账号权限： SHOW GRANTS FOR &#39;username&#39;@&#39;hostname&#39;; 查看当前用户自身权限： SHOW GRANTS; 回收权限REVOKE priviledge_name[(list_name1,list?_name2)] FROM dbname.table_name FROM &#39;username&#39;@&#39;hostname&#39;; 案例： revoke select on mysqlpractice.* from csg1;","categories":[],"tags":[]},{"title":"3.数据库操作-DML","slug":"DataBase/Mysql/3、数据库操作-DML","date":"2020-06-15T16:16:16.000Z","updated":"2025-05-05T05:49:05.831Z","comments":true,"path":"posts/6656ad65.html","link":"","permalink":"http://www.a2data.cn/posts/6656ad65.html","excerpt":"数据库操作DML","text":"数据库操作DML DML DML（Data Manipulation Language），是通过对表中数据的插入、删除和修改等操作，实现对数据库的基本操作。 主要用途：对数据表进行数据插入、删除、修改、排序或检索操作。 操纵命令：INSERT、UPDATE、DELETE INSERT：把数据插入到数据表中。 UPDATE：修改数据记录。 DELETE：删除数据库中不必再继续保留的记录。 1、插入数据形式一INSERT INTO TABLE_NAME (字段名1,字段名2,.....) VALUES(数值1,数值2,....); 案例： INSERT INTO user(user_id,user_name,age,remove,tel,sex) VALUES(001,&quot;A2Data&quot;,22,0,18511990011,0); 形式二INSERT INTO TABLE_NAME SET 字段名1 = 数值1, 字段名2 = 数值2,....; 案例： INSERT INTO user SET user_id=001,user_name=&quot;A2Data&quot;,age=22,remove=0,tel=18511990011,sex=0; 2、修改数据UPDATE TABLE_NAME SET 字段名1 = 新数值1,字段名2 = 新数值2; 案例： UPDATE USER SET age = 25 , sex = 1; 3、解决重复记录的更新使用on duplicate key update可以解决插入或更改重复主键，即当insert内容和原表内容存在重复记录时，执行update操作。 INSERT INTO table_name1 SELECT * FROM table_name2 ON DUPLICATE KEY UPDATE column_name = VALUES(column_name); 注意：在使用on duplicate key update时，表中必须要存在至少一个unique key或者primary key。 案例：现有表v1和v2如下： v1表与v2表同时存在id为005的行，且name字段值不一致。 我们使用on duplicate key update对v1表插入v2内容： insert into v1 select name,tel,remove from v2 on duplicate key update name = values(name); 查看执行后的v1表内容，可以看到id为005的记录，其name字段值已修改为v2的相应记录： 4、删除数据方法一：DELETEDELETE FROM TABLE_NAME [WHERE 子句] 如不加WHERE子句则表中数据全部删除 案例： DELETE FROM user; 方法二：TRUNCATETRUNCATE优势：作为DDL语句，比DELETE运行速度更快，且使用资源更少 TRUNCATE TABLE TABLE_NAME 案例： TRUNCATE TABLE user; 5、数据库查询5.1、基本查询语句SELECT column_name FROM table_name WHERE 条件语句 [LIMIT 限制行数] WHERE限制条件一览表： 限制条件类别 对应标识 备注 比较 &gt;、&lt;、=、&gt;=、&lt;=、&lt;&gt; 集合 in、not in 无法获取null值 指定范围 between and 使用时需注意其结果包含边界值 空值判断 is null、is not null 且 and 或 or 案例： SELECT user_id,user_name FROM user WHERE age &gt; 20 and tel IS NOT NULL LIMIT 10; 别名 column_name AS 别名 table_name AS 别名 *注:*WHERE子句中不可使用别名 GROUP BY：用于对查询结果进行数据分组 HAVING：用于对分组后的结果进行统计，其后可以跟聚合函数 案例： user表记录了用户所在部门user_dept，筛选出部门平均年龄大于25的结果。 SELECT user_dept,AVG(age) as &#39;年龄&#39; FROM `user` GROUP BY user_dept HAVING AVG(age)&gt;25; HAVING语句用于对分组后的结果进行统计 ORDER BY：对查询结果进行排序,默认为ASC升序，DESC为降序 案例： SELECT user_id,user_name FROM `user` ORDER BY user_name ; DISTINCT：取消重复的结果 案例： SELECT DISTINCT user_dept FROM `user`; 5.2、模糊查询LIKESELECT column_name FROM table_name WHERE column_name LIKE 模式字符串 通配符 含义 % 匹配任意长度（0或多个）字符串，不能匹配空值 _ 匹配任意单个字符串，_表示1个长度 案例： 查询user表中所有姓名为A开头的人员信息。 SELECT * FROM user WHERE user_name like &#39;A%&#39;; RLIKE、REGEXP这两个主要用于在MYSQL中进行正则表达式的书写。 SELECT column_name FROM table_name WHERE column_name REGEXP/RLIKE 模式字符串; 通配符 含义 . 匹配任意单个字符 * 匹配0个或多个前一个得到的字符 ^ 匹配开头，如^s匹配以s或者S开头的字符串。 $ 匹配结尾，如s$匹配以s结尾的字符串。 {n} 匹配前一个字符反复n次。 ｜ 多个条件间的“或”连接 案例： 查询user表中姓名存在字段bb的人员。 select * from user where user_name regexp &#39;b&#123;2&#125;&#39;; 查询user表中姓名为n结尾的人员。 select * from user where user_name rlike &#39;n$&#39;; 查询user表中姓名存在an字段的人员。 select * from user where user_name rlike &#39;an&#39;; 5.3、存储过程存储过程基本结构构造存储过程： CREATE PROCEDURE 存储体名称(IN/OUT 参数名 参数类型) BEGIN 存储内容 END; 调用存储过程： CALL 存储体名称(参数) 终端运行存储过程案例： 构造存储体u1，筛选所有部门为R&amp;D的员工。 首先将MYSQL默认结束符进行修改： DELIMITER // 构造存储过程： CREATE PROCEDURE U1() BEGIN SELECT * FROM user WHERE user_dept = &#39;R&amp;D&#39;; END // 调用存储体： CALL u1()// 5.4、多表查询内连接SELECT * FROM TABLE_A INNER JOIN TABLE_B ON TABLE_A.COLUMN 比较运算符 TABLE_B.COLUMN; 内连接用于比较并返回满足连接条件的数据行，结果取交集。 inner join示意图： 注意：如果两边的表行数不一致，可能会出现丢失数据。 外连接SELECT * FROM TABLE_A LEFT|RIGHT|FULL JOIN TABLE_B ON TABLE_A.COLUMN 比较运算符 TABLE_B.COLUMN; 外连接的两个表有主从之分，主表全部保存，从表适配保存。 full outer join示意图： left/right outer join示意图： 6、锁表锁表； LOCK TABLES table_name LOCK_TYPE 解锁： UNLOCK TABLES; Lock_type包含read和write等。 锁为read类型的表，可读但不可写；其他会话对该表可读，但写入需要等到解锁后： 锁为write类型的表，可读也可写；但其他会话对该表的读或写需要等到解锁以后： 7、MYSQL慢查询：EXPLAINexplain语句用于分析MYSQL的查询性能，可以显示MySQL如何使用索引等来处理select语句以及连接表。 用explain查看查询是否使用索引： EXPLAIN SELECT * FROM table_name WHERE 查询条件； 案例： 对表Sheet1建立索引i1后，用explain查看任意查询情况： explain select * from Sheet1 where number = 1601; explain查询结果type为ref，即使用了索引查询，而非全表遍历查询all；所使用的索引(possible keys/key)为i1：","categories":[],"tags":[]},{"title":"2.数据库操作-DDL","slug":"DataBase/Mysql/2、数据库操作-DDL","date":"2020-06-15T16:16:16.000Z","updated":"2025-05-05T05:49:05.832Z","comments":true,"path":"posts/b794162c.html","link":"","permalink":"http://www.a2data.cn/posts/b794162c.html","excerpt":"数据库操作DDL","text":"数据库操作DDL DDL DDL（Data Definition Language）是连接存储世界与现实世界的高铁！ 主要用途： 对数据库对象进行创建、修改、删除等操作。 操作对象： 数据库、数据表、列、索引等。 定义命令： CREATE：创建数据库或表的命令。 DROP：删除已建数据库或表。 ALTER： 添加、修改或删除列，更新表名，字段类型等。 数据库操作1、创建数据库 -- IF NOT EXISTS --- 不存在则创建，存在则不创建 CREATE DATABASE IF NOT EXISTS DataScience; 2、删除数据库1、查看所有数据库 SHOW DATABASES; 2、删除指定数据库 DROP DATABASE IF EXISTS DataScience; 3、修改数据库字符集1、查看数据库字符集 SHOW VARIABLES LIKE&#39;character_set_database&#39;; 2、修改数据库字符集 ALTER DATABASE DataScience character SET &#39;gbk&#39;; 4、进入数据库USE DataSciecne; mysql&gt; use -&gt; datascience; Query OK, 0 rows affected (0.00 sec) 数据表操作1、创建表语法 CREATE TABLE tab_name( column_name1 type[len], column_name2 type[len], ...... column_nameN type[len]) PRIMARY KEY (`id`) [ ENGINE=InnoDB #存储引擎 DEFAULT CHARSET=utf8]; #字符集 创建用户表 CREATE TABLE FansUser( user_id int not null comment &#39;用户ID&#39;, user_name varchar(30) not null comment &#39;名称&#39;, age int, tel int not null comment &#39;电话&#39;, sex bit default 1 ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 2、删除表 1、查看目前所有数据表 SHOW TABLES; 2、删除指定数据表 DROP TABLE IF EXISTS FansUser; 3、修改表3.0、表名 alter table FansUser rename FansUser1; --修改表名 ALTER TABLE FansUser RENAME User; || ALTER TABLE User RENAME To FansUser; 3.1、列名 ALTER TABLE FansUser CHANGE COLUMN old_column_name new_column_name varchar(30);--修改表列名 ALTER TABLE User change COLUMN sex status bit(1); 3.2、列的类型和约束 alter table User modify status char(10) --修改表列类型 alter table User change status sex bit(1) -- 修改类型及列名 3.3、新增列 注意：添加新列如无特殊约束条件，则默认添加到最后一列；如果添加到指定位置，则需要注意约束条件的正确使用。 FIRST 表示添加到列表的第一列 AFTER 表示添加到某个列之后 -- 指定位置 ALTER TABLE user ADD COLUMN remove bit(1) AFTER age; -- 默认添加 alter table user add column name1 varchar(10); --添加表列 3.4、删除列 ALTER TABLE user DROP column_name1; 4、复制表 user 表存在，user1 不存在。 4.0、结构 -- 要复制的表 在后边。 # like 只是复制表结构 CREATE TABLE user1 LIKE user; || -- 通过关键字as create table user1 as select * from user limit 0; || create table user1 select * from user limit 0; 4.1、数据及内容 --通过关键字as通过复制另一张表的表结构和数据创建新表 create table user1 as select * from user; 4.2、部分数据 # 根据条件创建表，并且将查询出来得数，存入表中 create table user1 as selecet * from user where age&lt;25; 4.3、部分字段 # 查询部分字段数据 create table user1 as select age,name form user; 索引索引相当于数据表的目录，其优点是可以提高检索数据的速度，但同时也增加了系统维护工作，以及会减慢写入速度。 索引不适用场景 数据较少的表或列 查询频率较低的列 数据类型为 TEXT 、IMAGE、BIT 的数据 字段经常性修改 不常出现在 WHERE 子句及排序的字段 索引选取类型 占用空间较少的数据型优选 简单的整型数据优于字符型 避开存在 NULL 以及 NOT NULL的字段 索引选取字段 数据表的主键、外键 常与其他数据表进行连接的字段 常出现在 WHERE 子句中的字段 常用于排序的字段 1、创建索引方法一：在创建表时创建索引 CREATE TABLE table_name column_name1 type[len], column_name2 type[len], ...... column_nameN type[len]) [UNIQUE/FULLTEXT/SPATIAL] INDEX [index_name](column_name[(length)]) 方法二：在已存在的表中创建索引 CREATE [UNIQUE/FULLTEXT/SPATIAL] INDEX index_name ON table_name(column_name[(length)]) 关于length参数：如果是 CHAR，VARCHAR 类型，length 可以小于字段实际长度；如果是 BLOB 和 TEXT 类型，必须指定length。 2、查看索引&amp;删除索引索引不能修改，想更改索引只能删除后重新创建。 查看： SHOW INDEX FROM table_name; 删除： DROP INDEX index_name ON table_name;","categories":[],"tags":[]},{"title":"5.数据库操作-TCL","slug":"DataBase/Mysql/5、数据库操作-TCL","date":"2020-06-15T16:16:16.000Z","updated":"2025-05-05T05:49:10.859Z","comments":true,"path":"posts/e4f3239b.html","link":"","permalink":"http://www.a2data.cn/posts/e4f3239b.html","excerpt":"数据库操作TCL","text":"数据库操作TCL TCL TCL（Transaction Control Language），事务控制语言。 主要用途：对数据库进行事务控制的指令。 操纵命令：COMMIT、ROLLBACK、SAVEPOINT、SET TRANSACTION COMMIT：提交事务。 ROLLBACK：回滚操作。 SAVEPOINT：设置保存点。 SET TRANSACTION：改变事务选项。 1、什么是事务？事务是数据库操作的逻辑单元，包含一系列数据操作，是一个不可分割的整体。 事务的特性——ACID： 原子性(Atomicity)，其包含的所有数据库操作指令要么都执行，如有执行失败会回滚为全都不执行。 一致性(Consistency)，执行前后的数据库有效性是一致的。 隔离性(lsolation)，一个事务不受其他事务的干扰，在多用户并发访问时相互不受干扰。 持久性(Durability)，一旦提交了事务，数据的改变永久保存本地。 2、事务的提交：COMMIT事务的执行内容只有使用commit进行提交后，其中的修改操作才可以成为永久性操作。 先转换MYSQL结束符： DELIMITER // 事务结构： START TRANSACTION｜BEGIN: 查询主体; COMMIT; // 案例： 对user表进行如下事务操作： 1. 姓名为Olivia的人员年龄修改为40 2. 插入新记录user_id为018的男性在职人员Ian，年龄23，电话13173629832，部门为CS 3. 删除原表中user_id为017的记录 4. 查询上述修改结果 start transaction; update user set age = &#39;40&#39; where user_name = &#39;Olivia&#39;; insert user values(&#39;018&#39;,&#39;Ian&#39;,&#39;23&#39;,&#39;0&#39;,&#39;13173629832&#39;,&#39;0&#39;,&#39;CS&#39;); delete from user where user_id = &#39;017&#39;; select * from user where user_dept = &#39;CS&#39; or user_name = &#39;Olivia&#39;; commit; // 我们先查询事务执行前的相关表内容： 执行事务： 3、事务的自动提交：AUTOCOMMITautocommit参数记录了数据库是否为自动提交模式，默认状态为on： 案例： 对user表中user_id为018的人员修改姓名为Peter，年龄为50。 我们开启两个终端，并仅将终端一的autocommit参数修改为OFF： set autocommit = 0// 在终端一进行姓名的修改操作，不执行commit。 我们可以在终端一中查询到修改后的记录： 而在终端二中，则姓名字段为修改前的记录： 若此时在终端二对user表进行年龄的修改操作，会因为正在进行的事务而报错： 将终端一中的事务提交后，我们完成终端二中的修改并查询结果： 4、事务的回滚：ROLLBACK事务在没有使用commit提交时，使用rollback可以将数据库恢复到事务提交前的状态。 案例： 对user表user_id为016的人员remove信息进行修改，并进行回滚操作。 修改前我们查询该条记录如下： 执行事务后并回滚，可以看到数据修改成功后又回滚到修改前状态： 5、设置保存点：SAVEPOINT在事务中设置savepoint，可以将事务回滚到savepoint前。 设置保存点： SAVEPOINT savepoint_name; 回滚到保存点： ROLLBACK TO SAVEPOINT savepoint_name; 解除保存点： RELEASE SAVEPOINT savepoint_name; 案例： start transaction; update user set remove = 1 where user_id = &#39;016&#39;; savepoint s1; delete from user where user_id = &#39;016&#39;; rollback to savepoint s1; release savepoint s1; // 6、事物隔离级别：SET TRANSACTION事务的隔离级别可用于防止事务的并发性问题。 事务有如下隔离级别： ​ read uncommitted 读未提交，该模式会出现脏读 ​ read committed 读已提交，该模式不支持重复读 ​ repeatable read 可重复读，也是MYSQL中默认隔离级别 ​ serializable 串行化，不允许读写并发操作 6.1、查看当前的事务隔离级别：SHOW VARIABLES LIKE &#39;TRANSACTION ISOLATION&#39;; 6.2、修改事务隔离级别：SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL READ 新的事务隔离级别; global：设置全局默认隔离级别 session：设置本次会话隔离级别 如果二者均不写：仅设置本次事务命令的隔离级别，下一个事务将回到默认隔离级别 案例：将当前会话的隔离级别修改为read committed。 set session transaction isolation level read committed; 当前会话隔离级别已更改为read committed： 新开终端再次查询隔离级别，其又回到了默认值repeatable read：","categories":[],"tags":[]},{"title":"Anaconda闪退","slug":"Python/Anaconda/Anaconda闪退","date":"2020-05-13T02:00:30.000Z","updated":"2025-05-05T06:09:14.861Z","comments":true,"path":"posts/4136.html","link":"","permalink":"http://www.a2data.cn/posts/4136.html","excerpt":"anaconda Windows闪退解决方案 。","text":"anaconda Windows闪退解决方案 。 anaconda 打开闪退 记录windwos 系统下 anaconda 打开闪退修复方式。 解决方式 1、 管理员模式运行 conda prompt 2、执行命令conda update anaconda-navigator # 片刻之后 会遇到如下 输入y 即可 3、 重启服务执行anaconda-navigator –reset anaconda-navigator --reset 4、更新客户端执行conda update anaconda-client conda update anaconda-client conda update -f anaconda-client 5、 启动运行 以管理员身份运行 anaconda","categories":[],"tags":[{"name":"Anaconda","slug":"Anaconda","permalink":"http://www.a2data.cn/tags/Anaconda/"}]},{"title":"Java 集合体系","slug":"Java/JavaSE/Java-集合体系","date":"2020-05-07T15:56:08.000Z","updated":"2025-05-05T06:09:14.857Z","comments":true,"path":"posts/9618.html","link":"","permalink":"http://www.a2data.cn/posts/9618.html","excerpt":"Java集合体系","text":"Java集合体系 1、集合体系0、Collection 集合的体系结构： ​ 有不同的数据结构(数据的组织，存储方式) 学习方式： 最顶层 实现： 最底层 Collection—-&gt; List—&gt; ArrayList 常用： add 添加 clear 清空 contains 是否包含指定元素 isEmpty 是否为空 remove 删除 size 返回集合中的元素个数 toArray 返回包含此集合中所有元素的数组。(遍历数组即可) Modifier and Type Method and Description boolean add(E e) 确保此集合包含指定的元素（可选操作）。 boolean addAll(Collection c) 将指定集合中的所有元素添加到这个集合（可选操作）。 void clear() 从这个集合中移除所有的元素（可选操作）。 boolean contains(Object o) 返回 true如果集合包含指定元素。 boolean containsAll(Collection c) 返回 true如果这个集合包含指定集合的所有元素。 boolean equals(Object o) 将指定的对象与此集合进行比较，以进行相等性。 int hashCode() 返回此集合的哈希代码值。 boolean isEmpty() 返回 true如果集合不包含任何元素。 Iterator iterator() 返回此集合中的元素的迭代器。 default Stream parallelStream() 返回一个可能并行 Stream与集合的来源。 boolean remove(Object o) 从这个集合中移除指定元素的一个实例，如果它是存在的（可选操作）。 boolean removeAll(Collection c) 删除此集合中包含的所有元素（可选操作）的所有元素（可选操作）。 default boolean removeIf(Predicate filter) 删除满足给定谓词的这个集合的所有元素。 boolean retainAll(Collection c) 仅保留包含在指定集合中的这个集合中的元素（可选操作）。 int size() 返回此集合中的元素的数目。 default Spliterator spliterator() 创建此集合中的元素的 Spliterator。 default Stream stream() 返回一个序列 Stream与集合的来源。 Object[] toArray() 返回包含此集合中所有元素的数组。 T[] toArray(T[] a) 返回包含此集合中所有元素的数组；返回数组的运行时类型是指定的数组的运行时类型。 1、Iterator 集合的遍历方式： 1、toArray(),可以把集合转换成数组,然后遍历数组即可 【有序】 2、iterator(),返回迭代器对象，可以通过迭代器对象来迭代集合 next() : 返回下一个元素。 hasNext() : 判断是否有元素可以获取 注意： 迭代器是依赖于集合的，相当于集合的一个副本,但迭代器在操作的时候，如果发现和集合不一样，则抛出异常。 Exception in thread “main ” java.util.ConcurrentModificationExeption 解决方案： 使用迭代器遍历时，用迭代器本身修改。 List.listIterator() package learn; import java.util.ArrayList; import java.util.Collection; import java.util.Iterator; /** * * @author JackFeng * @date 2020/3/25 */ public class IteratorDemo &#123; public static void main(String[] args) &#123; // method(); // 创建集合对象 Collection c = new ArrayList(); //添加元素 c.add(&quot;hello&quot;); c.add(&quot;2020&quot;); c.add(&quot;你好啊&quot;); //获取数组 使用迭代器 Iterator it = c.iterator(); while (it.hasNext())&#123; System.out.println(it.next()); &#125; &#125; private static void method() &#123; //快捷键：CTRL + ALT + M 将代码封装成方法 // 创建集合对象 Collection c = new ArrayList(); //添加元素 c.add(&quot;hello&quot;); c.add(&quot;2020&quot;); c.add(&quot;你好啊&quot;); //获取数组 Object[] objects = c.toArray(); // 遍历数组 for (int i = 0; i &lt;objects.length ; i++) &#123; System.out.println(objects[i]); &#125; &#125; &#125; 2、迭代并发修改 判断集合中是否有 “hello ” 如果有，则添加元素 “wolrd” 异常： Exception in thread &quot;main&quot; java.util.ConcurrentModificationException package learn; import java.util.*; /** * * @author JackFeng * @date 2020/3/25 */ public class ListIteratorDemo &#123; public static void main(String[] args) &#123; // mothod(); //创建集合对象 // Collection c = new ArrayList(); List c = new ArrayList(); // 添加元素 c.add(&quot;hello&quot;); c.add(&quot;2020您好&quot;); //迭代器遍历 /* Iterator it = c.iterator(); while (it.hasNext())&#123; String s = (String) it.next(); if (s.equals(&quot;hello&quot;)) &#123; c.add(&quot;world&quot;); &#125; &#125;*/ ListIterator lit = c.listIterator(); while (lit.hasNext()) &#123; String s = (String) lit.next(); if (s.equals(&quot;hello&quot;)) &#123; // 注意 使用迭代器添加，不可使用集合添加，迭代器就会同步集合 lit.add(&quot;world&quot;); &#125; &#125; System.out.println(c); &#125; private static void mothod() &#123; //创建集合对象 Collection c = new ArrayList(); // 添加元素 c.add(&quot;hello&quot;); c.add(&quot;2020您好&quot;); if (c.contains(&quot;hello&quot;))&#123; c.add(&quot;world&quot;); &#125; System.out.println(c); &#125; &#125; 3、泛型 泛型：是一种广泛的类型 优点： 避免类型转换的问题 减少黄色警告线 简化代码书写 什么情况使用泛型—— ** ** package learn; import java.util.ArrayList; import java.util.Collection; import java.util.Iterator; /** * * @author JackFeng * @date 2020/3/25 */ public class GenericDemo &#123; public static void main(String[] args) &#123; // 创建集合对象 // Collection c = new ArrayList(); Collection&lt;Student&gt; c = new ArrayList&lt;Student&gt;(); //创建元素对象 Student s = new Student(&quot;Jack&quot;, 22); Student s1 = new Student(&quot;Jack1&quot;, 25); // 添加元素 c.add(s); c.add(s1); //遍历集合对象 // Iterator ir = c.iterator(); Iterator&lt;Student&gt; ir = c.iterator(); while (ir.hasNext()) &#123; // 转换出错 // Exception in thread &quot;main&quot; java.lang.ClassCastException: learn.Student cannot be cast to java.lang.String // String str = (String) ir.next(); // System.out.println(str); Student stu = ir.next(); System.out.println(stu.name); &#125; &#125; &#125; class Student&#123; String name; int age; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; &#125; 4、foreache 增强for循环，一般用于遍历集合或者数组 格式： for（元素的类型 变量： 集合或者数组对象) { 可以使用变量； } package learn; import java.util.ArrayList; import java.util.Collection; /** * * @author JackFeng * @date 2020/3/25 */ public class ForEachDemo &#123; public static void main(String[] args) &#123; //创建集合对象 // Collection c = new ArrayList(); Collection&lt;String&gt; c = new ArrayList&lt;String&gt;(); //添加集合元素 c.add(&quot;hello&quot;); c.add(&quot;20200325&quot;); //增强for循环 /* for (Object obj:c ) &#123; System.out.println(obj); &#125;*/ for (String string:c ) &#123; // 在增强for循环中不可修改集合 否则会出现 并发修改错误 // c.add(&quot;123&quot;); System.out.println(string.toUpperCase()); &#125; &#125; &#125; 2、数据结构0、数组 数组： int [] arr = { 11,12,13,14}; 查找快，增删慢 1、链表 链表： 由链子连接起来的一堆结点 结点： 地址值，值，下一个结点地址值 获取x结点 方式： 遍历查找 x结点的后边添加新的结点： x结点的下一个结点地址值修改为新的地址值，把新结点的下一个地址值改为 x+1 查询慢，增删快 2、栈&amp;队列 栈：先进后出 堆：先进先出 3、集合List 序列： 指哪插哪 特点： 有序（存储和读取顺序一样） 整数索引 允许重复的 功能： 增 add(int index, E element) —– 在指定索引位置添加指定元素 删 remove(int index) —– 删除指定元素并返回 改 set(int index, E element) —- 将指定索引位置的元素替换为指定元素，并将原来的元素返回。 查 get(int index) —– 根据索引返回元素(防止越界(不存在)) 常用子类 ArrayList： 底层是数组结构，查询快，增删慢 LinkedList: 底层结构是链表，查询慢，增删快 常用 void addLast getFirst getLast removeFirst removeLast Modifier and Type Method and Description boolean add(E e) 将指定的元素列表的结束。 void add(int index, E element) 在列表中指定的位置上插入指定的元素。 boolean addAll(Collection c) 追加指定集合的所有元素到这个列表的末尾，按他们的指定集合的迭代器返回。 boolean addAll(int index, Collection c) 将指定集合中的所有元素插入到该列表中，从指定位置开始。 void addFirst(E e) 在此列表的开始处插入指定的元素。 void addLast(E e) 将指定的元素列表的结束。 void clear() 从这个列表中移除所有的元素。 Object clone() 返回该 LinkedList浅拷贝。 boolean contains(Object o) 返回 true如果这个列表包含指定元素。 Iterator descendingIterator() 返回在反向顺序在deque容器元素的迭代器。 E element() 检索，但不删除，此列表的头（第一个元素）。 E get(int index) 返回此列表中指定位置的元素。 E getFirst() 返回此列表中的第一个元素。 E getLast() 返回此列表中的最后一个元素。 int indexOf(Object o) 返回此列表中指定元素的第一个出现的索引，或-如果此列表不包含元素，或- 1。 int lastIndexOf(Object o) 返回此列表中指定元素的最后一个发生的索引，或-如果此列表不包含元素，或- 1。 ListIterator listIterator(int index) 返回此列表中元素的列表迭代器（在适当的顺序），从列表中的指定位置开始。 boolean offer(E e) 将指定的元素添加到列表的尾部（最后一个元素）。 boolean offerFirst(E e) 在列表的前面插入指定的元素。 boolean offerLast(E e) 在列表的结尾插入指定的元素。 E peek() 检索，但不删除，此列表的头（第一个元素）。 E peekFirst() 检索，但不删除该列表的第一个元素，或返回 null如果这个列表是空的。 E peekLast() 检索，但不删除该列表的最后一个元素，或返回 null如果这个列表是空的。 E poll() 检索并删除此列表的头（第一个元素）。 E pollFirst() 检索并移除此列表的第一个元素，或返回 null如果这个列表是空的。 E pollLast() 检索并移除此列表的最后一个元素，或返回 null如果这个列表是空的。 E pop() 从这个列表所表示的堆栈中弹出一个元素。 void push(E e) 将一个元素推到由该列表所表示的堆栈上。 E remove() 检索并删除此列表的头（第一个元素）。 E remove(int index) 移除此列表中指定位置的元素。 boolean remove(Object o) 从该列表中移除指定元素的第一个发生，如果它是存在的。 E removeFirst() 移除并返回此列表中的第一个元素。 boolean removeFirstOccurrence(Object o) 删除此列表中指定元素的第一个出现（当遍历从头到尾的列表）。 E removeLast() 移除并返回此列表中的最后一个元素。 boolean removeLastOccurrence(Object o) 删除此列表中指定元素的最后一次（当遍历从头到尾的列表时）。 E set(int index, E element) 用指定元素替换此列表中指定位置的元素。 int size() 返回此列表中元素的数目。 Spliterator spliterator() 创建一个后期绑定和快速失败 Spliterator超过此列表中的元素。 Object[] toArray() 返回一个数组，包含在这个列表中的所有元素在适当的顺序（从第一个到最后一个元素）。 T[] toArray(T[] a) 返回一个数组，包含在这个列表中的所有元素在适当的顺序（从第一到最后一个元素）；返回数组的运行时类型是指定的数组的运行时类型。 package learn; import java.util.ArrayList; import java.util.List; /** * * @author JackFeng * @date 2020/3/26 */ /* * 定义一个方法，返回指定列表中指定元素的索引位置 * * * 升级 * */ public class ListedListDemo &#123; public static void main(String[] args) &#123; List list = new ArrayList(); list.add(&quot;hello&quot;); list.add(&quot;A2Data&quot;); list.add(&quot;scala&quot;); int index = index(list, &quot;python&quot;); System.out.println(index); boolean flag = contains(list, &quot;scala&quot;); System.out.println(flag); boolean flag1 = list.contains(&quot;java&quot;); System.out.println(flag1); &#125; public static int index(List list, Object object) &#123; // 索引遍历方式 for (int i = 0; i &lt;list.size() ; i++) &#123; // 获取列表中的元素 Object o = list.get(i); // 判断列表中的元素和指定元素是否相等 // 如果使用 == 是拿地址值去比较的 if (o.equals(object))&#123; return i; &#125; &#125; // 查找不到指定元素 return -1; &#125; public static boolean contains(List list, Object o) &#123; // 获取指定元素在指定列表中的索引位置 int index = index(list, o); // 判断是否村子 if (index &gt;= 0) &#123; return true; &#125; else &#123; return false; &#125; &#125; &#125; 4、集合Set 特点： 无序（存储和读取顺序有可能不一样） 不允许重复（要求元素唯一） 没有索引 HashSet的add() 方法流程： 首先会使用当前集合中的每一个元素和新添加的元素进行hash值比较 如果hash值不同，则直接添加新的元素 如果hash值相同，比较地址值，或使用 equals方法进行比较 比较结果一样，则认为是重复不添加 所有结果都不一样则添加 package learn; import java.util.HashSet; import java.util.Iterator; /** * Created by JackFeng on 2020/3/26. */ /* *使用HashSet存储字符串 并且遍历 * * */ public class HashSetDemo &#123; public static void main(String[] args) &#123; // 创建集合对象 // HashSet&lt;String&gt; hs = new HashSet&lt;&gt;(); HashSet&lt;String&gt; set = new HashSet&lt;&gt;(); //添加元素对象 set.add(&quot;hello&quot;); set.add(&quot;2020&quot;); set.add(&quot;您好啊&quot;); //遍历集合 // mothod(set); // method1(set); // method2(set); &#125; private static void method2(HashSet&lt;String&gt; set) &#123; //增强for for (String s:set ) &#123; System.out.println(s); &#125; &#125; private static void method1(HashSet&lt;String&gt; set) &#123; //迭代器 Iterator&lt;String&gt; it = set.iterator(); while (it.hasNext()) &#123; String s = it.next(); System.out.println(s); &#125; &#125; private static void mothod(HashSet&lt;String&gt; set) &#123; //数组 Object[] objects = set.toArray(); for (int i = 0; i &lt;objects.length ; i++) &#123; System.out.println(objects[i]); &#125; &#125; &#125; HashSet方法优化package learn; import java.util.HashSet; import java.util.Objects; /** * * @author JackFeng * @date 2020/3/26 */ public class HashSetDemoTo &#123; public static void main(String[] args) &#123; //创建集合对象 HashSet&lt;Students&gt; hs = new HashSet&lt;Students&gt;(); //创建元素对象 Students s = new Students(&quot;JackFeng&quot;, 22); Students s1 = new Students(&quot;JackFeng&quot;, 22); Students s2 = new Students(&quot;Jack&quot;, 25); //添加元素 hs.add(s); hs.add(s1); hs.add(s2); //遍历集合对象 for (Students students:hs ) &#123; System.out.println(students); &#125; &#125; &#125; class Students&#123; String name; int age; public Students(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Students&#123;&quot; + &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; + &quot;, age=&quot; + age + &#39;&#125;&#39;; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Students students = (Students) o; return age == students.age &amp;&amp; Objects.equals(name, students.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125; &#125; Collections 面试题：Collection和collections 有何区别？ collection 是集合体系的最顶层，包含了集合体系的共性 collections 是一个工具类，方法都是用于操作collection 常用方法： binarySearch ——- 二分查找(元素有序) copy —— 源列表覆盖目标列表（目标》=源列表） fill —— 使用指定的对象填充指定列表的所有元素 reverse —– 反转 shuffle —– 随机置换 sort —– 排序 （自然顺序排序） swap —- 指定列表中的两个索引位置互换 Modifier and Type Method and Description static boolean addAll(Collection c, T... elements) 将所有指定的元素添加到指定的集合中。 static Queue asLifoQueue(Deque deque) 返回一个 Deque视图为后进先出（LIFO） Queue。 static int binarySearch(List&gt; list, T key) 使用二进制搜索算法搜索指定对象的指定列表。 static int binarySearch(List list, T key, Comparator c) 使用二进制搜索算法搜索指定对象的指定列表。 static Collection checkedCollection(Collection c, 类 type) 返回一个指定集合的动态类型安全的观点。 static List checkedList(List list, 类 type) 返回一个动态类型安全的查看指定的列表。 static Map checkedMap(Map m, 类 keyType, 类 valueType) 返回一个动态类型安全的查看指定的Map。 static NavigableMap checkedNavigableMap(NavigableMap m, 类 keyType, 类 valueType) 返回一个动态类型安全的查看指定的导航电子Map。 static NavigableSet checkedNavigableSet(NavigableSet s, 类 type) 返回一个动态类型安全的集合视图指定通航。 static Queue checkedQueue(Queue queue, 类 type) 返回一个动态类型安全的查看指定队列。 static Set checkedSet(Set s, 类 type) 返回一个指定的动态类型安全的观点。 static SortedMap checkedSortedMap(SortedMap m, 类 keyType, 类 valueType) 返回一个动态类型安全的查看指定的排序图。 static SortedSet checkedSortedSet(SortedSet s, 类 type) 返回一个动态类型安全的查看指定的排序设置。 static void copy(List dest, List src) 将所有的元素从一个列表复制到另一个列表中。 static boolean disjoint(Collection c1, Collection c2) 返回 true如果两个指定集合没有共同的元素。 static Enumeration emptyEnumeration() 返回一个没有元素的枚举。 static Iterator emptyIterator() 返回一个没有元素的迭代器。 static List emptyList() 返回一个空列表（不可变）。 static ListIterator emptyListIterator() 返回一个没有元素的列表迭代器。 static Map emptyMap() 返回一个空Map（不可变）。 static NavigableMap emptyNavigableMap() 返回一个空的导航Map（不可变）。 static NavigableSet emptyNavigableSet() 返回一个空的导航集（不可变）。 static Set emptySet() 返回一个空集（不可变）。 static SortedMap emptySortedMap() 返回一个空的排序映射（不可变）。 static SortedSet emptySortedSet() 返回一个空的排序集（不可变）。 static Enumeration enumeration(Collection c) 返回指定集合的枚举数。 static void fill(List list, T obj) 用指定元素替换指定列表的所有元素。 static int frequency(Collection c, Object o) 返回指定集合中等于指定对象的元素的数目。 static int indexOfSubList(List source, List target) 返回指定的源列表中指定的目标列表的第一个发生的起始位置，或-如果没有这样的发生，则- 1。 static int lastIndexOfSubList(List source, List target) 返回指定的源列表中指定的目标列表的最后一个发生的起始位置，或-如果没有这样的发生，则- 1。 static ArrayList list(Enumeration e) 返回一个数组列表，该列表包含在返回的顺序中由枚举返回的元素的元素。 static &gt;T max(Collection coll) 返回最大元素的集合，根据其元素的自然排序。 static T max(Collection coll, Comparator comp) 返回给定集合的最大元素，根据指定的比较器诱导的顺序。 static &gt;T min(Collection coll) 返回最小的元素的集合，根据其元素的自然排序。 static T min(Collection coll, Comparator comp) 返回给定集合的最小元素，根据指定的比较器诱导的顺序。 static List nCopies(int n, T o) 返回一个不可变列表包含指定对象的 n副本。 static Set newSetFromMap(Map map) 返回一个由指定的映射支持的集合。 static boolean replaceAll(List list, T oldVal, T newVal) 将列表中的某一特定值的所有出现替换为另一个。 static void reverse(List list) 反转指定列表中元素的顺序。 static Comparator reverseOrder() 返回一个比较器，对一系列的实施 Comparable界面对象的自然顺序相反。 static Comparator reverseOrder(Comparator cmp) 返回一个对指定比较器的反向排序的比较器。 static void rotate(List list, int distance) 按指定的距离旋转指定列表中的元素。 static void shuffle(List list) 随机置换指定列表使用随机默认源。 static void shuffle(List list, Random rnd) 随机排列指定列表使用指定的随机源。 static Set singleton(T o) 返回只包含指定对象的不可改变的集合。 static List singletonList(T o) 返回只包含指定对象的不可改变的列表。 static Map singletonMap(K key, V value) 返回一个不可改变的Map，只将指定的指定的键映射到指定的值。 static &gt;void sort(List list) 指定列表为升序排序，根据其元素的 natural ordering。 static void sort(List list, Comparator c) 根据指定的比较器指定的顺序对指定的列表进行排序。 static void swap(List list, int i, int j) 在指定的列表中的指定位置上交换元素。 static Collection synchronizedCollection(Collection c) 返回由指定集合支持的同步（线程安全）集合。 static List synchronizedList(List list) 返回由指定列表支持的同步（线程安全）列表。 static Map synchronizedMap(Map m) 返回由指定的Map支持的同步（线程安全）Map。 static NavigableMap synchronizedNavigableMap(NavigableMap m) 返回指定的导航Map支持的同步（线程安全）导航Map。 static NavigableSet synchronizedNavigableSet(NavigableSet s) 返回由指定的导航集支持的同步（线程安全）导航集。 static Set synchronizedSet(Set s) 返回一个由指定集合支持的同步（线程安全）集。 static SortedMap synchronizedSortedMap(SortedMap m) 返回一个由指定的排序映射支持的同步（线程安全）排序的Map。 static SortedSet synchronizedSortedSet(SortedSet s) 返回一个由指定的排序集支持的同步（线程安全）排序集。 static Collection unmodifiableCollection(Collection c) 返回指定集合的一个不可修改的视图。 static List unmodifiableList(List list) 返回指定列表中的一个不可修改的视图。 static Map unmodifiableMap(Map m) 返回指定映射的一个不可修改的视图。 static NavigableMap unmodifiableNavigableMap(NavigableMap m) 返回指定的导航电子Map的一个不可修改的视图。 static NavigableSet unmodifiableNavigableSet(NavigableSet s) 返回指定通航设置不可修改的视图。 static Set unmodifiableSet(Set s) 返回指定的设置不可修改的视图。 static SortedMap unmodifiableSortedMap(SortedMap m) 返回指定的排序图上一个不可修改的视图。 static SortedSet unmodifiableSortedSet(SortedSet s) 返回指定的排序设置不可修改的视图。 模拟斗地主发牌package learn; import java.util.ArrayList; import java.util.Collections; /** * Created by JackFeng on 2020/3/26. */ /* * * 模拟斗地主发牌 * */ public class CollectionsTest &#123; public static void main(String[] args) &#123; //创作扑克牌 //花色 String[] color = &#123;&quot;黑桃&quot;, &quot;红桃&quot;, &quot;梅花&quot;, &quot;方片&quot;&#125;; //数字 String[] nums = &#123;&quot;A&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;10&quot;,&quot;J&quot;,&quot;Q&quot;,&quot;K&quot;&#125;; //牌盒 ArrayList&lt;String&gt; box = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt;color.length ; i++) &#123; // 得到每一个花色的牌 for (int j = 0; j &lt;nums.length ; j++) &#123; // 得到每一个数字 box.add(color[i] + nums[j]); &#125; &#125; box.add(&quot;大王&quot;); box.add(&quot;小王&quot;); // System.out.println(box.size()); // 洗牌 使用置换方法 Collections.shuffle(box); // System.out.println(box); // 牌友分牌 54-3 /3 = 17张 3张底牌 ArrayList&lt;String&gt; A = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; B = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; C = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt;box.size() -3; i++) &#123; /* * i = 0; i % 3 = 0; * i = 1; i % 3 = 1; * i = 2; i % 3 = 2; * */ if (i % 3 == 0) &#123; A.add(box.get(i)); &#125; else if (i % 3 == 1) &#123; B.add(box.get(i)); &#125; else if (i % 3 == 2) &#123; C.add(box.get(i)); &#125; &#125; System.out.println(A); //底牌 for (int i = box.size()-3; i &lt; box.size() ; i++) &#123; System.out.println(box.get(i)); &#125; System.out.println(); &#125; &#125; 5、集合MapInterface Map&lt;K,V&gt; 参数类型 K -钥匙的Map保持型 V -映射的值的类型 public interface Map&lt;K,V&gt; 映射键到值的对象。一张Map不能包含重复的键，每个键可以映射到至多一个值。 Map 和 Collection 的区别? Map: 双列集合,常用于处理有对应关系的数据，key是不可以重复的 Collection： 单列集合，collection有不同的子体系，有的允许重复有索引有序，有的不允许重复且无序。 Map常用功能： 映射功能 put key映射到value,若key存在，则覆盖value，并且返回原来的value；不存在则返回为null 获取功能 get 根据指定的key 返回对应的value Set 获取所有的Key Collection values 获取所有的Value size 返回对应关系的个数 删除功能 clear 清空所有对应关系 remove 根据指定的key删除对应关系，并返回对应的value值，如果没有删除成功，返回null 判断功能 containsKey 判断指定的key是否存在，存在返回True 否则返回False containsValue 判断指定的value是否存在 isEmpty 判断是否有对应关系 遍历功能： Set Modifier and Type Method and Description void clear() 从这个映射中移除所有的映射（可选操作）。 default V compute(K key, BiFunction remappingFunction) 试图计算出指定键和当前的映射值的映射（或 null如果没有当前映射）。 default V computeIfAbsent(K key, Function mappingFunction) 如果指定的键是不是已经与价值相关的（或映射到 null），尝试使用给定的映射功能，进入到这个Map除非 null计算其价值。 default V computeIfPresent(K key, BiFunction remappingFunction) 如果指定键的值是存在和非空的，尝试计算一个新的映射，给出了键和它当前的映射值。 boolean containsKey(Object key) 返回 true如果这Map包含一个指定的键映射。 boolean containsValue(Object value) 返回 true如果映射到指定的值的一个或多个键。 Set&gt; entrySet() 返回一个 Set视图的映射包含在这个Map。 boolean equals(Object o) 将指定的对象与此映射的相等性进行比较。 default void forEach(BiConsumer action) 在该映射中的每个条目执行给定的操作，直到所有的条目被处理或操作抛出异常。 V get(Object key) 返回指定的键映射的值，或 null如果这个Map不包含的键映射。 default V getOrDefault(Object key, V defaultValue) 返回指定的键映射的值，或 defaultValue如果这个Map不包含的键映射。 int hashCode() 返回此映射的哈希代码值。 boolean isEmpty() 返回 true如果这个Map不包含键值的映射。 Set keySet() 返回一个 Set的关键视图包含在这个Map。 default V merge(K key, V value, BiFunction remappingFunction) 如果指定的键已与值相关联的值或与空值相关联的，则将其与给定的非空值关联。 V put(K key, V value) 将指定的值与此映射中的指定键关联（可选操作）。 void putAll(Map m) 从指定的映射到这个Map（可选操作）复制所有的映射。 default V putIfAbsent(K key, V value) 如果指定的键是不是已经与价值相关的（或映射到 null）将其与给定的值并返回 null，否则返回当前值。 V remove(Object key) 如果存在（可选操作），则从该Map中移除一个键的映射。 default boolean remove(Object key, Object value) 仅当它当前映射到指定的值时，为指定的键移除条目。 default V replace(K key, V value) 仅当它当前映射到某一值时，替换指定的键的条目。 default boolean replace(K key, V oldValue, V newValue) 仅当当前映射到指定的值时，替换指定的键的条目。 default void replaceAll(BiFunction function) 将每个条目的值替换为在该项上调用给定函数的结果，直到所有的条目都被处理或函数抛出异常。 int size() 返回这个映射中的键值映射的数目。 Collection values() 返回一个 Collection视图的值包含在这个Map。 Tips方法实例package learn; import java.util.Collection; import java.util.HashMap; import java.util.Set; /** * * @author JackFeng * @date 2020/3/27 */ public class MapDemo &#123; public static void main(String[] args) &#123; //创建Map对象 HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); // put 映射关系 System.out.println(map.put(&quot;001&quot;, &quot;Jack&quot;)); // 输出为null System.out.println(map.put(&quot;002&quot;, &quot;Jack Jie&quot;)); // 输出为null System.out.println(map.put(&quot;001&quot;, &quot;Jack Feng&quot;)); // 输出为Jack System.out.println(map); //&#123;001=Jack Feng&#125; //`containsKey` System.out.println(map.containsKey(&quot;001&quot;)); //containsValue System.out.println(map.containsValue(&quot;Jack Feng&quot;)); // clear() // map.clear(); //isEmpty // System.out.println(map.isEmpty()); // method(map); // Collection Collection&lt;String&gt; values = map.values(); for (String key:values ) &#123; System.out.println(key); &#125; &#125; private static void method(HashMap&lt;String, String&gt; map) &#123; //set 不允许重复 Set&lt;String&gt; keys= map.keySet(); for (String key:keys ) &#123; System.out.println(key); &#125; &#125; &#125; Map遍历 遍历方式： A(比较繁琐)： 获取所有的key，遍历得到每一个key，让每个key去找对应的value B： entrySet() 使用HashMap存储数据（可以自定义对象作为Key） package learn; import java.util.HashMap; import java.util.Map; import java.util.Set; /** * * @author JackFeng * @date 2020/3/27 */ public class MapTest &#123; public static void main(String[] args) &#123; // 创建map对象 HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); // 映射关系 map.put(&quot;001&quot;, &quot;A&quot;); map.put(&quot;002&quot;, &quot;B&quot;); map.put(&quot;003&quot;, &quot;a2data.cn&quot;); // 第一种遍历方式 // 方式1 获取所有的key 用过key 来获取value method(map); // 第二种遍历方式 System.out.println(&quot;第二种遍历方式&quot;); Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet(); // 遍历集合 // 需要用map 去修饰 Ectry ，因为是map的内部类 // 方式2 获取entry对象 ，通过entry 对象来获取 key value for (Map.Entry&lt;String, String&gt; entry:entries ) &#123; // 获取 key value String key = entry.getKey(); String value = entry.getValue(); System.out.println(&quot;key:&quot;+key + &quot;-----&quot; + &quot;value:&quot;+value); &#125; &#125; private static void method(HashMap&lt;String, String&gt; map) &#123; System.out.println(&quot;第一种遍历方式&quot;); // 召集所有key Set&lt;String&gt; keys = map.keySet(); //遍历map对象 for (String key:keys ) &#123; // 每个key 找到value String value = map.get(key); System.out.println(&quot;key:&quot;+key + &quot;-----&quot; + &quot;value:&quot;+value); &#125; &#125; &#125; Key：自定义对象 package learn; import java.util.HashMap; import java.util.Map; import java.util.Objects; import java.util.Set; /** * * @author JackFeng * @date 2020/3/27 */ public class HashMapTest &#123; public static void main(String[] args) &#123; // 创建Map对象 HashMap&lt;Message, String&gt; hashMap = new HashMap&lt;Message,String&gt;(); // 创建Key对象 Message ms = new Message(&quot;未读消息&quot;,12); Message ms1 = new Message(&quot;已读消息&quot;,22); Message ms2 = new Message(&quot;已读消息&quot;,22); // 如果想要这个不添加 重写 hashcode 和 equals // 添加映射关系 hashMap.put(ms, &quot;001&quot;); hashMap.put(ms1, &quot;002&quot;); hashMap.put(ms2, &quot;002&quot;); // 遍历 我们使用 Entry 使用entrySet Set&lt;Map.Entry&lt;Message, String&gt;&gt; entrys = hashMap.entrySet(); for (Map.Entry&lt;Message, String&gt; entry:entrys ) &#123; Message key = entry.getKey(); String value = entry.getValue(); System.out.println( key + value ); // 发现输出是如下 是因为少写了 toString 方法 //learn.Message@74a14482002 //learn.Message@4554617c001 &#125; &#125; &#125; class Message&#123; String name; int nums; public Message(String name, int nums) &#123; this.name = name; this.nums = nums; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getNums() &#123; return nums; &#125; public void setNums(int nums) &#123; this.nums = nums; &#125; // 解决输出 是地址值 @Override public String toString() &#123; return &quot;Message&#123;&quot; + &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; + &quot;, nums=&quot; + nums + &#39;&#125;&#39;; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Message message = (Message) o; return nums == message.nums &amp;&amp; Objects.equals(name, message.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, nums); &#125; &#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/tags/Java/"}]},{"title":"Java 常用API-II","slug":"Java/JavaSE/Java-常用API-II","date":"2020-05-07T15:55:37.000Z","updated":"2025-05-05T06:09:14.859Z","comments":true,"path":"posts/2834.html","link":"","permalink":"http://www.a2data.cn/posts/2834.html","excerpt":"JavaAPP-II","text":"JavaAPP-II 5、API-II5.0、常用类1、Object String toString() : 返回对象得字符串表示 ​ return getClass().getName() + “@” +Integer.toHexString(hashCode()) getClass(): 返回一个字节码对象 Integer.toHexString(): 返回指定参数的十六进制字符串形式 **hashCode():**返回该对象的哈希码值（内存地址） package api; /** * * @author JackFeng * @date 2020/3/24 */ public class ObjectDemo &#123; public static void main(String[] args) throws ClassNotFoundException &#123; // 获取对象字节码的方式 ----- 应用层 反射 //方式1 通过Object类的getClass()方法获取 Teacher t = new Teacher(); Class clazz = t.getClass(); System.out.println(clazz); //方式2 通过类名调用熟悉class来获取 Class&lt;Teacher&gt; clazz1 = Teacher.class; // 方式3 通过class类的静态方法 forName() 来获取 此时需要跑异常，例如输入错误 Class clazz2 = Class.forName(&quot;api.Teacher&quot;); // true System.out.println(clazz == clazz1); // true System.out.println(clazz1 == clazz2); &#125; &#125; 2、Object-equals == : 比较两个对象是否相等 i基本类型比值，引用类型比地址值。（需要重写） @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; return age == person.age &amp;&amp; Objects.equals(name, person.name); &#125; 3、System Modifier and Type Method and Description static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) 从指定的源数组中复制一个数组，开始在指定的位置，到目标数组的指定位置。 复制数组： 1、源数组 2、源数组的起始索引位置 3、目标数组 4、目标数组的起始索引位置 5、指定接受的元素个数 currentTimeMillis() 返回当前时间以毫秒为单位。 gc() 运行垃圾收集器。 exit(int status) 终止当前正在运行的java虚拟机。 4、Date java.util.Date 根据“指定时间” 创建Date对象 常用方法： 毫秒值 —- Date 返回值 void ，参数Long 获取 —-Date 返回值long 无参数 getTime setTime Date(long date) 分配一个 Date对象并将它初始化为代表指定的毫秒数自基准时间被称为“时代”，即1970年1月1日，00:00:00 GMT。 5、SimpleDateFormat DataFormat 解析日期或时间 SimpleDateFormat是格式和语言环境敏感的方式解析一个类的具体日期。可以格式化（日期→文本），分析（文本→日期），和归一化。 String format(Date date) 将日期格式化为日期/时间字符串。 2020-03-25 2020年3月25日 SimpleDateFormat() 使用默认的 FORMAT现场默认模式和日期格式的符号构建了一个 SimpleDateFormat。 SimpleDateFormat(String pattern) 使用给定的模式和默认的日期格式符号默认 FORMAT现场构建了一个 SimpleDateFormat。 package learn; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; /** * * @author JackFeng * @date 2020/3/25 */ public class SimpleDateFormatDemo &#123; public static void main(String[] args) throws ParseException &#123; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日&quot;); //格式化 Date date = new Date(); String s = sdf.format(date); // 2020年03月25日 System.out.println(s); //解析 Date d = sdf.parse(&quot;2020年3月25日&quot;); System.out.println(d.toLocaleString()); &#125; &#125; 6、Calendar 日历，提供操作年月日时的方法。 获取，月是 从 0开始。 所以 一般情况下 要 +1 int month = c.get(Calendar.MONTH) +1 7、包装类 包装类：封装了基本数据类型的类，Java 为我们提供了更多复杂的方法和一些变量 7.1 String 转IntInterger 1、int intValue（） 2、static int parseInt( String s) 7.2 Int 转 StringString 1、 + “ ” 2、 String toString() —- 无参 3、 static toString() 类似 8、自动装箱和拆箱package learn; import java.util.ArrayList; /** * * @author JackFeng * @date 2020/3/25 */ public class IntegerDemo &#123; public static void main(String[] args) &#123; // 自动装箱 // 相当于 Integer i = new Integer(10); Integer i1 = 10; // 自动拆箱 // 相当于 int a = i.intValue(); Integer i2 = 10; int a = i2; // Integer i3 = new Integer(i1.intValue() + i2.intValue()); Integer i3 = i1 + i2; // 应用场景 ArrayList arrayList = new ArrayList(); // 自动装箱 ,arrayList.add(new Integer(1)) arrayList.add(1); &#125; &#125; 5.1、正则表达式 正则表达式： ​ 规则规范，用于匹配字符串 boolean matcher( String regex) ：判断当前字符串是否匹配指定的正则表达式。 常用正则表达式字符 一、校验数字的表达式 数字：^[0-9]*$ n位的数字：^\\d{n}$ 至少n位的数字：^\\d{n,}$ m-n位的数字：^\\d{m,n}$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 带1-2位小数的正数或负数：^(-)?\\d+(.\\d{1,2})?$ 正数、负数、和小数：^(-|+)?\\d+(.\\d+)?$ 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]){1,3}$ 或 ^+?[1-9][0-9]$ 非零的负整数：^-[1-9][]0-9”$ 或 ^-[1-9]\\d$ 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$ 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 非负浮点数：^\\d+(.\\d+)?$ 或 ^[1-9]\\d.\\d|0.\\d*[1-9]\\d*|0?.0+|0$ 非正浮点数：^((-\\d+(.\\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\\d.\\d|0.\\d*[1-9]\\d*))|0?.0+|0$ 正浮点数：^[1-9]\\d.\\d|0.\\d*[1-9]\\d*$ 或 ^(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9]))$ 负浮点数：^-([1-9]\\d.\\d|0.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9])))$ 浮点数：^(-?\\d+)(.\\d+)?$ 或 ^-?([1-9]\\d.\\d|0.\\d*[1-9]\\d*|0?.0+|0)$ 二、校验字符的表达式 汉字：^[\\u4e00-\\u9fa5]{0,}$ 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 长度为3-20的所有字符：^.{3,20}$ 由26个英文字母组成的字符串：^[A-Za-z]+$ 由26个大写英文字母组成的字符串：^[A-Z]+$ 由26个小写英文字母组成的字符串：^[a-z]+$ 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20}$ 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$ 可以输入含有^%&amp;’,;=?$&quot;等字符：[^%&amp;’,;=?$\\x22]+ 禁止输入含有的字符：[^\\x22]+ 三、特殊需求表达式 Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+).\\w+([-.]\\w+)$ 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$ 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$ 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^((\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7} 身份证号(15位、18位数字)：^\\d{15}|\\d{18}$ 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.\\d)(?=.[a-z])(?=.*[A-Z]).{8,10}$ 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2} 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 钱的输入格式： 1.有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$ 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 5.必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$ 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 备注：这就是最终结果了,别忘了”+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$ 中文字符的正则表达式：[\\u4e00-\\u9fa5] 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行) HTML标记的正则表达式：&lt;(\\S*?)[^&gt;]&gt;.?&lt;/\\1&gt;|&lt;.*? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) 首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字) IP地址：\\d+.\\d+.\\d+.\\d+ (提取IP地址时有用) IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)) 校验QQ号： 必须0-15 位 不能以0 开头 必须是数字 package learn; /** * * @author JackFeng * @date 2020/3/25 */ public class RegexDemo &#123; public static void main(String[] args) &#123; String qq = &quot;66860619&quot;; boolean matches = qq.matches(&quot;[1-9][0-9]&#123;4,14&#125;&quot;); System.out.println(matches); String a1 = &quot;00001&quot;; boolean matches1 = a1.matches(&quot;[1-9][0-9]&#123;4,14&#125;&quot;); System.out.println(matches1); &#125; &#125; 正则判断元音 aeiou AEIOU public static boolean check(String s)&#123; // 转换成小写 s = s.toLowerCase(); return s.matches(&quot;\\\\w[aeiou]\\\\w&quot;); &#125; Splitpackage learn; /** * * @author JackFeng * @date 2020/3/25 */ public class SplitDemo &#123; public static void main(String[] args) &#123; String s = &quot; -1 2 22 123 88&quot;; System.out.println(&quot;正常分割&quot;); String[] arr = s.split(&quot; &quot;); print(arr); // 正则分割 String[] arr1 = s.split(&quot; +&quot;); System.out.println(&quot;正则分割&quot;); print(arr1); &#125; public static void print(String[] arr)&#123; for (int i = 0; i &lt;arr.length ; i++) &#123; System.out.println(arr[i]); &#125; &#125; &#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/tags/Java/"}]},{"title":"Java面向对象 (继承、多态)","slug":"Java/JavaSE/Java面向对象-继承、多态","date":"2020-05-07T15:55:15.000Z","updated":"2021-01-24T13:53:54.757Z","comments":true,"path":"posts/43249.html","link":"","permalink":"http://www.a2data.cn/posts/43249.html","excerpt":"Java面向对象 继承 多态","text":"Java面向对象 继承 多态 面向对象 (继承、多态)1、static静态 static（静态） 关键字 用于修饰成员变量和成员方法 特点： 被所有的对象所共享 可以使用类名调用 静态加载优先于对象 随着类的加载而加载 注意事项： 静态方法只能访问静态成员 非静态方法既可以访问静态也可以访问非静态 非静态方法中不可以定义静态变量 静态方法中不可以定义this，super关键字 优缺点： 优点 对对象的共享数据提供单独的存储空间，节省空间 直接被类名调用，不用在堆内存创建对象 缺点 访问出现局限性（只能访问静态） package one; /** * Created by JackFeng on 2020/3/8. */ public class StaticDemo &#123; public static void main(String[] args) &#123; /* * Math 主要的数学运算方法 * */ // static double abs ( double a) : 返回绝对值 System.out.println(Math.abs(15)); System.out.println(Math.abs(-10)); System.out.println(&quot;----------&quot;); // ceil 天花板 向上取整 System.out.println(Math.ceil(1.2)); System.out.println(Math.ceil(1.6)); System.out.println(&quot;----------&quot;); // floor 向下取整 System.out.println(Math.floor(1.2)); System.out.println(Math.floor(1.8)); System.out.println(&quot;==========&quot;); // round 四舍五入 System.out.println(Math.round(1.2)); System.out.println(Math.round(1.6)); System.out.println(&quot;---------&quot;); // max min System.out.println(Math.max(3,8)); // pow 次幂 第一个参数的第二个参数次幂 System.out.println(&quot;2 的3 次方&quot;); System.out.println(Math.pow(2,3)); // random 随机数 大于0 &lt;1 System.out.println(Math.random()); &#125; &#125; 2、代码块 写一个数据操作的工具类，取最大值，已经取数组中指定索引的值 MyArray 工具类 package com.a2data; /** * Created by JackFeng on 2020/3/13. */ public class MyArrays &#123; // 数组操作 有关的工具类 ，不需要创建对象，所以 可以私有他的构造方法 private MyArrays()&#123;&#125; // 取最大值 public static int getMax(int[] arr)&#123; // 定义参照物 int max = arr[0]; for (int i = 1; i &lt;arr.length ; i++) &#123; if (max&lt;arr[i])&#123; // 替换参照物 max = arr[i]; &#125; &#125; return max; &#125; // 获取指定数组中指定元素的索引位置 public static int getIndex(int[] arr,int a)&#123; for (int i = 0; i &lt;arr.length ; i++) &#123; if (arr[i]== a) return i; &#125; return -1; &#125; &#125; MyArrayDemo 工具类使用 package com.a2data; /** * Created by JackFeng on 2020/3/13. */ public class MyArrayDemo &#123; public static void main(String[] args) &#123; int[] arr = &#123;1, 2, 3, 4, 5, 21&#125;; int max = MyArrays.getMax(arr); System.out.println(max); int index = MyArrays.getIndex(arr, 3); int index1 = MyArrays.getIndex(arr, 6); System.out.println(index); System.out.println(index1); &#125; &#125; 局部代码块： ​ 存在于方法中，控制变量的生命周期（作用域） 构造代码块： ​ 去构造方法中的共性，每次创建对象都会执行，并且在构造方法执行之前执行。 静态代码块： ​ 随着类的加载而加载，只加载一次，加载类时需要加载的驱动 3、继承 继承：Extends ​ 多个类有共同的成员变量和成员方法，抽取到另外一个类中（父类） 只能继承一个父类。 — 只有一个亲爹 只能继承父类非私有成员 支持多层继承 — 还可以有一个亲爷爷 super 与this相似，获取父类的成员和方法。 就近原则！ 方法重写： ​ 在子父类当中,子类的方法和父类的方法完全一样，子类重写了父类的方法(覆盖)。并且super 调用父类的方法即可。 注意事项： 不能重写父类私有的方法 必须大于等于父类方法的权限 注解：@ @Override 继承中构造方法的执行顺序： 子父类继承关系 创建了子类的对象，就会调用子类的构造方法 子类构造方法第一行没有调用父类构造方法，默认调用父类无参构造 肯定先执行父类方法，因为要先给父类的成员变量进行初始化，子类可能会用到。 super() 在子类构造方法的第一行中调用父类的构造方法 继承优缺点 优点： 提高代码的复用性，可维护性 缺点： 耦合性的影响。 开发原则： 高内聚低耦合 内聚：自己完成某件事的能力 耦合：类与类的关系 package com.a2data; /** * Created by JackFeng on 2020/3/13. */ public class ExtendsDemo &#123; public static void main(String[] args) &#123; Zi zi = new Zi(); zi.function(); &#125; static class Die &#123; int num = 11; Die()&#123; System.out.println(&quot;我是父类无参构造&quot;); &#125; public Die(int num)&#123; System.out.println(&quot;我是父类有参构造&quot;); &#125; public void method()&#123; System.out.println(&quot;我是父类的方法&quot;); &#125; &#125; static class Zi extends Die&#123; int num = 2020; Zi()&#123; this(1); // 第一行不调用子类，或者其他方法，默认调用父类 System.out.println(&quot;我是子类无参构造&quot;); &#125; Zi(int num)&#123; System.out.println(&quot;我是子类有参构造&quot;); &#125; public void method()&#123; System.out.println(&quot;我是子类的方法&quot;); &#125; void function()&#123; // this.method(); this.num = 20; &#125; &#125; &#125; this和super的区别 this和super的区别： this： 当前对象的引用 调用子类的成员变量 调用子类的成员方法 在子类的构造方法第一行调用子类其他构造方法 super ： 子类对象的父类引用 调用父类的成员变量 调用父类的成员方法 在子类的构造方法第一行调用父类的构造方法 4、匿名对象&amp;final 匿名对象：没有名字的对象 场景： ​ 当方法只是使用一次的时候，可以使用匿名对象 ​ 可以当做参数传递，但无法进行操作 注意： ​ 匿名对象可以调用成员对象，并赋值，但是并没有意义，因为只调用一次 package com.a2data; /** * Created by JackFeng on 2020/3/13. */ public class AnonyDemo &#123; public static void main(String[] args) &#123; // Student s = new Student(); // s.study(); new Student(); // 匿名对象，没有变量名引用的对象 &#125; &#125; class Student&#123; String name; int age; public void study()&#123; System.out.println(&quot;加油提升自己&quot;); &#125; &#125; Final 修饰符： 可以用于修饰类，成员方法和成员变量 final所修饰的类，不可被继承，不能有子类 final所修饰的方法，不能被重写。 final所修饰的变量，是不可修改的，是常量 常量： 字面值常量： 1,2,3 自定义常量：被final所修饰的成员变量，一旦初始化则不可改变 注意： 自定义常量必须初始化，可以选择显示初始化或者构造初始化 5、抽象类 abstract: 关键字，用于修饰方法和类 抽象方法： ​ 不同类的方法是相似的，但是具体内容又不太一样，所以我们智能抽取它的申明，没有具体的方法体，没有具体方法体的方法就是抽象方法 抽象类： ​ 有抽象方法的类必须是抽象类 ​ 特点： 抽象方法只能在抽象类里边 抽象类和抽象方法必须被abstract修饰 抽象类不能创建对象（不能实例化） 抽象类中可以有非抽象的方法 抽象类和类的关系也是继承 抽象类的成员特点 成员变量 可以有成员变量 可以有常量 成员方法 可以有抽象方法 可以有非抽象方法 构造方法 可以有构造方法的，需要对抽象类的成员变量进行初始化 注意： ​ 一个类继承了抽象类需要重写他所有的抽象方法,否则这个类就得是抽象类 package com.a2data; import sun.plugin2.message.JavaReplyMessage; /** * Created by JackFeng on 2020/3/15. */ /* * * 普通教练，高级教练 * * * 共性： * 属性 姓名 年龄 性别 * 行为 教学 * * */ public class AbastractTest &#123; public static void main(String[] args) &#123; BasicTeacher bt = new BasicTeacher(); bt.name = &quot;小白教练&quot;; bt.teach(); JobTeacher jt = new JobTeacher(); jt.name = &quot;小灰教练&quot;; jt.teach(); &#125; &#125; abstract class Teacher&#123; String name; // 姓名 int age; // 年龄 String gender; public abstract void teach(); &#125; class BasicTeacher extends Teacher&#123; @Override public void teach() &#123; System.out.println(name + &quot;讲基础内容&quot;); &#125; &#125; class JobTeacher extends Teacher&#123; @Override public void teach() &#123; System.out.println(name+ &quot;讲高级实战内容&quot;); &#125; &#125; 6、接口 interface: 接口是一个比抽象类还抽象的类，接口里所有的方法全是抽象方法,接口和类的关系是实现，implements 格式： interface 接口名 { ​ } 特点： 只能有抽象方法 只能有常量 只能用 publie&amp;abstract 方法 默认使用public static final 来修饰成员变量 建议 手动输入默认修饰符（public&amp;abstract），虽然不输入也会是默认的。 注意： 接口不能创建对象（不能实例化） 类与接口的关系是实现关系，一个类实现一个接口必须实现它的所有方法 类与类：继承关系，单一继承，多层继承 类与接口：实现关系，多实现 接口与接口关系： 继承关系，多层继承 接口优点： 1、类与接口的关系，实现关系，而且是多实现，一个类可以实现多个接口，类与类之间是继承关系，java中的继承是单一继承，一个类只能有一个父类，打破了继承的局限性 2、对外提供规则（统一要求，例如Use接口,充电器接口） 3、降低程序的耦合性 定义规则，模块化开发 高内聚低耦合，提高开发效率 接口和抽象类的区别： 共性： 抽取出抽象的概念 区别1：与类的关系 类与接口是实现关系，多实现 类与抽象类是继承关系，Java中的继承是单一继承，一个类只能有一个父类，java中的继承是多层继承 区别2：成员 成员变量： 抽象类可以有成员变量，也可以有常量 接口只能有常量 成员方法： 抽象类可以有抽象方法，也有非抽象方法 接口只能有抽象方法，默认修饰符 public abstract 构造方法： 抽象类有构造方法的 接口没有构造方法 接口开发的思路 分析： ​ 由下至上 不断向上抽取 实现： ​ 由上至下 先实现共性 应用： ​ 使用具体的子类 package com.a2data; /** * Created by JackFeng on 2020/3/15. */ /* * * 篮球运动员和教练 * 乒乓球运动员和教练 * 篮球运动员和教练要出国访问，需要学习英语 * * * * */ public class InterfaceTest &#123; public static void main(String[] args) &#123; //篮球运动员对象 BasketBallPlayer bp = new BasketBallPlayer(); bp.name = &quot;姚明&quot;; bp.age = 35; bp.gender = &quot;男&quot;; bp.sleep(); bp.study(); bp.speak(); System.out.println(&quot;------------&quot;); //乒乓球教练对象 PingpangCoache pp = new PingpangCoache(); pp.name = &quot;刘教练&quot;; pp.age = 40; pp.gender = &quot;男&quot;; pp.sleep(); pp.teach(); // pp.speak() &#125; &#125; class Person&#123; String name; int age; String gender; public Person() &#123; &#125; public Person(String name, int age, String gender) &#123; // 成员变量初始化 this.name = name; this.age = age; this.gender = gender; &#125; public void eat()&#123; System.out.println(&quot;吃饭&quot;); &#125; public void sleep()&#123; System.out.println(&quot;睡觉&quot;); &#125; &#125; interface SpeakEnglish &#123; public abstract void speak(); &#125; // 运动员 abstract class Player extends Person&#123; //学习 public abstract void study(); &#125; // 教练 abstract class Coach extends Person&#123; // 教 public abstract void teach(); &#125; //篮球运动员 class BasketBallPlayer extends Player implements SpeakEnglish&#123; @Override public void study() &#123; System.out.println(&quot;学扣篮&quot;); &#125; @Override public void speak() &#123; System.out.println(&quot;说英语&quot;); &#125; &#125; //乒乓球运动员 class PingpangPlayer extends Player&#123; @Override public void study() &#123; System.out.println(&quot;学颠球&quot;); &#125; &#125; //篮球教练 class BasketBallCoach extends Coach implements SpeakEnglish&#123; @Override public void teach() &#123; System.out.println(&quot;教扣篮&quot;); &#125; @Override public void speak() &#123; System.out.println(&quot;说英语&quot;); &#125; &#125; //乒乓球教练 class PingpangCoache extends Coach&#123; @Override public void teach() &#123; System.out.println(&quot;教颠球&quot;); &#125; &#125; 7、多态前提 多态的前提： 子父类继承关系 方法的重写 父类引用指向子类对象 动态绑定：运行期间调用的方法，是根据具体的类型，具体的方法 优缺点： 优点： 可以提高可维护性(多态前提所保证的)，提高代码的可扩展性 缺点： 无法直接访问子类特有的成员 package com.a2data; /** * Created by JackFeng on 2020/3/15. */ public class PoymorphicDemo &#123; public static void main(String[] args) &#123; // Cat cat = new Cat(); // cat.eat(); // 父类引用 Animal a // 指向 = // 子类对象 new Cat() // 动态绑定 Animal a = new Cat(); a.eat(); &#125; &#125; class Animal &#123; public void eat()&#123; System.out.println(&quot;c吃东西&quot;); &#125; &#125; class Cat extends Animal&#123; public void eat()&#123; System.out.println(&quot;猫吃鱼&quot;); &#125; &#125; 特点 多态的成员特点： 成员变量 编译时看的是左边，运行时看的是左边 成员方法 编译时看的是左边，运行时看的是右边 静态方法 编译时看的是左边，运行时看的是左边 编译时看的都是左边，运行时成员方法看的是右边，其他（成员变量和静态方法）看的都是左边 package com.java; import java.util.Date; /** * Created by JackFeng on 2020/3/15. */ public class PoymorphicDemo &#123; public static void main(String[] args) &#123; // 成员变量 // 在继承中没有被重写的概念，没有动态绑定的概念 // 执行的是父类的 Dad d = new Kid(); System.out.println(d.num); // 成员方法 // 运行看右边 System.out.println(&quot;----------&quot;); d.method(); // 静态方法 d.function(); // 使用变量去调用静态方法，相当于用变量类型的类名去调用 所以输出父类的静态方法 &#125; &#125; class Dad&#123; int num = 1; public void method()&#123; System.out.println(&quot;我是父类的方法&quot;); &#125; public static void function()&#123; System.out.println(&quot;我是父类的静态方法&quot;); &#125; &#125; class Kid extends Dad&#123; int num = 21; public void method()&#123; System.out.println(&quot;我是子类的方法&quot;); &#125; public static void function()&#123; System.out.println(&quot;我是子类的静态方法&quot;); &#125; &#125; 多态转型 多态中的向上转型和向下转型： 引用类型之间的转换 向上转型 由小到大（子类型转换成父类型) 向下转型 由大到小 基本数据类型的转换 自动类型转换 由小到大 byte short char – int — long — float – double 强制类型转换 由大到小 package com.java; /** * Created by JackFeng on 2020/3/15. */ public class polymorphicDemo &#123; public static void main(String[] args) &#123; Animal a = new Dog(); // 向上转型 a.eat(); Dog d = (Dog) a; // 向下转型 本身是什么类型 转换成什么类型 d.swim(); &#125; &#125; class Animal&#123; public void eat()&#123; System.out.println(&quot;吃东西&quot;); &#125; &#125; class Dog extends Animal&#123; public void eat()&#123; System.out.println(&quot;啃骨头&quot;); &#125; public void swim()&#123; System.out.println(&quot;狗刨&quot;); &#125; &#125; 8、权限修饰符包 特点：（package） 可以由多层 不同包下的文件名可以重复 包的声明必须在第一行代码 包使用场景类的全名： 包名.类名 同包： ​ 相同包下的类可以直接访问，不需要做其他的操作 异包: ​ 1、使用类的全名 ​ 2、使用关键字import将类导入 注意： ***** 代表的是通配符，代表导入了这个包下所有的类,并没有导入子包下的类 权限修饰符 pubilc —- 访问都是对外的 当前类，相同包下不同的类，不同包下的类 default 当前类，相同包下不同的类 当前包下使用(与protected)区别 private 仅限当前类 protected — 数据保护 当前类，相同包下不同的类 让子类对象使用 9、内部类成员内部类 1、在类的成员位置，和成员变量以及成员方法所在的位置是一样的 2、在内部类当中，可以直接访问外部类的成员，包括私有成员 修饰符： 可以使用权限修饰符修饰成员内部类,但是如果使用私有来修饰，则无法在其他类中访问 可以使用static 修饰成员内部类，不用再创建外部类对象 匿名内部类： 必须在定义匿名内部类得时候创建它得对象 格式： new 类/接口(){ 继承这个类得子类对象，可以重写父类方法 实现这个类得子类对象，必须实现这个接口得所有方法 }； 原理： 创建了继承这个类得子类对象或者创建了实现这个接口得子类对象 应用场景： 作为参数传递 package com.java; /** * Created by JackFeng on 2020/3/15. */ public class InnerDemo &#123; public static void main(String[] args) &#123; Outer.Inner i = new Outer().new Inner(); i.function(); &#125; &#125; class Outer&#123; private int num = 10; public void method()&#123; Inner i = new Inner(); i.function(); &#125; class Inner&#123; public void function()&#123; // 私有成员 可以i直接访问 System.out.println(num); &#125; &#125; &#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/tags/Java/"}]},{"title":"Java常用API","slug":"Java/JavaSE/Java常用API","date":"2020-05-07T15:54:55.000Z","updated":"2021-01-24T13:53:56.008Z","comments":true,"path":"posts/32274.html","link":"","permalink":"http://www.a2data.cn/posts/32274.html","excerpt":"Java常用API-I","text":"Java常用API-I 常用API1、String类功能赋值 String S = “hello “ Objcet： 是类层次结构的根类，所有类都直接活间接的继承该类 判断功能 boolean equals(Object obj) —-比较字符串的内容是否相同 boolean equalsIgnoreCase(String str) —- 比较字符串内容是否相同，忽略大小写 boolean startsWith(String str) —- 判断字符串对象是否以指定的str开头 boolean endsWitn(String str) —- 判断字符串对象是否以指定的str结尾 获取功能 int length() —- 获取字符串的长度 char charAt(int index) —- 获取指定索引处的字符 int indexOf(String str) —- 获取str 在字符串对象中第一次出现的索引 String substring(int start) —- 从start开始截取字符串 String substring(int start,int end) — 从s-e 截取，包括s 不包括e 统计录入大小写数字 package myTest; import java.util.Scanner; /** * Created by JackFeng on 2020/3/2. */ public class StringTest &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入一个字符串数据：&quot;); String s = sc.nextLine(); //定义统计变量 int BigCount = 0; int SmaCount = 0; int numberCount = 0; //遍历字符 for (int i = 0; i &lt;s.length() ; i++) &#123; char ch = s.charAt(i); if (ch &gt;= &#39;A&#39; &amp;&amp; ch&lt;= &#39;Z&#39;) &#123; BigCount++; &#125;else if(ch &gt;= &#39;a&#39; &amp;&amp; ch&lt;= &#39;z&#39;)&#123; SmaCount++; &#125;else if (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)&#123; numberCount++; &#125;else &#123; System.out.println(&quot;该字符&quot;+ch+&quot;非法&quot;); &#125; &#125; System.out.println(&quot;大写字符&quot;+BigCount); System.out.println(&quot;小写字符&quot;+SmaCount); System.out.println(&quot;数字字符&quot;+numberCount); &#125; &#125; 转换功能 char[ ] toCharArray() —- 把字符串转换为字符数组 String toLlowerCase() —- 把字符串转换为小写字符串 String toUpperCase() —- 把字符串转换为大写字符串 字符串的遍历： A：length() 加上charAt() B：字符串转换字符数组，然后遍历数组 空格&amp;分割 去除字符串两端空格： String trim() 按照指定符号分割字符串 String[ ] split (String str) 实现字符串反转 package myTest; import java.util.Scanner; /** * Created by JackFeng on 2020/3/2. */ /* * 键盘录入：abc 输出 cba * * 反转方法： * A： 把字符串倒着遍历，得到每一个字符拼接成字符串 * B： 把字符串转换成字符数组，然后对字符数组进行反转，最后把字符数组转换为字符串 * * */ public class StringTest1 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入一个字符串：&quot;); String s = sc.nextLine(); // 调用方法A // String result = reverse(s); //调用方法B String result = reFan(s); //输出结果 System.out.println(&quot;result:&quot;+result); &#125; // 方案A public static String reverse (String s)&#123; String ss = &quot;&quot;; // 倒着遍历 for (int i = s.length()-1; i &gt;=0 ; i--) &#123; ss+=s.charAt(i); &#125; return ss; &#125; // 方案B public static String reFan( String s)&#123; // 把字符串转换为字符数组 char[] chs = s.toCharArray(); for (int start = 0,end = chs.length-1; start &lt;=end ; start++,end--) &#123; char temp = chs[start]; chs[start] = chs[end]; chs[end] = temp; &#125; // 把字符数组转换为字符串 String ss = new String(chs); return ss; &#125; &#125; 2、StringBuilder类功能 StringBuilder : 可变的字符串，字符串缓冲区类 String 内容是固定 StringBuider 内容是可变的 构造方法： StringBuilder() 成员方法： public int capacity() :返回当前容量 public int length() :返回长度(字符数) 容量 —- 理论值 长度 —- 实际值 常用方法 添加功能： public StringBuilder append(任意类型) 添加数据，并返回自身对象 链式编程 sb.append(“hello”).append(“world) 反转功能 public StringBuilder reverse() StringBuilder ——&gt;String toString() —— 转成String String ——&gt; StringBuilder StringBuilder (String str) —– 构造方法 键盘录入对称判断package myTest; import java.util.Scanner; /** * Created by JackFeng on 2020/3/2. */ /* * 判断一个字符串是否是对称字符串 * * 例如 abc 不是 aba abba aaa 是对称字符串 * * */ public class StringBuilderDemo &#123; public static void main(String[] args) &#123; // 键盘录入 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入一个字符串：&quot;); String s = sc.nextLine(); // 方法实现 // 调用方法 boolean b = isDuiChen(s); System.out.println(&quot;b:&quot;+b); &#125; public static boolean isDuiChen(String s)&#123; StringBuilder sb = new StringBuilder(s); sb.reverse(); String result = sb.toString(); return result.equals(s); &#125; &#125; 3、对象数组 对象数组练习： 定义学生类 创建学生数组 创建学生对象 把学生对象作为元素赋值给学生数组 遍历学生数组 package com.datascience.myArray; /** * Created by JackFeng on 2020/3/2. */ public class StudentDemo &#123; public static void main(String[] args) &#123; // 创建学生数组 Student[] students = new Student[3]; //创建学生对象 Student s1 = new Student(&quot;荣耀王者&quot;, 50); Student s2 = new Student(&quot;星耀&quot;, 10); Student s3 = new Student(&quot;王者&quot;, 20); //学生对象 作为元素赋值给学生数组 students[0] = s1; students[1] = s2; students[2] = s3; //遍历学生数组 for (int i = 0; i &lt;students.length ; i++) &#123; Student s = students[i]; System.out.println(s); //这样输出的是地址值 System.out.println(s.getName()+&quot;=====&quot;+s.getAge()); &#125; &#125; &#125; 学生类 package com.datascience.myArray; /** * Created by JackFeng on 2020/3/2. */ // alt + insert 可以快速生成 get/set 方法等 public class Student &#123; private String name; private int age; public Student(String name,int age) &#123; this.name = name; this.age = age; &#125; public Student() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; &#125; 4、集合ArrayList ArrayList： 大小可变数组的实现 : 特殊的数据类型：泛型 构造方法： ArrayList() 添加元素： pubilc boolean add(E e) — 添加元素 public void add (int index, E element) — 指定索引处 添加元素 获取元素： public E get(int index) —- 返回指定索引出的元素 集合长度： public int size() 返回集合中元素的个数 删除元素： public boolean remove(object o) 删除指定的元素，返回删除是否成功 pubilc E remove(int index) 删除指定索引出的元素，返回被删除的元素 修改元素： public E set(int index, E element) 修改指定索引出的元素，返回被修改的元素 AarryList(集合)遍历： size() + get 方法 package com.myArray; import java.util.ArrayList; /** * Created by JackFeng on 2020/3/ */ public class ArrayListDemo &#123; public static void main(String[] args) &#123; // 创建集合对象 ArrayList&lt;Object&gt; array = new ArrayList&lt;&gt;(); // 这里如果是String 接受就是String Object 接受就是Object // add(E e) 添加元素 array.add(&quot;hello&quot;); array.add(&quot;world&quot;); array.add(&quot;Data&quot;); System.out.println(array); // 在指定索引处添加一个元素 // 第一个位置添加 Science array.add(1,&quot;Science&quot;); System.out.println(&quot;====&quot;); System.out.println(&quot;array&quot;+ array); //获取元素 get System.out.println(array.get(1)); // 集合长度 size System.out.println(&quot;集合的长度：&quot;+array.size()); // 删除元素 remove System.out.println(&quot;remove：&quot;+array.remove(&quot;hello&quot;)); System.out.println(&quot;remove：&quot;+array.remove(&quot;hello&quot;)); // 不存在则失败，这里就是失败了 false //删除指定元素 remove (int index) System.out.println(&quot;remove：&quot;+ array.remove(1)); // 修改元素 set (int index , E element) System.out.println(&quot;set:&quot;+ array.set(1,&quot;hhha&quot;)); // System.out.println(array); // 添加元素 array.add(&quot;aaa&quot;); array.add(&quot;abc&quot;); array.add(&quot;acd&quot;); //遍历集合 System.out.println(&quot;================&quot;); for (int i = 0; i &lt;array.size() ; i++) &#123; System.out.println(array.get(i)); &#125; // 标准遍历 for (int i = 0; i &lt;array.size() ; i++) &#123; // object Object s = array.get(i); System.out.println(s); &#125; &#125; &#125; Test package com.myArray; import java.util.ArrayList; import java.util.Scanner; /** * Created by JackFeng on 2020/3/ */ /* * * 创建一个集合：存储学生对象，学生对象的数据来自键盘录入，最后遍历集合 * * * 分析： * A： 定义学生类 String name , String age * B： 创建集合对象 * C： 键盘录入数据，创建学生对象，把键盘录入的数据赋值给学生对象的成员变量 * D： 把学生对象作为元素存储到集合中 * E： 遍历集合 * * */ public class ArrayListTest &#123; public static void main(String[] args) &#123; //创建集合对象 ArrayList&lt;Student&gt; array = new ArrayList&lt;Student&gt;(); //d调用方法 addStudent(array); addStudent(array); addStudent(array); //遍历集合 for (int i = 0; i &lt;array.size() ; i++) &#123; Student s = array.get(i); System.out.println(s.getName() +&quot;-------&quot;+ s.getAge()); &#125; &#125; /* * 提高复用性，键盘录入学生信息 封装成一个方法 * * 两个明确： * 返回值类型： void * 参数列表： ArrayList&lt;Student&gt; * * * */ public static void addStudent (ArrayList&lt;Student&gt; array)&#123; //键盘录入 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入姓名：&quot;); String name = sc.nextLine(); System.out.println(&quot;请输入年龄：&quot;); String age = sc.nextLine(); //赋值给成员变量 Student s = new Student(); s.setName(name); s.setAge(age); //学生对象存储到集合中 array.add(s); &#125; &#125; 简易学生管理系统 步骤： ​ A： 定义学生类 ​ B： 主界面的代码编写 ​ C： 查看所有学生 ​ D： 添加学生 ​ E： 修改学生 ​ F： 删除学生 Student package myStudentManager; /** * Created by JackFeng on 2020/3/4. */ /* * * 学生类 * */ public class Student &#123; private String id; // 姓名 private String name; // private String age; private String address; public Student() &#123; &#125; public Student(String id, String name, String age, String address) &#123; this.id = id; this.name = name; this.age = age; this.address = address; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAge() &#123; return age; &#125; public void setAge(String age) &#123; this.age = age; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; &#125; Test package myStudentManager; import java.util.ArrayList; import java.util.Scanner; /** * Created by JackFeng on 2020/3/4. */ public class StudentMangerTest &#123; public static void main(String[] args) &#123; //创建集合对象，存储学生数据 ArrayList&lt;Student&gt; array = new ArrayList&lt;&gt;(); while (true) &#123; // 主界面 System.out.println(&quot;---------欢迎来到学生管理系统----------&quot;); System.out.println(&quot;1 查看所有学生&quot;); System.out.println(&quot;2 添加学生&quot;); System.out.println(&quot;3 删除学生&quot;); System.out.println(&quot;4 修改学生&quot;); System.out.println(&quot;5 退出&quot;); System.out.println(&quot;请输入你的选择：&quot;); // 键盘录入 Scanner sc = new Scanner(System.in); String choice = sc.nextLine(); switch (choice) &#123; case &quot;1&quot;: // 查看所有学生 findAllStudent(array); break; case &quot;2&quot;: // 添加学生 addStudent(array); break; case &quot;3&quot;: //删除学生 delStudent(array); break; case &quot;4&quot;: //修改学生 updataStudent(array); break; case &quot;5&quot;: //退出 // break; case 穿透 default: System.out.println(&quot;谢谢你的使用！&quot;); System.exit(0); // jvm 退出 break; &#125; &#125; &#125; //1 查看所有学生 public static void findAllStudent(ArrayList&lt;Student&gt; array)&#123; // 判断集合中是否有数据，如果没有数据，给出提示，并让该方法不继续往下执行 if (array.size()==0)&#123; System.out.println(&quot;不好意思，暂无学生信息，请重新选择你的操作&quot;); return;// void 没有返回值 可以直接return &#125; // \\t System.out.println(&quot;学号\\t\\t姓名\\t年龄\\t地址&quot;); for (int i = 0; i &lt; array.size(); i++) &#123; Student s = array.get(i); System.out.println(s.getId()+&quot;--&quot;+s.getName()+&quot;--&quot;+s.getAge()+&quot;---&quot;+s.getAddress()); &#125; &#125; // 添加学生 public static void addStudent(ArrayList&lt;Student&gt; array)&#123; //创建键盘录入对象 Scanner sc = new Scanner(System.in); // id 定义在外边 因为下边还要用 String id; // 代码重复使用 while (true)&#123; System.out.println(&quot;请输入 学生ID：&quot;); // String id = sc.nextLine(); id = sc.nextLine(); //判断学号是否存在 // 定义标记默认为false boolean flag = false; for (int i = 0; i &lt;array.size() ; i++) &#123; Student s = array.get(i); if (s.getId().equals(id))&#123; flag = true; // 说明学号被占用 &#125; &#125; if (flag)&#123; System.out.println(&quot;你输入的学号已经被占用&quot;); &#125;else &#123; break; &#125; &#125; System.out.println(&quot;请输入 学生姓名：&quot;); String name = sc.nextLine(); System.out.println(&quot;请输入 学生年龄：&quot;); String age = sc.nextLine(); System.out.println(&quot;请输入 学生地址：&quot;); String address = sc.nextLine(); //创建学生对象 Student s = new Student(); s.setId(id); s.setAge(age); s.setName(name); s.setAddress(address); // 把学生对象添进 集合 array.add(s); System.out.println(&quot;学生信息添加成功====姓名为： &quot;+s.getName()); &#125; public static void delStudent(ArrayList&lt;Student&gt; array)&#123; //根据学号删除 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入要删除学生的学号：&quot;); String id = sc.nextLine(); // 定义一个索引 int index = -1; //遍历集合 for (int i = 0; i &lt;array.size() ; i++) &#123; //获取每个学生的对象 Student s = array.get(i); if (s.getId().equals(id))&#123; // array.remove(i); // 根据索引删除 index = i; break; &#125; // System.out.println(&quot;删除学生成功！&quot;); &#125; if (index == -1)&#123; System.out.println(&quot;不好意思，您输入的学号不存在，请重新输入&quot;); &#125;else &#123; array.remove(index); // 根据索引删除 System.out.println(&quot;删除学生成功&quot;); &#125; &#125; // 修改学生 public static void updataStudent(ArrayList&lt;Student&gt; array)&#123; // 创建键盘录入对象 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入你要修改学生的学号：&quot;); String id = sc.nextLine(); // 定义一个索引 int index = -1; for (int i = 0; i &lt;array.size() ; i++) &#123; //获取每一个学生对象 Student s = array.get(i); if (s.getId().equals(id))&#123; index = i; break; &#125; &#125; if (index == -1)&#123; System.out.println(&quot;不好意思，你要修改的学生信息不存在，请重新你的选择&quot;); &#125;else &#123; System.out.println(&quot;请输入学生新姓名：&quot;); String name = sc.nextLine(); System.out.println(&quot;请输入学生新年龄：&quot;); String age = sc.nextLine(); System.out.println(&quot;请输入学生新住址：&quot;); String address = sc.nextLine(); Student s = new Student(); s.setId(id); s.setName(name); s.setAddress(address); s.setAge(age); // 修改集合中的学生信息 array.set(index, s); System.out.println(&quot;修改学生信息成功&quot;); &#125; &#125; &#125; 5、IO字符流 IO流用来处理设备之间的数据传输 文件复制，上传、下载文件 IO流分类 输出流 FileWriter 输入流 FileReader 常见的换行符： Windows \\r\\n Linux \\n Mac \\r 5.0、写数据package myIo; import java.io.FileWriter; import java.io.IOException; /** * Created by JackFeng on 2020/3/8. */ /* * 需求： 往文件中写数据 * * 写数据 -- 输出流 ---FileWriter * * * */ public class FileWriterDemo &#123; public static void main(String[] args) throws IOException &#123; // 创建输出流对象 // 调用系统资源创建一个文件,创建输出流对象，把输出流对象指向文件 // 不写路径 就会在 在相对路径下创建！ // FileWriter fw = new FileWriter(&quot;D:\\\\Practice\\\\Java\\\\JavaSE\\\\a.txt&quot;); // 默认为false FileWriter fw = new FileWriter(&quot;D:\\\\Practice\\\\Java\\\\JavaSE\\\\a.txt&quot;,true); // true 为追加写入 // 写字符串数据 // fw.write(&quot;IO你好&quot;); // 数据没有直接写入 到文件中， 其实是写到了内存缓冲区 // fw.flush(); // 刷新缓冲区 // 释放资源 通知系统释放和该文件相关的资源 // 写数据的几种方法 /* * 1、write(String str) 写一个字符串数据 * * */ // 1 // fw.write(&quot;abcde&quot;); //2 // fw.write(&quot;abcd&quot;,1,2); // 3 // fw.write(97); // 4 写一个数组 // char[] chs = &#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;&#125;; // fw.write(chs); // 5 // fw.write(chs, 0, 1); // 数据换行 + 数据追加写入 // \\n 可以换行，windows 没有换行 ，\\r\\n for (int i = 0; i &lt; 10 ; i++) &#123; fw.write(&quot;Hi&quot;+i); fw.write(&quot;\\r\\n&quot;); &#125; fw.close(); // 先刷新缓冲区。再通知系统释放资源 &#125; &#125; 5.1、读数据package myIo; import java.io.FileReader; import java.io.IOException; /** * Created by JackFeng on 2020/3/8. */ public class FileReaderDemo &#123; public static void main(String[] args) throws IOException &#123; // 创建输入流 对象 FileReader fr = new FileReader(&quot;D:\\\\Practice\\\\Java\\\\JavaSE\\\\a.txt&quot;); /* // 读数据方法 // 1. int read() // 第一次读数据 int ch = fr.read(); System.out.println(ch); System.out.println((char)ch); // 第二次 ch = fr.read(); System.out.println(ch); System.out.println((char)ch); // 如果读取数据的返回值 是 -1的时候 说明结束了*/ // 标准代码 // 读取 字符串 /* int ch; while ((ch=fr.read())!= -1)&#123; // System.out.println(ch); System.out.print((char)ch); &#125;*/ //第二种读取数据方式 一次读取一个数组的数据 // 标准代码 效率较高 // char[] chs = new char[5]; char[] chs = new char[1024]; // 一般写1024 及其整数倍 int len; while ((len= fr.read(chs)) != -1)&#123; System.out.print(new String(chs,0,len)); // 以数组方式读入 &#125; fr.close(); // 释放资源 &#125; &#125; 5.2、文件复制package myIo; import java.io.FileReader; import java.io.FileWriter; import java.io.IOException; /** * Created by JackFeng on 2020/3/8. */ public class CopyFileDemo &#123; public static void main(String[] args) throws IOException &#123; // 创建输入刘对象 FileReader fr = new FileReader(&quot;D:\\\\Practice\\\\Java\\\\JavaSE\\\\src\\\\myIo\\\\FileWriterDemo.java&quot;); // 创建输出流对象 FileWriter fw = new FileWriter(&quot;Copy.java&quot;); //读写数据 /* int ch; while ((ch=fr.read())!=-1)&#123; fw.write(ch); &#125;*/ char[] chs = new char[1024]; int len; while ((len= fr.read(chs))!= -1)&#123; fw.write(chs,0,len); &#125; fr.close(); fw.close(); &#125; &#125; 5.3、字符缓冲流BufferedWriter —- 高效写入 BufferedReader — 高效读取 不是直接传入文件，而是传入 FileWriter 特殊功能 BufferedWriter Void newLine() —- 写一个换行符，这个换行符由系统决定的 BufferedReader String readLine() —- 一次读取一行数据,但是不读取换行符 package myIo; import java.io.*; /** * Created by JackFeng on 2020/3/8. */ public class BufferedDemo &#123; public static void main(String[] args) throws IOException &#123; // 创建输出缓冲流对象 BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;a.txt&quot;)); bw.write(&quot;hello world&quot;); // bw.flush(); for (int i = 0; i &lt; 10 ; i++) &#123; bw.write(&quot;Hi&quot;+i); // bw.write(&quot;\\r\\n&quot;); bw.newLine(); // 等同于 bw.write(&quot;\\r\\n&quot;); &#125; bw.close(); // 创建输入缓冲流对象 BufferedReader br = new BufferedReader( new FileReader(&quot;a.txt&quot;)); // 一次写一个字符 /* int ch; while ((ch=br.read())!= -1)&#123; System.out.print((char) ch); &#125;*/ // 一次读写一个数组 /* char[] chs = new char[1024]; int len; while ((len = br.read(chs))!= -1) // System.out.print(chs,0,len); 这里会报错 需要 new String 构造 System.out.println(new String(chs,0,len)); br.close();*/ String line; // br.readLine while((line= br.readLine())!=null)&#123; System.out.println(line); &#125; br.close(); &#125; &#125; 集合数据写入文件 package myIo; import java.io.BufferedWriter; import java.io.FileWriter; import java.io.IOException; import java.util.ArrayList; /** * Created by JackFeng on 2020/3/8. */ public class ArrayListToFileTest &#123; public static void main(String[] args) throws IOException &#123; // 创建集合对象 ArrayList&lt;String&gt; array = new ArrayList&lt;&gt;(); // 给集合添加元素 array.add(&quot;hello&quot;); array.add(&quot;world&quot;); array.add(&quot;今天是2020，三八妇女节&quot;); // 创建缓冲流输出对象 BufferedWriter bw = new BufferedWriter( new FileWriter(&quot;array.txt&quot;)); //遍历集合写入到文件 for (int i = 0; i &lt;array.size() ; i++) &#123; String s = array.get(i); bw.write(s); bw.newLine(); // 读取换行 bw.flush(); &#125; bw.close(); &#125; &#125; 文件存入集合 package myIo; import java.io.BufferedReader; import java.io.FileReader; import java.io.IOException; import java.util.ArrayList; /** * Created by JackFeng on 2020/3/8. */ public class FileToArrayList &#123; public static void main(String[] args) throws IOException &#123; // 创建输入缓冲流对象 BufferedReader br = new BufferedReader(new FileReader(&quot;array.txt&quot;)); // 创建集合对象 ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;(); // 读取数据 每次读取一行数据， 把该行数据作为一个元素存储到集合中 String line; while ((line = br.readLine())!= null)&#123; array.add(line); &#125; br.close(); //遍历集合 for (int i = 0; i &lt;array.size() ; i++) &#123; String s = array.get(i); System.out.println(s); &#125; &#125; &#125; 学生管理添加升级版本 package myIo; import myStudentManager.Student; import java.io.BufferedWriter; import java.io.FileWriter; import java.io.IOException; import java.util.ArrayList; import java.util.Scanner; /** * Created by JackFeng on 2020/3/8. */ public class ArratListToFileTest &#123; public static void main(String[] args) throws IOException &#123; ArrayList&lt;Student&gt; array = new ArrayList&lt;&gt;(); // 写方法添加学生对象 addStudent(array); addStudent(array); addStudent(array); // 创建输出缓冲流对象 BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;std.txt&quot;)); for (int i = 0; i &lt;array.size() ; i++) &#123; Student s = array.get(i); // 链式编程 /// 姓名,年龄,。。。 采用 StringBuilder StringBuilder sb = new StringBuilder(); sb.append(s.getId()).append(&quot;,&quot;).append(s.getName()).append(&quot;,&quot;).append(s.getAddress()).append(&quot;,&quot;).append(s.getAge()); bw.write(sb.toString()); // 转化为string bw.newLine(); // 换行 bw.flush(); // 刷新 &#125; bw.close(); &#125; // 添加学生 public static void addStudent(ArrayList&lt;Student&gt; array)&#123; //创建键盘录入对象 Scanner sc = new Scanner(System.in); // id 定义在外边 因为下边还要用 String id; // 代码重复使用 while (true)&#123; System.out.println(&quot;请输入 学生ID：&quot;); // String id = sc.nextLine(); id = sc.nextLine(); //判断学号是否存在 // 定义标记默认为false boolean flag = false; for (int i = 0; i &lt;array.size() ; i++) &#123; Student s = array.get(i); if (s.getId().equals(id))&#123; flag = true; // 说明学号被占用 &#125; &#125; if (flag)&#123; System.out.println(&quot;你输入的学号已经被占用&quot;); &#125;else &#123; break; &#125; &#125; System.out.println(&quot;请输入 学生姓名：&quot;); String name = sc.nextLine(); System.out.println(&quot;请输入 学生年龄：&quot;); String age = sc.nextLine(); System.out.println(&quot;请输入 学生地址：&quot;); String address = sc.nextLine(); //创建学生对象 Student s = new Student(); s.setId(id); s.setAge(age); s.setName(name); s.setAddress(address); // 把学生对象添进 集合 array.add(s); System.out.println(&quot;学生信息添加成功====姓名为： &quot;+s.getName()); &#125; &#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/tags/Java/"}]},{"title":"Java面向对象(封装)","slug":"Java/JavaSE/Java面向对象-封装","date":"2020-05-07T15:54:34.000Z","updated":"2021-01-24T13:53:54.819Z","comments":true,"path":"posts/8589.html","link":"","permalink":"http://www.a2data.cn/posts/8589.html","excerpt":"Java面向对象 封装！","text":"Java面向对象 封装！ 面向对象（封装） 面向对象思想： 面向对象是基于面向过程的编程思想。 面向过程：强调每一个功能的步骤 面向对象：强调的是对象，然后用对象去调用功能 特点 A:符合我们思考习惯的思想 B:可以将复杂的事情简单化 C:执行者—-指挥者 类和对象 A：属性 —- 就是事物的描述信息 B：行为 —- 事物能够做什么 类：一组相关属性和行为的集合 对象： 就是该事物的具体体现 成员变量 位置： 类中，方法外 初始化值：不需要 成员方法 去掉static 关键字 Phone package myTest; /** * Created by JackFeng on 2020/3/2. */ public class Phone &#123; String barnd; int price; String color; public void call(String name) &#123; System.out.println(&quot;给&quot; + name + &quot;打电话&quot;); &#125; public void sendMessage()&#123; System.out.println(&quot;给所有人群发短信&quot;); &#125; &#125; PhoneDemo package myTest; /** * Created by JackFeng on 2020/3/2. */ public class PhoneDemo &#123; public static void main(String[] args) &#123; Phone p = new Phone(); System.out.println(p.barnd + &quot;---&quot; +p.price+ &quot;----&quot;+p.color); p.barnd = &quot;iphone&quot;; p.price = 8888; p.color = &quot;金色&quot;; System.out.println(p.barnd + &quot;---&quot; +p.price+ &quot;----&quot;+p.color); p.call(&quot;DataScience&quot;); p.sendMessage(); &#125; &#125; 成员变量和局部变量的区别 区别： A: 在类中的位置不同 成员变量：类中，方法外 局部变量：方法中或者方法声明上(形式参数) B：在内存中的位置不同 成员变量：堆内存 局部变量：栈内存 C：生命周期不同 成员变量：随着对象的创建而存在，随着对象的消失而消失 局部变量：随着方法的调用而存在，随着方法调用完毕而消失 D：初始化值的问题 成员变量：有默认值 局部变量：没有默认值，必须先定义，赋值，最后使用 package myTest; /** * Created by JackFeng on 2020/3/2. */ public class Variable &#123; // 成员变量 int x; public void show ()&#123; //局部变量 // int y; // 如果y 没有值 就会报错 int y = 1; // 赋值就会不报错 System.out.println(y); // 调用x 有默认值 System.out.println(x); &#125; &#125; 标准学生类代码 package myTest; /** * Created by JackFeng on 2020/3/2. */ public class StudentDemo &#123; public static void main(String[] args) &#123; // 无参 + set方法 Student s = new Student(); s.setName(&quot;Data&quot;); s.setAge(26); System.out.println(s.getName()+&quot;====&quot;+s.getAge()); // 带参构造 Student s2 = new Student(&quot;DataScinece&quot;, 26); System.out.println(s2.getName()+&quot;====&quot;+s2.getAge()); &#125; &#125; 学生类 package myTest; /** * Created by JackFeng on 2020/3/2. */ public class Student &#123; private String name; private int age; // 构造方法 // 无参数 public Student()&#123;&#125; // 有参数 public Student(String name, int age )&#123; this.name = name; this.age = age; &#125; // get set 方法 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; &#125; 类名 如果类名作为形式参数传递 要的是该类的对象 如果类名作为返回值类型 返回的是该类的对象","categories":[{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/tags/Java/"}]},{"title":"Java基础语法","slug":"Java/JavaSE/Java基础语法","date":"2020-05-07T15:54:10.000Z","updated":"2021-01-24T13:53:55.758Z","comments":true,"path":"posts/34708.html","link":"","permalink":"http://www.a2data.cn/posts/34708.html","excerpt":"Java基础语法","text":"Java基础语法 1、基础语法Hello Wolrd 首先定义类 —— public class 类名 在类定义之后加上一对大括号 —— {} 在大括号中间添加一个主(main)方法/函数 —— public static void main(String[] args){} 在主方法的大括号中间添加一行输出语句 —— System.out.println(“Hello World”) 完整代码 public class HelloWorld&#123; public class static void main(String[] args)&#123; System.out.println(&quot;Hello World!&quot;) &#125; &#125; Javac —— 编译 javac HelloWorld.java Java + HelloWorld 运行 初学者注意事项 单词拼写问题 — class &gt; Class — String &gt; string — System &gt; system — main &gt; mian 中文符合问题 — 提示非法字符 1.1、Java入门1.1.0、注释 注释 // #单行注释 /*…*/ #多行注释 /...*/ #文本注释 JAVA 语句用 ； 分号结束。 命名 A、类：首字母大写 B、方法/函数：首字母小写第二个单词首字母大写 C、变量： 首字母小写第二个单词首字母大写 D、常量：全部字母大写 标识符程序员对程序中的各个元素加以命名时，使用的命名记号，称为标识符。 标识符以字母 下划线（__） 美元符（$）开始的一个字符序列， 后可跟 字母，下划线，美元符，数字。 1.1.1、关键字 JAVA关键字(保留字）* abstract default if private this boolean do implements protected throw break double impor public throws byte else instanceof return transient case extends int short try catch final interface statictfp volatile char finally long strictfp volatile class float native super while const for new switch null continue goto package synchronized 1.1.2、常量 常量：程序执行中，值不可发生改变 变量：在程序执行中，值会发生变化 常量分类 —— A： 字符串常量 ‘DataScience’ —— B： 整数常量 123 —— C： 小数常量 1.23 —— D： 字符常量 ‘a’,’1’ —— E： 布尔常量 true ,false—— F： 空常量 （null、’’) public class CL&#123; public static void main(String[] args)&#123; // 字符串常量 System.out.println(&quot;DataScience&quot;) // 整数常量 System.out.println(123) // 小数常量 System.out.println(1.23) // 字符串量 System.out.println(&quot;Data&quot;) // 布尔常量 System.out.println(true) &#125; &#125; 1.1.3、变量 变量的申明： 访问[修饰符] 数据类型 变量名称=初始值 变量的分类：1、按照声明位置： 成员变量： 类的内部，方法的外部定义的变量 局部变量： 方法或代码块的内部定义的变量 区别： 成员变量有默认初始值，局部变量没有 成员变量的作用域在整个类的内部，局部变量在当前方法或代码块中 变量实例： /** * Created by JackFeng on 2019/8/28. */ /* * 常量: 在程序的执行过程中，其值不可以发生改变的量 * * 常量的分类： * A： 字符串常量 * B： 整数常量 * C： 小数常量 * D： 字符常量 * E： 布尔常量 true ,false * F： 空常量 * * */ public class Variable &#123; public static void main(String[] args) &#123; // A System.out.println(&quot;欢迎关注公众号DataScience&quot;); // B System.out.println(12); System.out.println(-66); // C System.out.println(23.56); //D System.out.println(&#39;a&#39;); // E System.out.println(true); &#125; &#125; 1.1.4、数据类型 数据类型 —— Java是强类型语言，针对每一种数据都给出了明确的数据类型。 数据类型分类： A：基本数据类型 B：引用数据类型 （类、接口、数组） 基本数据类型（以及占用字节数） A、整数 byte 1 short 2 int 4 long 8 B、浮点数 float 4 double 8 C、字符 char 2 D、布尔 boolean 1 注意 A：整数默认是int类型，浮点数默认是double类型 B： 定义long类型数据的时候，要加L或者l，建议加L 定义float类型数据的时候，要加F或者f，建议加F 整型变量 类型 占用储存空间 表数范围 byte 1字节 -128~127 short 2字节 -2^15~2^15-1 int 4字节 -2^31~2^31-1 long 8字节 -2^63~2^63-1 浮点型变量 类型 占用储存空间 表数范围 float 4字节 -3.403E38~3.403E38 double 8字节 -1.798E308~1.798E308 字符型变量： char 一个字符2字节 布尔型变量： true false 符号常量 final 变量类型 变量名=初始化值 值常量整型常量、浮点型常量、符号型常量、字符串常量、布尔型常量（true false） 空常量 转义字符 含义 \\b 退格（backspace） \\t 水平制表（Tab） \\f 走纸换页，只对打印有效 \\n 换行 \\r 回车 \\ 反斜杠字符 &#39; 单引号字符 &quot; 双引号字符 \\ddd 1–3位八进制数所代表的ASCII字符 \\uxxxx 1-4位十六进制数所代表的unicode字符 1.1.5、 计算机存储单元 bit(比特位) —–字节（byte） 单位换算： 1B(字节) = 8it 1KB = 1024B 1MB = 1024KB 1GB = 1024MB 1TB = 1024GB 1PB = 1024TB 1ZB = 1024PB 1.1.6、标识符标识符： 包、类、方法、变量 等起名字的符号 组成规则： A：unicode 字符 数字字符，英文大小写字母，汉字（不建议使用汉字） B：下划线 _ C：美元符 $ 注意事项： A: 不能以数字开头 B：不能是Java中的关键字 常见命名规则： A：基本要求 见名知意 B：常见的命名 1、包（其实就是文件夹，用于对类进行管理） 全部小写，多级包.隔开 EG: com， com.datascience 2、类 单个单词首字母大写 EG:Dog 多个单词首字母大写 EG:BigDog 3、方法和变量 单个单词首字母小写 EG： dog 多个单词组成第二个开始首字母大写 EG: bigDog,maxAge 1.1.7、运算符优先级 优先级 运算符 结合性 1 （） [ ] . 从左向右 2 ！ +（正） -（负） ~ ++ – 从右向左 3 / * % 从左向右 4 + (加) -（减） 从左向右 5 《 》 &gt;&gt;&gt; 从左向右 6 &lt;&lt;=&gt;&gt; instanceof 从左向右 7 == ！= 从左向右 8 &amp; （按位与） 从左向右 9 ^ 从左向右 10 | 从左向右 11 &amp;&amp; 从左向右 12 || 从左向右 13 ?: 从右向左 14 = += -= *= /= %= &amp;= |= ^= ~= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;= 从右向左 1.2、基本类型数据转换1.2.1、定义变量变量格式： 数据类型 变量名 = 初始化值 数据类型： byte,short,int,long,float,double,char,boolean Demo public class VariableDemo &#123; /* * 变量的定义 * */ public static void main(String[] args)&#123; // 定义byte 类型 byte a = 10; System.out.println(10); System.out.println(a); // 定义 short类型 short b = 11; System.out.println(b); // 定义int类型 int c = 12; System.out.println(c); // 定义long类型 long d = 1231L; System.out.println(d); // 定义float类型 float e = 1.23F; System.out.println(e); // 定义double类型 double f = 1.23; System.out.println(f); // 定义char类型 char g = &#39;a&#39;; System.out.println(g); // 定义boolean类型 boolean h = true; System.out.println(h); &#125; &#125; 1.2.2、变量定义的注意事项package one; /** * Created by JackFeng on 2020/2/22. */ public class BianLiang &#123; /* * 变量定义的注意事项 * A: 变量未赋值，不能直接使用 * B：变量只在所属的范围内有效（仅在它所在的大括号中有效） * C: 一行可以多个变量（不建议） * */ public static void main(String[] args)&#123; // 定义变量aa、 int aa = 2020; System.out.println(aa); &#123; // 大括号中的就是代码块 int ab = 131; System.out.println(ab); &#125; // 定义多个变量 int a1, a2; a1 =11; a2 = 20; System.out.println(a1); System.out.println(a2); &#125; &#125; 1.2.3、类型转化package one; /** * Created by JackFeng on 2020/2/25. */ /* * +: 加法运算符 * * 运算中，要求参与运算的数据类型必须一致 * * * 类型转化： * 隐式转化 * 强制转化 * 隐式转化： * byte,short,char -- int --long --float --double * byte+ int === int 类型 * 强制转化： * 目标类型 变量名 = （目标类型）（被转化的数据） * 建议：数据做运算，最好以结果类型为准（不要随意转化，否则可能损失精度） * int a = 10; * byte b = 20; * int c = a+b * * byte d = (byte)(a + b) * * * */ public class TypeCastDemo &#123; public static void main(String[] args) &#123; // 1、 定义同类型变量 int a = 11; int b = 22; int c = a + b; System.out.println(c); // 定义一个 byte 类型 一个int类型 int a1 = 10; byte a2 = 20; System.out.println(a1+a2); &#125; &#125; 1.2.4、运算符1.2.4.1、运算符 运算符： 用于 常量和变量操作的符号 表达式：用运算符号链接起来符合java语法的句子 ​ EG: a,b a+b 1.2.4.2、运算符分类1、算术运算符 +，-，*，/ ，%，++，– *+，-，，/** // +,-,*,/ 使用 // 定义变量 int a = 3; int b = 4; System.out.println(a+b); System.out.println(a-b); System.out.println(a*b); System.out.println(a/b); // 整数相除 只能得到整数，要想得到小数 必须有浮点数参与运算 System.out.println(3.0/4); System.out.println(3/4.0); % (取余) *%*：用于获取 两个数据相除时候的余数 */*： 用于获取 两个数据相除时候的商 int a1=3; int a2=5; System.out.println(a2/a1); System.out.println(a2%a1); + +： 加法运算 正常加法运算 int a =10; int b = 12; 字符参与加法运算，是拿字符在计算机中存储的数据值来参与运算的 “A” 65 ‘a’ 97 ‘0’ 48 字符串参与加法运算，其实不是做加法，而是字符串的拼接 例如： int a =1; int b =2; System.out.println(“hello”+a) hello1 System.out.println(a+b+”hello”) ​ 3hello 注意 执行顺序（会对结果产生影响）： 从左–&gt;右 ++，– ++，– ： 自增自减，用于对变量+1 或 -1 单独使用： 放在变量前后都可以，结果一样 其它操作： ++ 在后边，先拿变量做操作，然后变量再++ ++ 在前边，先变量++，再拿变量做操作 package myOperator; /** * Created by JackFeng on 2020/2/25. */ /* * ++ -- : 自增自减 * * */ public class OpeartorDemo1 &#123; public static void main(String[] args) &#123; // 定义变量 int a = 123; System.out.println(&quot;a:&quot;+a); // ++ int b = a++; System.out.println(&quot;a:&quot;+a); System.out.println(&quot;b:&quot;+b); int c = ++a; System.out.println(&quot;a:&quot;+a); System.out.println(&quot;c:&quot;+c); &#125; &#125; 2、赋值运算符 赋值运算符： 基本赋值运算符：= 扩展赋值运算符：+=，-=，*=，/=,….. package myOperator; /** * Created by JackFeng on 2020/2/25. */ /* * 赋值运算符： * 基本的赋值运算符： = * 扩展的赋值运算符： +=，-=，*=，/= ... * * */ public class OpeartorDemo2 &#123; public static void main(String[] args) &#123; // 定义变量 int a = 25; // 把 25 赋值给int 类型的变量a // += 操作 // 拿+= 左边和右边的数据做 加法，然后赋值给左边 a += 5; System.out.println(a); // 注意： 扩展的赋值运算符,隐含了 强制类型转换 // 有一个变量 a, a+=5; // 相当于： a=(a的数据类型)(a+5) short s = 1; s += 1; System.out.println(s); &#125; &#125; 3、关系运算符 关系运算符： ==， !=，&gt;,&gt;=,&lt;,&gt;= 关系运算符结果是 boolean类型.（false/true） 注意事项： 不要把两个== 写成 = （除非你赋值） 4、逻辑运算符 逻辑运算符： 释义：用于链接关系表达式 逻辑运算分类： &amp;，|，^,! &amp;&amp;, || &amp;（或） 有false 则false |（与） 有true则true ^（异或） 相同则false，不同则true ！（非） true则false，false 则 true &amp;&amp; &amp;&amp; 和 &amp; 的结果一样 &amp;&amp; 与 &amp; 的区别： &amp;&amp; 有短路效果，左边为false，右边不执行 &amp; 左边无论是什么，右边都会执行 || || 和 | 的结果一样 || 与 | 的区别： || 左边为true ，右边不执行 | 左边无论是啥，右边都执行 5、三元运算符 三元运算符： 关系表达式？表达式1：表达式2 执行流程： A： 计算关系表达式的值（true/false） B: 结果展示 如果是true，表达式1就是结果 如果是false，表达式2就是结果 // 三元运算符 int aa = 10; int bb = 20; int cc = (aa &gt; bb) ? aa : bb; System.out.println(&quot;====&quot;); System.out.println(&quot;cc&quot;+cc); //输出 ==== cc:20 案例：取三个数中的最大值 // 获取三个数的最大值 int q = 11; int w = 12; int e = 22; // 先获取两个数据的最大值,然后再和第三个数据比较即可 int temp = (q &gt; w) ? q : w; int max = (temp &gt; e) ? temp : e; System.out.println(&quot;+++++++++&quot;); System.out.println(&quot;max:&quot;+max); 1.2.5、键盘录入package myScanner; /** * Created by JackFeng on 2020/2/25. */ /* * * 键盘录入： * 如何实现？ JDK提供的类Scanner * 使用步骤： * A: 导包 * import java.util.Scanner; * 在一个类中顺序： package &gt; import &gt; class * B: 创建键盘录入对象 * Scanner sc = new Scanner(System.in) * C: 接受数据 * int i = sc.nextInt(); * * * * */ import java.util.Scanner; public class ScannerDemo &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入数据： &quot;); int i = sc.nextInt(); System.out.println(&quot;i:&quot;+i); &#125; &#125; 录入数据求和 // 录入数据 并且求和 System.out.println(&quot;请输入第一个数据： &quot;); int aa = sc.nextInt(); System.out.println(&quot;请输入第二个数据： &quot;); int bb = sc.nextInt(); // 数据求和 int sum = aa + bb; System.out.println(&quot;sum:&quot;+sum); // 比较两个数据是否相等 // boolean flag = (aa == bb) ? true : false; boolean flag = (aa == bb); System.out.println(flag); // 录入三个数据,三个数据的最大值 System.out.println(&quot;请输入第三个数据： &quot;); int cc = sc.nextInt(); int temp = (aa &gt; bb) ? aa : bb; int max = (temp&gt;cc)?temp:cc; System.out.println(&quot;max:&quot;+max); 1.2.6、流程控制语句顺序结构 从上往下，依次执行！ 选择结构 if语句： if(关系表达式){ ​ 语句体 } 执行流程 A: 首先计算关系表达式的值，看是true/false B: 如果是true，就执行语句体 C: 如果是False，则不执行 // if 关系表达式 int a = 10; int b = 20; if(a==b)&#123; System.out.print(&quot;a=b&quot;) &#125; int c = 10; if(a==c)&#123; System.out.println(&quot;a=c&quot;) &#125; if(关系表达式){ ​ 语句体1; }else{ ​ 语句体2; } // 判断一个数 是偶数还是奇数 int a = 100; // 重新给a赋值 a = 99; if(a%2 ==0)&#123; System.out.println(&quot;a为偶数&quot;); &#125;else&#123; System.out.println(&quot;a为奇数&quot;); &#125; if(关系表达式1){ ​ 语句体1; }else if(关系表达式2){ ​ 语句体2; } … else{ ​ 语句体n+1; } // 多个if 表达式 int x = 10; int y; if (x &gt;= 3)&#123; y = 2 * x + 1; &#125; else if (x &gt;= -1 &amp;&amp; x&lt;3)&#123; y = 2 * x; &#125;else if (x &lt;= -1)&#123; y = 2 * x - 1; &#125;else &#123; y = 0; System.out.println(&quot;不存在x&quot;); &#125; System.out.println(&quot;y&quot;+y); 键盘录入案例比较 // 键盘录入判断最大值 Scanner sc = new Scanner(System.in); System.out.println(&quot;1:&quot;); int a = sc.nextInt(); System.out.println(&quot;2: &quot;); int b = sc.nextInt(); // 常规比较 if (a &gt; b) &#123; System.out.println(&quot;最大值是：&quot;+a); &#125;else &#123; System.out.println(&quot;最大值是：&quot;+b); &#125; // 用一个变量值接受 int max; if (a &gt; b) &#123; max = a; System.out.println(&quot;max：&quot;+max); &#125;else &#123; max = b; System.out.println(&quot;max：&quot;+max); &#125; // 对变量max 做操作 max = max + 100; System.out.println(max); 1.2.7、选择结构语句switch package myOperator; import java.util.Scanner; /** * Created by JackFeng on 2020/2/26. */ /* * switch语句格式： * switch (表达式)&#123; * case 值1： * 语句体1; * case 值2： * 语句体2; * ... * default: * 语句体n+1; * break; * * &#125; * * * * */ public class SwitchDemo &#123; public static void main(String[] args) &#123; /* * 格式解释： * 表达式： byte，short，int，char * jdk5 以后 可以是枚举 * jdk7 以后 可以是字符串 * case后边的值：就是用来和表达式的值进行匹配的内容 * break：表示中断的意思 * default： 所有值都不匹配的时候（相当于else） * * */ // 键盘录入 1-7 判断星期几 Scanner sc = new Scanner(System.in); // 接受数据 System.out.println(&quot;请输入数字 1-7:&quot;); int weekday = sc.nextInt(); switch (weekday)&#123; case 1: System.out.println(&quot;星期一&quot;); break; case 2: System.out.println(&quot;星期二&quot;); break; case 3: System.out.println(&quot;星期三&quot;); break; case 4: System.out.println(&quot;星期四&quot;); break; case 5: System.out.println(&quot;星期五&quot;); break; case 6: System.out.println(&quot;星期六&quot;); break; case 7: System.out.println(&quot;星期天&quot;); break; default: System.out.println(&quot;你输入的数据有误&quot;); break; &#125; &#125; &#125; 1.2.8、循环结构语句1.2.8.1、forpackage myOperator; /** * Created by JackFeng on 2020/2/26. */ /* * for循环语句的格式： * for(初始化语句;判断条件语句;控制条件语句）&#123; * 循环体语句： * * &#125; * * */ public class ForDemo &#123; public static void main(String[] args) &#123; // 输出10次 hello for (int i=1;i&lt;=10;i++)&#123; System.out.println(&quot;hello&quot;+i); &#125; // 获取 1-5 for (int x =1 ;x &lt;=5;x++)&#123; System.out.println(&quot;-----&quot;); System.out.println(x); &#125; // 获取 5-1 for (int x = 5; x &gt;= 1; x--) &#123; System.out.println(&quot;======&quot;); System.out.println(x); &#125; // 1-5 求和 //初始化值为0 int sum = 0; for (int x =1;x&lt;=5;x++)&#123; sum = sum + x; // sum += x; System.out.println(&quot;累加值为:&quot;+sum); &#125; System.out.println(&quot;sum&quot;+sum); &#125; &#125; 1-100 偶数和 // 结果：2550 int s = 0; for (int x =1;x&lt;=100;x++)&#123; if (x%2 ==0)&#123; s += x; &#125; &#125; System.out.println(&quot;1-100偶数求和为：&quot;+s); 水仙花 //经典案例 水仙花数 // EG: 153 // 个位： 153%10 // 十位： 153/10%10 // 百位： 153/10/10%10 int count = 0; for (int x=100;x&lt;=999;x++)&#123; int gw =x % 10; int sw =x/10 % 10; int bw =x/10/10 % 10; if ((gw*gw*gw +sw*sw*sw + bw*bw*bw )==x)&#123; System.out.println(x); count++; //统计次数 &#125; &#125; //输出统计值 System.out.println(count); 1.2.8.2、whilepackage myOperator; /** * Created by JackFeng on 2020/2/26. */ public class WhileDemo &#123; public static void main(String[] args) &#123; // 输出10次 你好 // for 实现 for (int i =1;i&lt;=10;i++)&#123; System.out.println(&quot;你好&quot;); &#125; // while 实现 int s = 1; while (s&lt;=10)&#123; System.out.println(&quot;Nihao&quot;); s++; &#125; &#125; &#125; 1.2.8.3、do…whilepackage myOperator; /** * Created by JackFeng on 2020/2/26. */ public class DoWhileDemo &#123; public static void main(String[] args) &#123; // 输出10次 HI for (int i =1;i&lt;=10;i++)&#123; System.out.println(&quot;Hi&quot;); &#125; // do while 改写 int x = 1; do &#123; // 循环体语句 System.out.println(&quot;HI hi&quot;); // 控制条件语句 x++; &#125; // 判断体语句 while (x &lt;= 10); &#125; &#125; 1.2.8.4、 三种循环语句区别 A: do…while 循环至少执行一次循环体 B: for和 while 必须判断条件成立才执行循环体 package myOperator; /** * Created by JackFeng on 2020/2/26. */ public class XunDemo &#123; public static void main(String[] args) &#123; int x = 3; while(x &lt;3)&#123; System.out.println(&quot;while 循环体&quot;); x++; &#125; int y = 3; do &#123; System.out.println(&quot; do while 循环ti &quot;); y++; &#125; while (y &lt; 3); &#125; &#125; for 和 while 区别 for循环结束后，初始化变量不可被使用。 while 循环结束后，初始化变量可以被使用。 推荐使用顺序： for while do…while // for 和 while 的区别 public static void main(String[] args) &#123; //for for (int i = 0; i &lt;5 ; i++) &#123; System.out.println(&quot;这里是for循环&quot;); &#125; // System.out.println(&quot;i:&quot;+i); 这里是调用不了的 //while int x =0; while (x&lt;5)&#123; System.out.println(&quot;while循环&quot;); x++; &#125; System.out.println(&quot;x:&quot;+x); &#125; 1.2.9、跳转控制语句Break（中断） break：中断 使用场景： A：switch语句中 B：循环中 注意： 离开场景，将无意义。 作用： 用于结束循环 package com.data.it; /** * Created by JackFeng on 2020/3/1. */ public class BreakDemo &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt;4 ; i++) &#123; System.out.println(&quot;这是个正常的循环&quot;); &#125; System.out.println(&quot;============&quot;); for (int i = 0; i &lt;4 ; i++) &#123; if (i==1)&#123; break; &#125; System.out.println(&quot;这是加入break控制的循环&quot;); &#125; &#125; &#125; Continue（继续） continue：继续 使用场景： 循环中 作用： 结束一次循环，进入下一次循环。 package com.data.it; import java.sql.SQLOutput; /** * Created by JackFeng on 2020/3/1. */ public class BreakAndContinueDemo &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt;=10 ; i++) &#123; // break:结束整个循环 if (i == 2)&#123; break; &#125; System.out.println(&quot;B And C&quot;); // continue 结束本次循环，继续下一次循环 if (i==3)&#123; continue; &#125; System.out.println(&quot;C === A&quot;); &#125; &#125; &#125; 1.3、Random Random：用于产生随机数 使用步骤： A：导包 import java.util.Random; B：创建对象 Random r = new Random(); C：获取随机数 int number = r.nextInt(10) 数据范围：[0,10) 包括0，但不包括10 package com.data.it; import java.util.Random; /** * Created by JackFeng on 2020/3/1. */ public class RandomDemo &#123; public static void main(String[] args) &#123; //创建对象 Random r = new Random(); // 获取随机数 int n = r.nextInt(10); System.out.println(&quot;n:&quot;+n); for (int i = 0; i &lt;10 ; i++) &#123; int num = r.nextInt(10); System.out.println(&quot;第&quot;+i+&quot;次随机数结果为：&quot;+num); &#125; // 如何获取100 - 1之间的随机数 int ii = r.nextInt(100);// [0,99] int T = r.nextInt(100)+1;// +1 即可 &#125; &#125; 猜数字游戏 package com.data.it; import java.util.Random; import java.util.Scanner; /** * Created by JackFeng on 2020/3/1. */ /* * 猜数字游戏： * 系统产生一个 1-100 的数字，猜出这个数字是多少 * * 分析： * A：系统产生一个1-100之间的随机数 * Random r = new Random(); * int number = r.nextInt(100)+1; * B: 键盘录入要猜的数据 * C: 比较这两个数据的大小 * 大了：提示大了 * 小了：提示小了 * 相等：猜中了 * D：多次猜数据，而我们不知道猜多少次？ * while(true)&#123;循环体语句&#125;; * * * */ public class RandomNumDemo &#123; public static void main(String[] args) &#123; // 产生1-100随机数 Random r = new Random(); // 获取随机数 int i = r.nextInt(100)+1; // 判断是否猜中 多次猜数据 // 录入的数据 要放在判断里 否则永远也猜不中 while (true) &#123; // 键盘录入 Scanner s = new Scanner(System.in); // 获取输入数据 System.out.println(&quot;请输入你要猜的数据：&quot;); int g = s.nextInt(); if (g&gt;i)&#123; System.out.println(&quot;你猜的&quot;+g+&quot;大了&quot;); &#125;else if (g&lt;i)&#123; System.out.println(&quot;你猜的&quot;+g+&quot;小了&quot;); &#125;else &#123; System.out.println(&quot;恭喜你猜中了&quot;); break; &#125; &#125; &#125; &#125; 1.4、数组 数组：存储同一种数据类型的多个元素的容器 取值： 数组名 【索引】 定义格式： A：数据类型[] 数组名；(推荐方式) B：数据类型 数组名[]; 案例： int[] arr; 定义int类型的数组，名称为 arr int arr[]；定义int类型的变量，变量名为arr数组 数组初始化： A：数组开辟内存空间，为数组中的每个元素赋值 B：数组初始的方式： a：动态初始化 只给出长度，系统给初始化值 b：静态初始化 给出初始值，由系统决定长度 动态初始化： 数据类型[] 数组名 = new 数据类型[数组长度]; 静态初始化： 数据类型[] 数组名 = new 数据类型[]{元素1,元素2….}; 简化格式： 数据类型[] 数组名 ={元素1，元素2,…} 动态初始化 package com.data.it; /** * Created by JackFeng on 2020/3/1. */ public class MyArrayDemo &#123; public static void main(String[] args) &#123; //数据类型[] 数组名 = new 数据类型[数组长度]; int[] arr = new int[3]; // 释义 /* * 左边： * int：说明数组中的元素类型是 int 类型 * []: 说明是个数组 * arr： 数组名称 * * 右边： * new ： 为数组申请内存分配空间 * int： 数组中的元素是int类型 * []： 数组 * 3： 数组的长度----数组中元素的个数 * */ //输出数组名 System.out.println(&quot;arr&quot;+arr); //[I@4554617c // 获取的是地址值，如何获取数组中的元素值 // 数组中的元素都是有编号的，从0 开始，最大编号是 数组的长度-1 // 索引 arr[0] // 取值： 数组名 配合 元素编号 // 访问格式：数组名[索引] System.out.println(arr[0]); //0 System.out.println(arr[1]); // 0 System.out.println(arr[2]); //0 // 赋值 arr[0] = 100; arr[2] = 200; System.out.println(&quot;=====&quot;); System.out.println(arr); // 001 System.out.println(arr[0]); //100 System.out.println(arr[1]); // 0 System.out.println(arr[2]); //200 // 指向一个数组 // arr1 数组 int[] arr1 = new int[3]; System.out.println(arr1); System.out.println(arr1[0]); System.out.println(arr1[1]); System.out.println(arr1[2]); int[] arr2 = arr1; arr1[0] =111; arr1[1] =222; arr1[2] =123; System.out.println(&quot;=============&quot;); System.out.println(arr1); System.out.println(arr1[0]); System.out.println(arr1[1]); System.out.println(arr1[2]); System.out.println(arr2); System.out.println(arr2[0]); System.out.println(arr2[1]); System.out.println(arr2[2]); &#125; &#125; 静态初始化 package com.data.it; /** * Created by JackFeng on 2020/3/1. */ public class ArraryDemo &#123; public static void main(String[] args) &#123; int[] arr = new int[]&#123;1,2,3&#125;; int[] arr1 = &#123;1, 2, 3&#125;; System.out.println(arr); System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); // System.out.println(&quot;----------&quot;); System.out.println(arr1); System.out.println(arr1[0]); System.out.println(arr1[1]); System.out.println(arr1[2]); &#125; &#125; 常见小问题 小问题： ArrayIndexOutOfBoundsException: 数组索引越界异常 原因 我们访问了不存在的索引 NullPointerException：空指针异常 原因 数组已经不在指向堆内存的数据了，还使用数组名去访问数组中的数据 数组遍历练习 package com.data.it; /** * Created by JackFeng on 2020/3/1. */ public class ArrayTest &#123; public static void main(String[] args) &#123; // 定义数组 int[] arr = &#123;1, 2, 3, 4, 5, 6&#125;; // 通过for循环遍历输出 ,调用 数组属性:length // 格式： 数组名.length for (int i = 0; i &lt;arr.length ; i++) &#123; System.out.println(arr[i]); &#125; &#125; &#125; 取最值 思路： A：先拿数组中的一个元素做参照物 B：遍历数组，让后边所有元素依次和参照物进行比较，如果元素比参照物大，就留下 C：整个循环遍历比较，留下的就是最大值 package com.data.it; /** * Created by JackFeng on 2020/3/1. */ public class ArrayTest1 &#123; public static void main(String[] args) &#123; // 取最大值 int[] arr = &#123;1, 2, 3, 55, 22, 10&#125;; // 定义一个参照值 int max = arr[0]; // 循环遍历整个数组 for (int i = 1; i &lt;arr.length ; i++) &#123; if (arr[i]&gt;max)&#123; max = arr[i]; &#125; &#125; System.out.println(&quot;最大值为：&quot;+max); &#125; &#125; 二维数组 二维数组： 元素为一堆数组的数组 定义格式： - A：数据类型[ ] [ ] 数组名; (推荐的方式) - B：数据类型 数组名[ ] [ ] - C：数据类型[ ] 数组名[ ] 初始化： - A： 动态初始化 - 数据类型[ ] [ ] 数组名 = new 数据类型[m] [n]; - m 表示的是 二维数组中一维数组的个数 - n 表示的是 一维数组中的元素个数 - B： 静态初始化 - 数据类型[ ] [ ] 数组名 = new 数据类型[ ] [ ] &#123;&#123;元素…&#125;,&#123;元素….&#125;&#125; - 简化格式： - 数据类型[ ] [ ] 数组名 = &#123;&#123;1,…&#125;,&#123;2….&#125;,&#123;3….&#125;&#125; 取值： - *二维数组名配合索引可以获取到每一个一维数组* 【**arr[索引]**】 - *一维数组配合索引名可以获取到数组中的元素*【**arr[索引] [索引]**】 二维数组取值 package com.data.it; /** * Created by JackFeng on 2020/3/1. */ public class Array2Test &#123; public static void main(String[] args) &#123; //数据类型[] [] 数组名 = &#123;&#123;元素..&#125;,&#123;元素...&#125;&#125; int[][] arr = &#123;&#123;1, 2, 3&#125;, &#123;1, 3, 6&#125;, &#123;2, 3, 6&#125;&#125;; // // System.out.println(arr); // System.out.println(arr[0]); // System.out.println(arr[0][0]); // 遍历二维数组 // 第一个数组的元素 for (int i = 0; i &lt;arr[0].length ; i++) &#123; System.out.println(arr[0][i]); &#125; System.out.println(&quot;==========&quot;); // 第二个数组的元素 for (int i = 0; i &lt;arr[2].length ; i++) &#123; System.out.println(arr[0][i]); &#125; // 优化循环二维数组 System.out.println(&quot; -----------&quot;); // 二维数组 arr.length 就是有几个 一维数组 for (int i = 0; i &lt; arr.length ; i++) &#123; for (int j = 0; j &lt;arr[i].length ; j++) &#123; System.out.print(arr[i][j] + &quot; &quot;); &#125; System.out.println(&quot;====&quot;); &#125; &#125; &#125; 1.5、函数方法使用 方法： 特定功能的代码块 方法定义格式： 修饰符 返回值类型 方法名(参数类型 参数名1，参数类型 参数名2 ..){ ​ 方法体; ​ return 返回值; } 格式解释： A：修饰符 public static B：返回值类型 限定返回值的数据类型 C：方法名 方便我们调用方法的名字 D：参数类型 用于限定调用方法时传入数据的类型 E：参数名 用于接收调用方法时传入的数据变量 F： 方法体 完成功能代码 G：return 结束方法，并且把返回值带给调用者 方法明确： A：返回值类型 明确功能结果的数据类型 B：参数列表 明确有几个参数，以及参数的数据类型 方法调用：（有明确返回值的调用） A：单独调用 没有意义 B：输出调用，有意义，但是不够好(因为我想要拿结果进一步操作) C：赋值调用 方法调用：(void修饰的方法) 如果一个方法没有明确的返回值，也不能空开返回值，用void表示该方法无返回值类型 只能输出调用。 求和方法 package com.data.it; /** * Created by JackFeng on 2020/3/1. */ public class SumTest &#123; public static void main(String[] args) &#123; //调用sum // 单独调用 无意义 // sum(10, 20); // 输出调用，有意义，不完美 // System.out.println(sum(10,20)); // 赋值调用，常用操作。 int i = sum(10, 20); System.out.println(i); System.out.println(i+1); // 对i 进行操作 int j = sum(10,20)+10; System.out.println(j); &#125; /* * 两个明确： * 返回值： int * 参数列表： int a , int b * * * */ public static int sum(int a , int b )&#123; int c = a + b; return c; &#125; &#125; 键盘录入两个数据判断是否相等 package com.data.it; import java.util.Scanner; /** * Created by JackFeng on 2020/3/1. */ public class MethodTest &#123; public static void main(String[] args) &#123; // 创建键盘录入 Scanner sc = new Scanner(System.in); // 接收数据 System.out.println(&quot;请输入第一个数据：&quot;); int x = sc.nextInt(); System.out.println(&quot;请输入第二个数据：&quot;); int y = sc.nextInt(); // 调用方法 boolean b = bijiao(x, y); System.out.println(b); &#125; /* * 求两个值是否相等： * 返回值： boolean * 参数列表： int a,int b * * */ public static boolean bijiao(int a , int b )&#123; if (a==b)&#123; return true; &#125;else &#123; return false; &#125; &#125; &#125; 水仙花数 package com.data.it; /** * Created by JackFeng on 2020/3/1. */ public class MethodTest1 &#123; public static void main(String[] args) &#123; //调用方法 printFlower(); &#125; /* * 水仙花数打印到控制台方法 * * 两个参数： * 返回值类型：void * 参数列表： 无参数 * * */ public static void printFlower()&#123; for (int i = 100; i &lt;1000 ; i++) &#123; int g = i%10; int s = i/10%10; int b = i/10/10%10; if (g*g*g + s*s*s + b*b*b == i)&#123; System.out.println(i); &#125; &#125; &#125; &#125; 方法重载 方法重载： 在同一个类中，出现了方法名相同 不能出现参数名以及参数条件一致的方法 特点： 方法名相同，参数不同 参数不同 参数数量不同 参数个数不同 注意：在调用方法的时候，java虚拟机会通过参数列表的不同来区分同名的方法。 比较两个数据是否相等 package com.data.it; /** * Created by JackFeng on 2020/3/1. */ public class MethodTest2 &#123; public static void main(String[] args) &#123; System.out.println(compare(10,10)); System.out.println(compare(10L,10L)); System.out.println(compare((byte) 10,(byte)20)); System.out.println(compare((short) 10,(short) 20)); &#125; //byte public static boolean compare(byte a , byte b)&#123; System.out.println(&quot;byte&quot;); return a == b; &#125; //short public static boolean compare(short a , short b)&#123; System.out.println(&quot;short&quot;); return a == b; &#125; //int public static boolean compare(int a , int b)&#123; System.out.println(&quot;int&quot;); return a == b; &#125; //long public static boolean compare(long a , long b)&#123; System.out.println(&quot;long&quot;); return a == b; &#125; &#125; 形式参数 如果方法的参数是基本数据类型： ​ 形式参数的改变不影响实际参数 如果方法的参数是引用数据类型： ​ 形式参数的改变直接影响实际参数 数组遍历 package com.data.it; /** * Created by JackFeng on 2020/3/1. */ public class ArrayDo &#123; public static void main(String[] args) &#123; int[] arr = &#123;1, 2, 3, 4, 5&#125;; System.out.println(&quot;第一种方式&quot;); printArray(arr); System.out.println(&quot;第二种方式&quot;); printArray1(arr); &#125; /* * 两个明确： * 返回类型： void * 参数列表： int[] arr * */ public static void printArray(int[] arr)&#123; for (int i = 0; i &lt;arr.length ; i++) &#123; System.out.println(arr[i]); &#125; &#125; public static void printArray1(int[] arr)&#123; // 输出为这样的 [1,2,3,4,5] System.out.print(&quot;[&quot;); for (int i = 0; i &lt;arr.length ; i++) &#123; if (i==arr.length-1)&#123; System.out.println(arr[i]+&quot;]&quot;); &#125;else &#123; System.out.print(arr[i]+&quot;, &quot;); &#125; &#125; &#125; &#125; 1.6、断点调试 断点调试的作用： ​ A： 查看程序的执行流程 ​ B： 调试程序 断点： ​ – 标记 哪里需要点哪里 需加在有效的地方 1.7、基础练习不死神兔计算 package myTest; /** * Created by JackFeng on 2020/3/1. */ public class Test &#123; public static void main(String[] args) &#123; // 20个月 兔子的对数 // 1,1,2,3,5.... // 定义数组 int[] arr = new int[20]; // 给数组赋值 arr[0] = 1; arr[1] = 1; // 找规律赋值 for (int i = 2; i &lt;arr.length ; i++) &#123; arr[i] = arr[i - 1] + arr[i - 2]; &#125; //输出结果 System.out.println(&quot;第20个月兔子的对数是：&quot;+arr[19]); &#125; &#125; 评委评分 需求： ​ 在编程竞赛中，有6个评委为参赛选手打分，分数为0-100的整数分。 ​ 选手最后的得分为，去掉一个最高分与最低分，剩下4个评委的平均值 分析： A：定义一个长度为6的数组 B：键盘录入评委的分数 C：写方法实现最高分、最低分 D：写方法求评委分数和 E：平均分：（和-最高分-最低分）/（arr.length-2） F：输出平均分 package myTest; import java.util.Scanner; /** * Created by JackFeng on 2020/3/2. */ public class Test1 &#123; public static void main(String[] args) &#123; //定义数组 int[] arr = new int[6]; //键盘录入 Scanner sc = new Scanner(System.in); //键盘录入评委分数 for (int i = 0; i &lt;arr.length ; i++) &#123; //接受数据 System.out.println(&quot;请输入第 &quot;+(i+1)+&quot;个评委给出的分数&quot;); int score = sc.nextInt(); arr[i] = score; &#125; //调用方法 int max = getMax(arr); int min = getMin(arr); int sum = sum(arr); // 求平均分 int avg = (sum - max - min) / (arr.length - 2); System.out.println(&quot;该选手的最终得分是：&quot;+avg); &#125; //最高分 /* * 两个明确： * 返回值类型： int * 参数列表： int [] arr * * * */ public static int getMax(int[] arr)&#123; //定义参照物 int max = arr[0]; for (int i = 1; i &lt;arr.length ; i++) &#123; if (arr[i]&gt;max)&#123; max = arr[i]; &#125; &#125; return max; &#125; // 最低分 public static int getMin(int[] arr)&#123; //定义参照物 int min = arr[0]; for (int i = 1; i &lt;arr.length ; i++) &#123; if (arr[i]&lt;min)&#123; min = arr[i]; &#125; &#125; return min; &#125; // 求和 public static int sum(int[] arr)&#123; // 定义求和变量 int sum = 0; for (int i = 0; i &lt;arr.length ; i++) &#123; sum += arr[i]; &#125; return sum; &#125; &#125; 键入数组反转 需求： 1、键盘录入5个int的数据存在arr中 2、定义方法将arr数组中的内容反转 3、定义方法对反转后的数组进行遍历 package myTest; import java.util.Scanner; /** * Created by JackFeng on 2020/3/2. */ public class Test2 &#123; public static void main(String[] args) &#123; int[] arr = new int[5]; Scanner sc = new Scanner(System.in); for (int i = 0; i &lt;arr.length ; i++) &#123; System.out.println(&quot;请输入&quot;+(i+1)+&quot;个元素值：&quot;); int number = sc.nextInt(); arr[i] = number; &#125; printArray(arr); // 反转 arr reverse(arr); System.out.println(&quot;反转后&quot;); printArray(arr); &#125; //遍历数组 public static void printArray(int[] arr)&#123; System.out.print(&quot;[&quot;); for (int i = 0; i &lt;arr.length ; i++) &#123; if (i==arr.length-1)&#123; System.out.println(arr[i]+&quot;]&quot;); &#125;else&#123; System.out.print(arr[i]+&quot;, &quot;); &#125; &#125; &#125; // 反转数组 public static void reverse(int[] arr)&#123; for(int start =0, end= arr.length-1; start&lt;=end;start++,end--)&#123; int temp = arr[start]; arr[start] = arr[end]; arr[end] = temp; &#125; &#125; &#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/tags/Java/"}]},{"title":"Java环境","slug":"Java/JavaSE/Java环境","date":"2020-05-07T15:53:40.000Z","updated":"2021-01-24T13:53:55.229Z","comments":true,"path":"posts/17415.html","link":"","permalink":"http://www.a2data.cn/posts/17415.html","excerpt":"Java JDK 环境安装","text":"Java JDK 环境安装 Java环境 程序编译和运行需要使用 javaJDK 下的bin目录 环境变量配置： JAVA_HOME —— jdk安装目录 Path环境 —— %JAVA_HOME%\\bin JVM: JAVA虚拟机 JRE: JAVA运行环境 JDK: 开发环境 JDK包含JER包含JVM 1、Win10环境 Win10下 Java环境变量配置 首先，你应该已经安装了 Java 的 JDK 了！！！ 如果没有安装JDK，请跳转到此网址：http://www.oracle.com/technetwork/java/javase/downloads/index-jsp-138363.html） 笔者安装的是 jdk-1.8.0_151-windows-x64 接下来主要讲怎么配置 Java 的环境变量，也是为了以后哪天自己忘记了做个备份！！ 注：win10的环境变量配置和其他的windows版本稍有不同 2、环境变量在电脑桌面 右键点击 “此电脑”的“属性”选项 选择“高级系统设置”选项 点击下面的“环境变量”选项 接下来就是具体的配置过程： 点击“系统变量”下面的”新建“选项 在”变量名“处填上”Java_Home“ 变量值“为JDK安装路径，路径自定义: D:\\Program Files\\Java\\jdk1.8.0_151 点击”确定“选项 在”系统变量“中找到”Path“ 选中”Path“点击”编辑“选项 3、添加变量 选择右边的“新建”，将引号里面的分别复制添加“%Java_Home%\\bin;%Java_Home%\\jre\\bin;” 点击“环境变量”最下面的“确定”选项 回到电脑桌面，按快捷键“Win+R”，输入“cmd” 检查Java环境是否配置成功 输入 java -verison 4、环境配置成功 如上图所示，恭喜你，环境变量就配置好了。 为了敏捷开发，小编建议 安装IDEA，并且2020版本支持中文。 有了好的环境，才能更好的学习。小编也会补充上基础得学习教程。 一起加油吧 ！！！","categories":[{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/categories/Java/"}],"tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://www.a2data.cn/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/tags/Java/"}]},{"title":"最快图床搭建","slug":"Tools/最快图床搭建","date":"2020-05-05T17:09:54.000Z","updated":"2021-01-24T13:53:55.027Z","comments":true,"path":"posts/36204.html","link":"","permalink":"http://www.a2data.cn/posts/36204.html","excerpt":"最快的图床搭建，有坑请联系小编。","text":"最快的图床搭建，有坑请联系小编。 PicGo1、安装PicGoGitHub地址 https://github.com/Molunerfinn/PicGo/releases 访问 PicGo选择 PicGo-Setup-XXX.exe下载软件安装包（GitHub直接下载速度会有些慢甚至无法完成下载，可选择使用迅雷下载，亲测有用） 或者联系小编，小编有 微云+ 百度云高效连接。 2、安装选项 安装软件时选择仅为我安装，另外注意不要安装在C盘 安装node.js：点击 nodejs 下载完安装包后进行安装，除了更改安装位置外，一路默认完成安装即可 更换镜像源：进入命令行执行以下命令 npm config set registry https://registry.npm.taobao.org 3、安装完成 Gitee1、打开PicGo运行软件打开插件设置搜索gitHub，安装github-plus插件 2、创建Gitee图床仓库 https://gitee.com/DataITems_admin/cdn.git 创建仓库时务必要勾选一个初始化选项初始化仓库，否则后面上传时会失败 3、创建私人令牌私人令牌：https://gitee.com/profile/personal_access_tokens/new 生成成功如下： 4、 设置GithubPlus返回PicGO，点击图床设置-&gt; githubPlus ，填写repo，token和origin三项，token填写为上一步生成的token，origin选择gitee，repo填写为sqlsq_admin/cdn Typora 熟悉的都知道，这个记事本我推荐了好多次了。 并且也自己魔改了一些css样式。目前小编最钟爱的编辑器。 完成以上操作即可正常使用你的PicGo了，如果你还经常使用typora的话可以继续设置你的typora 1、配置图片 2、上传配置 建议开启 优先使用相对路径。 这样可以预览！ 3、体验极速上传吧 推荐图床： 别问小编为什么，因为我穷付费的都用不起。 Github 免费 有时候容易失败 GithubPlus — Gitee 免费 高效 快捷 上传 上传成功 4、完美 至于图床的更多便捷就不一 一诉说了。","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/categories/Tools/"}],"tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://www.a2data.cn/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"图床","slug":"图床","permalink":"http://www.a2data.cn/tags/%E5%9B%BE%E5%BA%8A/"}]},{"title":"Redis","slug":"DataBase/Redis/Redis","date":"2020-05-05T16:47:18.000Z","updated":"2025-05-05T06:07:54.184Z","comments":true,"path":"posts/bae4ff13.html","link":"","permalink":"http://www.a2data.cn/posts/bae4ff13.html","excerpt":"详细说明Redis的安装。","text":"详细说明Redis的安装。 Redis安装 Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 1、下载 windows版本： https://github.com/MSOpenTech/redis/releases Linux版本： 官网下载： http://www.redis.cn/ git下载 https://github.com/antirez/redis/releases 我们现在讨论的是windows下的安装部署，目前windows下最新版本是：3.2.100。 下载地址，提供多种下载内容，Redis-x64-3.2.100.msi是在windows下，最简单的安装文件，方便，直接会将Redis写入windows服务。Redis-x64-3.2.100.zip是需要解压安装的，接下来讨论的是这种。Source code (zip) 源码的zip压缩版Source code (tar.gz) 源码的tar.gz压缩版 2、安装以 Redis-x64-3.2.100.msi 为例，下载之后运行 3、启动 通过cmd指定到该redis目录。使用命令：redis-server.exe 启动服务 或者到对应目录启动即可。 4、使用 参考安装完之后的生成文档 如果您使用MSI包安装了Redis，那么Redis已经作为Windows服务安装了。没有别的事可做。如果您想要更改它的设置，您可以更新Redis .windows-service.conf文件，然后重新启动Redis服务(运行-&gt;服务。msc -&gt; Redis -&gt;重启)。 在安装MSI期间，您可以使用安装程序的用户界面来更新Redis监听的端口和防火墙异常，或者在没有UI的情况下静默运行它。下面的例子展示了如何从命令行安装: default install (port 6379 and firewall exception ON): msiexec /i Redis-Windows-x64.msi set port and turn OFF firewall exception: msiexec /i Redis-Windows-x64.msi PORT=1234 ADD_FIREWALL_RULE=&quot;&quot; set port and turn ON firewall exception: msiexec /i Redis-Windows-x64.msi PORT=1234 ADD_FIREWALL_RULE =1 install with no user interface: msiexec /quiet /i Redis-Windows-x64.msi 如果您没有使用MSI包安装Redis，那么您仍然可以按照以下说明运行Redis作为Windows服务: 为了更好地与Windows服务模型集成，在Redis中引入了新的命令行参数。这些服务参数需要一个提升的用户上下文，以便连接到服务控制管理器。如果这些命令是从非提升的上下文调用的，那么Redis将尝试创建一个提升的上下文来执行这些命令。这将导致一个用户帐户控制对话框显示在窗口，并可能需要Admini #安装服务 这必须是redis-server命令行的第一个参数。参数按服务启动时发生在Redis中的顺序传递。该服务将被配置为自动启动，并将作为“NT AUTHORITY\\NetworkService”启动。安装成功后，将显示一条成功消息，Redis将退出。 此命令不启动服务。 #例如： redis-server --service-install redis.windows-service.conf --loglevel verbose #卸载服务 --service-uninstall 这将从注册表中删除Redis服务配置信息。卸载成功后，将显示一条成功消息，Redis将退出。 这并不命令不停止服务。 #例如 redis-server --service-uninstall Starting the Service --service-start 这将启动Redis服务。成功启动后，将显示一条成功消息并开始运行Redis。 #例如 redis-server --service-start Stopping the Service --service-stop 这将停止Redis服务。成功终止后，将显示一条成功消息，Redis将退出。 #例如 redis-server --service-stop #命令服务 --service-name name 此可选参数可与前面的任何命令一起使用，以设置安装的服务的名称。该参数应该位于service-install、service-start、service-stop或service-uninstall命令之后，并位于通过service-install命令传递给Redis的任何参数之前。 下面将安装并启动三个独立的Redis服务实例: redis-server --service-install --service-name redisService1 --port 10001 redis-server --service-start --service-name redisService1 redis-server --service-install --service-name redisService2 --port 10002 redis-server --service-start --service-name redisService2 redis-server --service-install --service-name redisService3 --port 10003 redis-server --service-start --service-name redisService3 # 测试 启动服务 redis-server --service-start 客户端 命令： 精简模式： redis-cli.exe 指定模式： redis-cli.exe -h 127.0.0.1 -p 6379 -a requirepass (-h 服务器地址 -p 指定端口号 -a 连接数据库的密码[可以在redis.windows.conf中配置]，默认无密码) 5、Redis工具 Redis Desktop Manager https://redisdesktop.com/pricing 注意：Redis支持多个数据库，并且每个数据库的数据是隔离的不能共享，并且基于单机才有，如果是集群就没有数据库的概念。 Redis是一个字典结构的存储服务器，而实际上一个Redis实例提供了多个用来存储数据的字典，客户端可以指定将数据存储在哪个字典中。 每个数据库对外都是一个从0开始的递增数字命名，Redis默认支持16个数据库（可以通过配置文件支持更多，无上限），可以通过配置databases来修改这一数字。客户端与Redis建立连接后会自动选择0号数据库，不过可以随时使用SELECT命令更换数据库。","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://www.a2data.cn/tags/Redis/"}]},{"title":"1.DBeaver安装","slug":"DataBase/1.DBeaver安装","date":"2020-05-05T16:46:01.000Z","updated":"2025-05-05T06:07:54.177Z","comments":true,"path":"posts/773d5f8c.html","link":"","permalink":"http://www.a2data.cn/posts/773d5f8c.html","excerpt":"DBeaver安装步骤","text":"DBeaver安装步骤 DBeaver1、下载 官方链接：https://dbeaver.io/ 2、安装 双击打开应用程序。只需要更改存储位置即可。 3、新建 4、下载驱动文件 5、 链接数据库 6、测试链接 7、更改主题 根据自己爱好设定。 8、查询数据","categories":[],"tags":[]},{"title":"大数据集群","slug":"Hadoop/大数据集群","date":"2020-05-05T16:41:07.000Z","updated":"2025-05-05T06:07:54.191Z","comments":true,"path":"posts/9e565f9f.html","link":"","permalink":"http://www.a2data.cn/posts/9e565f9f.html","excerpt":"快速搭建Hadoop集群","text":"快速搭建Hadoop集群 全网独家收藏的大数据学习环境此版本为CDH 官网提供，小编早期独家收藏，便于快速学习的版本。目前已经没有了。 默认情况下，Cloudera快速启动VM在Linux的服务和配置管理下运行Cloudera的发行版，包括Apache Hadoop (CDH)。如果您希望迁移到Cloudera Manager，您必须运行以下命令之一。 要使用Cloudera Express(免费)，可以在桌面上运行Launch Cloudera Express。这需要至少8gb的RAM和至少2个虚拟cpu。 要开始一个具有先进管理功能的为期60天的Cloudera Enterprise试用版，请在桌面上运行Launch Cloudera Enterprise(试用版)。这需要至少10gb的RAM和至少2个虚拟cpu。 请注意，在重启之后，Cloudera Manager可能需要几分钟时间才能启动它管理的所有服务，并准备好接受来自客户端的连接。 环境要求 内存 8G CPU 最少2个 空间 64GB Vmware VM安装0、下载 VMware Workstation Pro 确立了在单台 Linux 或 Windows PC 上运行多个操作系统的行业标准。 Workstation 15.5 Pro 通过提供全新的用户界面控件，支持巨型帧以及最新的 Windows 和 Linux 操作系统等，进一步完善了领先的桌面… 链接直达： https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html 1、以管理员身份运行找到下载的程序，右击 2、下一步 3、接收协议 4、更改安装目录 5、安装 点击下一步，点击安装 6、完成 许可证激活密钥 UY758-0RXEQ-M81WP-8ZM7Z-Y3HDA VM使用0、启动 1、更改存储位置 2、更改共享位置 3、虚拟网络 虚拟机网络相关配置 详细设置 cloudera cloudera-quickstart-vm-5.13.0-0-vmware （目前已经不可下载） https://www.cloudera.com/products/open-source/apache-hadoop/key-cdh-components.html VM快速学习 目前最高版本是 5.16 https://docs.cloudera.com/documentation/enterprise/5-16-x/topics/cloudera_quickstart_vm.html 1、导入虚拟机 2、编辑虚拟机设置 最低配置： **4G，4G ，4G **—- 4G 1cores 64GB 小编配置： 8G 2cores 64GB 3、开启虚拟机 4、项目成功启动 等候片刻，根据机器配置来讲，成功创建。如下图 打开浏览器 如果你配置了ip，可以在外部浏览器打卡的。 点击 Cloudera Express 启动成功 5、更改IPcentos ip更改 默认值： DEVICE=&quot;eth0&quot; BOOTPROTO=&quot;dhcp&quot; DHCP_HOSTNAME=&quot;quickstart.cloudera&quot; HOSTNAME=&quot;quickstart.cloudera&quot; HWADDR=&quot;00:0C:29:D3:4D:5C&quot; IPV6INIT=&quot;no&quot; MTU=&quot;1500&quot; NM_CONTROLLED=&quot;yes&quot; ONBOOT=&quot;yes&quot; TYPE=&quot;Ethernet&quot; UUID=&quot;f127faf3-7a1f-4bca-a404-0119665a8459&quot; 注意：使用sudo sudo vim /etc/sysconfig/network-scripts/ifcfg-eth0 修改为: DEVICE=&quot;eth0&quot; BOOTPROTO=&quot;static&quot; DHCP_HOSTNAME=&quot;quickstart.cloudera&quot; HOSTNAME=&quot;quickstart.cloudera&quot; HWADDR=&quot;00:0C:29:D3:4D:5C&quot; IPV6INIT=&quot;no&quot; MTU=&quot;1500&quot; NM_CONTROLLED=&quot;yes&quot; ONBOOT=&quot;yes&quot; TYPE=&quot;Ethernet&quot; UUID=&quot;f127faf3-7a1f-4bca-a404-0119665a8459&quot; IPADDR=192.168.6.6 NETMASK=255.255.255.0 重新启动即可: sudo service network restart 6、启动异常解决方案异常解决 重新添加网卡 复制MAC地址： 更改： DEVICE = eth2 HWADDR —- 为你的地址值 再次重新启动 1.重启服务 sudo service network restart 2.查看ip ip addr/ifconfig MobaXterm1、安装MobaXterm https://mobaxterm.mobatek.net/download-home-edition.html 2、启动 3、配置 4、登录 输入密码，保存。 5、查看 相关安装包，请联系小编获取。 欢迎访问 小编博客 ： www.a2data.cn全力打造 SQL社区： www.sqlsq.cn","categories":[],"tags":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://www.a2data.cn/tags/Hadoop/"}]},{"title":"Linux 正则表达式","slug":"Linux/Linux-正则表达式","date":"2020-04-25T11:14:43.000Z","updated":"2020-09-11T08:45:25.871Z","comments":true,"path":"posts/47985.html","link":"","permalink":"http://www.a2data.cn/posts/47985.html","excerpt":"正则表达式相关","text":"正则表达式相关 正则表达式 是指用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。就是用某种模式去匹配一类字符串的一个公式。 touch bb.txt grep “m*” bb.txt 基本元字符集grep -E = egrep · 匹配任意单个字符。 如：rat、r、t。 ^ 匹配一行的开始 $ 匹配一行的结尾 匹配0个或多个前面的字符 + 匹配1个或者多个+前面的字符（需要\\号，如grep -E “11+” /root/2） ? 匹配0个或1个？之前的字符 \\ 转义 []匹配括号中的任何一个字符。如：[abc] [^] 匹配不在括号中的，表示排除 如[^abc]或者 grep -v [abc] &lt; 匹配词的开始 &gt; 匹配词的结束。 如 &lt;the&gt;\\。 | 或。 例如 （him|her） {m} 前面的表达式重复m次。如：“\\w{2}”相当于“\\w\\w”。 {m,n} 表达式至少重复m次，做多重复n次。如：“ba{1,3}”匹配“ba”或“baa”“baaa” “d{2,3}” {m，} 表达式至少重复m次 \\w 任意一个字母或数字或下划线 \\d 任意一个数字 grep [0-9] bb.txt \\s 空格、制表符、换页符、空白符中的任意的一个。 \\b 匹配一个单词的边界。如：“.\\b.” 以什么开头放后边 以什么结尾放前边 环境支持 命令或环境 · [] ^ $ ( ) { } ? + | ( ) vi × × × × × awk × × × × × × × × sed × × × × × × grep × × × × × × egrep × × × × × × × × × perl × × × × × × × × ×","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"}]},{"title":"Linux Shell语法","slug":"Linux/Linux-Shell语法","date":"2020-04-25T11:14:22.000Z","updated":"2020-09-11T08:45:25.893Z","comments":true,"path":"posts/64423.html","link":"","permalink":"http://www.a2data.cn/posts/64423.html","excerpt":"Linux Shell 语言得一些基本语法。","text":"Linux Shell 语言得一些基本语法。 Shell语法If语句格式 (number=num) read -p &quot;请输入一个数字&quot; num if [ $num -eq 3 ] （如果） then echo &quot;wo xiang ni&quot; elif [ $num -le 5 ] then （然后） echo &quot;zhen xiang le &quot; else [ $num -ge 6 ] （否则） echo &quot;miss 531&quot; fi （结束） 闰年第一版 year=`date +%Y` if [ $[ $year % 400 ] -eq 0 ] then echo &quot;$year is a leap year.&quot; elif [ $[ $year % 4 ] -eq 0 ] then if [ $[ $year % 100 ] -ne 0 ] then echo &quot;$year is a leap year.&quot; else echo &quot;$year is not a leap year.&quot; fi else echo &quot;$year is not a leap year.&quot; fi 第二版（原版） year=$(date +%Y) if [ $[ $year % 400 ] -eq 0 ] then echo &quot;$year is a leap year.&quot; elif [ $[ $year % 4 ] -eq 0 ] then if [ $[ $year % 100 ] -ne 0 ] then echo &quot;$year is a leap year.&quot; else echo &quot;$year is not a leap year.&quot; fi else echo &quot;$year is not a leap year.&quot; fi 第三版（查询哪一年是闰年） read -p &quot;shu ru nian fen&quot; year if [ $[ $year % 400 ] -eq 0 ] then echo &quot;$year is a leap year.&quot; elif [ $[ $year % 4 ] -eq 0 ] then if [ $[ $year % 100 ] -ne 0 ] then echo &quot;$year is a leap year.&quot; else echo &quot;$year is not a leap year.&quot; fi else echo &quot;$year is not a leap year.&quot; fi FOR 循环 格式语法：for NAME in [ LIST ];do COMMANDS; done ​ 列表 执行命令 结束 LIST用法 直接写 1 2 3 大括号 {1..5} 文件名 /etc/*.conf 命令结果 find /etc/ -name “*.conf” C语言风格 for ((i=0;i&lt;5 i=i+2)) i++ ping网段案例ping.sh for p in &#123;1..10&#125; p---变量名称 do do----执行内容 host=(192.168.18.$p) ping -c2 192.168.18.$p &gt;&gt; /root/Desktop/2.txt c2---频率 if [ $? == 0 ] then echo &quot;$host is online.&quot; 在线 else echo &quot;$host is offline.&quot; 不在线 fi done while循环aa=1 while [ $aa -le 10 ] do echo &quot;wo xiang ni le&quot; aa=$[$aa+1] done case 判断aa=3 ( 3 变量值） case &quot;$aa&quot; in 1) echo &quot;haha&quot;;; （1,2,4常量值） 2) echo &quot;heihei&quot;;; 3) echo &quot;nimei&quot;;; （有内容两；没有一个；） esac break 终止当前for循环 for n in &#123;1..10&#125; do if [ $n -eq 3 ] then break fi echo $n done continue 跳出本次循环 for n in &#123;1..10&#125; do if [ $n -eq 3 ] then continue fi echo $n done","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"}]},{"title":"Linux Shell脚本","slug":"Linux/Linux-Shell脚本","date":"2020-04-25T11:14:07.000Z","updated":"2020-09-11T08:45:25.875Z","comments":true,"path":"posts/43857.html","link":"","permalink":"http://www.a2data.cn/posts/43857.html","excerpt":"Linux Shell脚本相关学习。","text":"Linux Shell脚本相关学习。 Shell:操作系统与用户进行交互操作的界面，提供脚本语言编程环境，方便用户自动批量处理大量的工作任务。 红帽企业版linux一般默认的Shell是bash shell。 shell脚本 Shell:操作系统与用户进行交互操作的界面，提供脚本语言编程环境，方便用户自动批量处理大量的工作任务。 红帽企业版linux一般默认的Shell是bash shell。 vim aa.sh #编辑aa脚本 cd /root/Desktop #切换到root下的桌面 mkdir aa #创建aa目录 touch aa/aa.txt #在aa目录下创建aa.txt sh aa.sh #运行aa.sh脚本 echo $$ 查看当前进程号 bash 进入另一个shell exit 退出 history 历史 语法 替换 ！！ 前一个命令 ！n 命令号n ！-n 倒数第n个命令 ！cmd 最后用来启动cmd的命令 多命令运行#！/bin/sh 注释信息，可写可不写 echo $? 返回值：通过$?变量进行查看，返回0成功，不成功则返回非0值！ 有条件的链接命令 &amp;&amp; 把两个命令链接在一起，只有第一个命令成功执行时，才会执行第二个命令。 || 把两个命令链接在一起，只有第一个命令失败时，才会执行第二个命令。 Bash变量例如：aa=DataScience echo $aa 则会显示DataScience Shell变量A和B A=123 B=234 echo a:$A b:$B 显示AB变量内容 a：123 b：234 export A 将A变量提升为环境变量 bash ps echo a:$A b:$B---- 启动一个bash ，通过ps运行，确定有俩个shell在运行；父shell（B），子shell（A）由于被提升为一个环境变量，A shell从B shell中继承了它，相反，A shell对B shell的变量B一无所知。Bshell 属于sleep状态。结果如下 a：123 ：b： exit echo a:$A b:$B 退出再次查看 a：123 b：234 unset A B----- 取消环境变量A和shell变量 B 命令替换 替换 语法 含义 历史（history） ！ 前一个命令行 大括号（Brace） {} 指定的文本 代字号（Tilde） ~username 用户的主目录 变量 $,${…} Shell和环境变量 算数（Arithmetic） $((…)) 算数运算 命令替换 ‘…’，$(…) 运行在字shell中的命令的输出 路径名（Pathname） [^…*]?,[…] 文件系统中匹配的文件名 mkdir chap&#123;a1,a2,a3,a4,&#125;/&#123;bb,cc&#125; 需要先创建&#123;a1,a2,a3,a4&#125; mkdir -p &#123;a1,a2,a3,a4,&#125;/&#123;bb,cc&#125; 算法a=123 b=234 echo $(($a+$b)) ----- a+b 357 ---------- 结果 2、计算器 Scale=2 保留几位小数, %取余。 Quit 退出计算器 \\;反斜杠 转义字符 创建时间文档 date +%Y%m%d 语法 作用 \\ 避免下一个字符被shell解释 “” 避免双引号内除了S、！和（反引号）字符以外的其它字符被shell解释 ‘’ 避免单引号内的字符被shell解释 alias 命令 Shell别名可创建扩展（替换）为任意文本的命令 alias NAME=a unalias 取消 unalias a 取消a替换NAME的命令 标准输入 标准输出echo “aaa”&gt; aa.txt 创建aa.txt文档 cat aa.txt 查看aa.txt文档 设置密码（可批量设置用户密码） useradd u1 创建u1用户 passwd u1 设置u1 密码 useradd u2 创建u2用户 vim bb.txt 新建立一个bb.txt文档 123456 将密码输入 bb.txt文档中 passwd u2 --stdin &lt; bb.txt 将输入定向到文档中 su - u1 切换到u1 su - u2 切换到u2 输入密码 123456 标准输出和错误输出echo “aaabbccc”&gt;aa.txt &gt;&gt;文件续写 echo “aaabbbcc”&gt;&gt;aa.txt 意思是用&gt;把内容输入到文档中。 head -1 /etc/rc.d/\\* &gt; aa.txt 2&gt;bb.txt 将标准输出和错误输出分别传到aa.txt和bb.txt head -1 /etc/re.d/\\* &gt;aa.txt 2&gt;&amp;1 head -1 /etc/rc.d/\\* &gt;&amp; aa.txt 将标准输出和错误输出合并到aa.txt Shell scripts scripts脚本返回值 echo $? 返回值 退出状态 0（Zero） Success Non-zero Failure 2 Incorrect usage 126 Not an executable 127 Command not found vim aa.sh 编辑aa.sh脚本 read -p &quot;qing shu ru yong hu ming cheng &quot; name echo $name sh aa.sh 运行aa，name脚本 只读变量 变量 含义 ？ 最新执行的命令的退出状态 - 当前启用中的shell选项标记 $ 当前shell的进程id（PID） ！ 最新后台命令的进程ID（pid） _ 前一个命令的最后标记 PPID shell父进程的ID（PID） SHELLOPTS 被冒号隔开的当前启用中的shell选项列表，和set -o命令结果一样 UID 当前用户的用户id 路径替换 ~ */? []/[^] &amp; 比较–针对文件 关于文件类型的判断，如：test -e filename -e 是否存在 -f 是否为文件 -d 是否为目录 -b 是否为block device -c 是否为character device -S 是否为socket -p 是否为pipe文件 -L 是否为链接 比较–权限 关于文件权限的判断，如：test -r filename -r 文件是否可读 -w 文件是否可写 -x 文件是否可执行 -u 文件是否有SUID -g 文件是否有SGID -k 文件是否有Sticky bit -s 文件是否非空 比较–新旧与大小 比较两个文件大小，命令 例如： test A -nt B -nt A是否比B新 -ot A是否比B旧 -ef A是否和B是用一个文件，两个整数之间的判断。 -eq 两个数相等 -ne 两个数不等 -gt A大于B -lt A小于B -ge A大于等于B -le A小于等于B","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"}]},{"title":"Linux系统监控","slug":"Linux/Linux系统监控","date":"2020-04-25T11:13:45.000Z","updated":"2020-09-11T08:45:25.895Z","comments":true,"path":"posts/10537.html","link":"","permalink":"http://www.a2data.cn/posts/10537.html","excerpt":"Linux 系统监控篇。","text":"Linux 系统监控篇。 系统监控PS 进程监控 ps工具标识进程的5种状态码 D 不可中断 uninterruptible sleep(usually IO) R 运行 runnable (on run queue) S 中断 sleeping T 停止 traced or stopped Z 僵死 a defunct (“zombie”) process 使用方法 ps [options] [–help] ps 的参数 -A 列出所有的行程 -w 显示加宽可以显示较多的资讯 -au 显示较详细的资讯 -aux 显示所有包含其他使用者的行程 总述 标识 释义 USER 行程所拥有者 PID pid %CPU 占用cpu使用率 %MEM 占用的记忆体使用率 VSZ 占用的虚拟机体大小 RSS 占用的记忆体大小 TTY 终端的次要装置号码 COMMAND 所执行的指令 top动态监控系统进程 TOP动态 第一行任务队列信息 - 01:06:08 当前时间 1 user 当前登录用户数 第二、三行 进程和cpu Tasks：158total 进程总数 最后两行为内存信息 Mem：191272k total 物理内存总数 COMMAND 命令名/命令行 SAR 系统活动情况报告 指令软件包：sysstat-7.0.3-3.el5.i386mp sar 命令常用格式 sar [options][-A][-o file]t[n] 其中：t：采样间隔 n 采样次数 默认值为1. options未明朗行选项，sar常用选项如下： -o file 表示将命令结果以二进制格式存放在文件中 -A 所有报告的总和 -u 输出cpu使用情况的统计 -v 输出inode、文件和其他内核表的统计信息 -d 输出每一个块设备的活动信息 -r 输出内存和交换空间的统计信息 -b 显示l/O和传送速率的统计信息 -a 文件读写情况 -c 输出进程统计信息，每秒创建的进程数 -R 输出内存页面的统计信息 -y 终端设备活动情况 -w 输出系统交换活动信息 vmstat监控工具 vmstat 2 10 每隔两秒采集10次 r—表示运行队列 b—表示阻塞的进程 swap—-虚拟内存已经使用的大小 si—-每秒从磁盘读入虚拟内存的大小 sp—每秒虚拟内存写入磁盘的大小 in—-每秒cpu的中断次数 sy—-系统cpu时间 id—-空闲cpu时间 wt—–等等lO cpu 时间 iostat 主要可以显示cpu和1/O系统的负载情况及分区状态信息 直接执行iostat lsof 主要查看端口 lsof -i 22 查看端口为22 的服务 losf -g gid 显示归属gid的进程情况 lsof -i 用以显示符合条件的进程情况 echo $$ 当前进程号 kill -9 5641 杀死（结束）5641进程 strace 跟踪进程执行时的系统调用和所接受的信号。 Find 详解 常见用法 -name filenname #查找名为filename的文档 -perm #按执行权限来查找 -user username #按文档属主来查找 -group groupname #按组来查找 -mtime -n +n #按文档更改时间来查找文档 -n指n天以内，+n指n天以前 -group groupname #按组来查找 -type b/d/c/p/l/f #查是块设备、目录、字符设备、管道、符号链接、普通文档 -size n[C] #查长度为n块[或n字节]的文档 -prune #忽略某个目录","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"}]},{"title":"Linux NFS网络文件","slug":"Linux/Linux-NFS网络文件","date":"2020-04-25T11:13:31.000Z","updated":"2020-09-11T08:45:25.873Z","comments":true,"path":"posts/10415.html","link":"","permalink":"http://www.a2data.cn/posts/10415.html","excerpt":"Linux 手把手教你搭建NFS网络文件系统。","text":"Linux 手把手教你搭建NFS网络文件系统。 NFS网络文件系统 1.功能：文件共享 2.协议与端口： 需要RPC进行控制 NFS安装yum install nfs-utils protmap（端口分放） 服务机 ip 221vim /etc/exports （配置文件） /aa 192.168.18.220/255.255.255.0(rw) 根下aa 共享（客户机）ip/子掩网码 rw 读写 ro 只读 cd / 切换到根下 mkdir aa 创建aa目录 touch aa/abc.txt 创建aa下abc文档 service nfs restart 重启nfs服务 客户机 ip 220showmount -e 192.168.18.221 cd / mkdir pub 创建pub 文件 mount 192.168.18.220:/aa pub 挂载到aa/pub 切换到服务机 更改权属 ll -d aa 查看aa权限 chmod o+w aa 修改aa权限（o 其他人） service nfs restart 重启服务 切换到客户机 cd pub/ vim abc.txt 修改 touch aa.txt 创建一个文件 切换到服务机 cd aa ls aa 查看是否有文件 配置Sambasamba 软件包 samba.i386 : The Samba SMB server. samba-client.i386 : Samba (SMB) client programs. samba-common.i386 : Files used by both Samba servers and clients. 安装samba mount /dev/cdrom /mnt 挂载 切换到挂载目录进行配置 cd /mnt/Server/ vim /etc/yum.repos.d/qq.repo r /etc/yum.repos.d/rhel-debuginfo.repo yum -y install samba 编辑文件cd /etc/samba/ 切换 vim smb.conf 配置文件 vim /etc/samba/smb.conf security=share ---共享 找见[public] 7yy 复制7行 p 粘贴 修改[aa] --- 这是昵称 comment = nidaye ---注释信息 path = /aa ---要共享的目录 public = yes ---公共的匿名用户可以访问的 writeable = yes ---可被写 browseable = yes ---可被浏览 查看cd / ls mdkir qq 返回根下查看 创建qq文件 cd qq touch aa.txt 切换到qq下创建aa文档 service smb restart 重启smb服务 修改文件权限1、 chmod o+w /aa 2、 cd /aa chmod 777\\* Linux客户端 smbclient -L //192.168.18.221—查看共享信息 smbclient //192.168.18.221/share-进入共享目录 ? 查看有哪些命令可以使用 ls 查看共享目录下有哪些内容 windows客户端 \\192.168.18.221 —可以看到共享目录","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"}]},{"title":"Linux Apache论坛","slug":"Linux/Linux-Apache论坛","date":"2020-04-25T11:13:14.000Z","updated":"2025-05-05T06:09:14.853Z","comments":true,"path":"posts/41055.html","link":"","permalink":"http://www.a2data.cn/posts/41055.html","excerpt":"Linux 手把手教你搭建Apahce论坛","text":"Linux 手把手教你搭建Apahce论坛 搭建一个Apache论坛该论坛是再虚拟机环境下运行，实机一样得操作。 恢复快照，检测是否有 阿帕奇 service httpd restart 源代码安装的 进入apache目录 删除即可 yum源安装的 使用 rmp卸载 一、挂载mount /dev/cdrom /mnt 挂载镜像文件到/mnt ls /mnt/Server/ 查看是否有文件 vim /etc/yum.repos.d/aa.repo 配置yum文件 二、安装*【注：\\* 为安装http 下所有包】 1.yum -y install http\\* （先装阿帕奇服务） 2.yum -y install mysq\\* （数据库） 3.yum -y install php\\* （php开发语言） 三、启动service httpd restart 启动阿帕奇 service mysqld restart 启动mysq 再去启动论坛包（Discuz_X2_SC_UTF8）copy到虚拟机 四、解压（zip压缩包）cd /root/Desktop 切换到桌面 unzip Discuz_X2_SC_UTF8 解压Discuz到桌面 cp -r upload /uar/www/html/ 复制upload文件到html cd /dav/www/html ls 切换到html 查看是否有upload文件 （恢复快照）重新配置ip vim /etc/sysconfig/network-scripts/ifcfg-eth0 ifdown eth0 &amp;&amp; ifup etho ping通（192.168.18.222）--本机 使用本机或者虚拟机浏览器进行访问 192.168.18.221 Red Hat 192.168.18.221 upload 五、安装192.168.18.221/upload进入Dis 安装向导 修改阿帕奇权属权限 chown apache upload html -R （-R递归修改所有权属） 六、创建数据库mysql 进入数据库 show databases； 显示当前数据库 create database hehe; 创建 hehe grant all on hehe.\\* to ‘hh’@‘localhost’ identified by ‘123456’; (密码 ，授权） 数据库名：hehe 数据库用户名：hh 密码：123456 错误情况方案整理：1、数据库模版错误 yum -y install php-\\* 2、安装http中过程中途停止 yum -y install httpd-devel 3、安装mysql时出错 yum -y install mysql-connector-odbc 4、想卸载已安装http（apache）时，需在挂载镜像。 yum -y remove http\\* 5、配置yum（配置服务器中文包） yum install fonts-chinese.noarch yum install m17n-db-common-cjk yum install m17n-db-chinese","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"}]},{"title":"Linux 计划任务","slug":"Linux/Linux-计划任务","date":"2020-04-25T11:12:39.000Z","updated":"2020-09-11T08:45:25.876Z","comments":true,"path":"posts/39704.html","link":"","permalink":"http://www.a2data.cn/posts/39704.html","excerpt":"计划任务","text":"计划任务 计划任务date----当前时间 ctrl+D 保存 Atq 查看任务列表 Atrm 删除任务 At 一次性计划任务 命令：at + 时间 Crontab 周期性计划任务 服务脚本名称： /etc/init.d/crond crontab -e [-u 用户名] 编辑计划任务 crontab -l [-u 用户名] 查看计划任务 crontab -r [-u 用户名] 删除计划任务 周期条件 分 时 日 月 周 执行内容 0-59（整数） 0-23（整数） 1-31(整数） 1-12（整数） * run_command 50 3 2 1 * 执行命令或脚本 例如： 30 18 */3 * 1,3，5 /bin/rm-rf /var/ftp/pub/* 30 18 */3 * 1,3,5 /bin/rm -rf /var/ftp/pub/* 每隔3天在周1,3,5来清除FTP服务公共目录. * ， - / 表示该范围内的任意时间 表示间隔的多个不连续时间点 表示一个连续的时间范围 指定间隔的时间频率","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"}]},{"title":"Linux SSH协议","slug":"Linux/Linux-SSH协议","date":"2020-04-25T11:12:22.000Z","updated":"2020-09-11T08:45:25.869Z","comments":true,"path":"posts/630.html","link":"","permalink":"http://www.a2data.cn/posts/630.html","excerpt":"Linux SSH协议。","text":"Linux SSH协议。 SSH 协议默认端口 ：TCP：22 FTP:21 SSH:22 Apache（阿帕奇）：80 步骤1： ping 192.168.18.221 （ping得通） 步骤2：ssh [root@192.168.18.221](mailto:root@192.168.18.221) 输入密码 进入服务端 步骤3： exit 退出服务端 ssh-keygen -t rsa(或者dsa) 客户机生成密钥 步骤4：ssh-copy-id -i .ssh/id_rsa.pub [root@192.168.18.221](mailto:root@192.168.18.221) 将密钥上传输到服务端。 步骤5：输入服务端密码 exit 再次输入 ssh [root@192.168.18.221](mailto:root@192.168.18.221) 便可直接进入！","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"}]},{"title":"Linux Mdadm案例","slug":"Linux/Linux-Mdadm案例","date":"2020-04-25T11:12:05.000Z","updated":"2020-09-11T08:45:25.892Z","comments":true,"path":"posts/61794.html","link":"","permalink":"http://www.a2data.cn/posts/61794.html","excerpt":"Linux Mdadm 案例 raid5。","text":"Linux Mdadm 案例 raid5。 Mdadm 案例 raid5一、添加RAID5mdadm -C /dev/md5 -l 5 -n 3 /dev/sd[b,c,d] 二、创建文件系统 格式化：mkfs.ext3 /dev/md5 makir /raid5 三、挂载文件系统 mount /dev/md5 /raid5 挂载文件系统 df -hT 查看 RAID容错mdadm /dev/md5 -f /dev/sdb 损坏磁盘b mdadm -D /dev/md5 查看 mdadm /dev/md5 -a /dev/sdf 增加一块磁盘 mdadm /dev/md5 -r /dev/sdb 移除坏磁盘 echo &quot;DEVICE /dev/sdc /dev/sdd /dev/sde /dev/sdf&quot; &gt;&gt;（写入到哪） /etc/mdadm.conf 把UUID 写入 /etc/.......文件中 mdadm -Ds &gt;&gt; /etc/mdadm.conf 把UUID 读写出来 cat /etc/mdadm.conf mdadm -S --scan /dev/md5 关闭RAID（需要卸载md5） mdadm -A --scan /dev/md5 开启RAID 恢复快照！","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"}]},{"title":"Linux逻辑卷","slug":"Linux/Linux逻辑卷","date":"2020-04-25T11:11:47.000Z","updated":"2020-09-11T08:45:25.872Z","comments":true,"path":"posts/40711.html","link":"","permalink":"http://www.a2data.cn/posts/40711.html","excerpt":"Linux 逻辑卷得操作指南。","text":"Linux 逻辑卷得操作指南。 LVM逻辑卷 创建lvm 创建物理卷__PV pvcreate /dev/sdb,c,d,e (创建pv） pvdisplay(显示pv） 创建卷组 vgcreate /dev/feng_vg /dev/sdb,c,d,e(创建vg） vgdisplay (显示vg） 拓展vg pvcreate /dev/sdf(创建一个新的pv） vgextend feng_vg /dev/sdf (扩展vg) 减少vg vgreduce feng_vg /dev/sdc,d,e 移除vg vgremove feng_vg 创建LV lvcreate -L 30G -n feng_lv feng_vg 格式化 mkfs.ext3 /dev/feng_vg/feng_lv 挂载 mount /dev/feng_vg/feng_lv /aa 增加 先卸载 umount /aa lvextend -L +10G /dev/feng_vg/feng_lv（检测硬件） resize2fs /dev/feng_vg/feng_lv （重设文件系统大小） 减少LV先卸载 （输入卸载名称或者目录） umount /dev/feng_vg/feng_lv 缩小lv先缩小文件系统再缩小lv e2fsck -f /dev/feng_vg/feng_lv （检测硬件） resize2fs /dev/feng_vg/feng_lv 9g （将文件系统缩小到9G） 缩小lv lveduce -L 9G /dev/feng_vg/feng_lv 移除lv lvremove /dev/feng_vg/feng_lv 移除pv pvremove /dev/sdb1 /dev/sdb2 lv 使用pe（默认4M） 的块 lvcreat -l (小写） 个数 lvcreat -L (大写） 指定容量","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"}]},{"title":"Linux磁盘管理","slug":"Linux/Linux磁盘管理","date":"2020-04-25T11:11:29.000Z","updated":"2020-09-11T08:45:25.889Z","comments":true,"path":"posts/37426.html","link":"","permalink":"http://www.a2data.cn/posts/37426.html","excerpt":"Linux 磁盘管理。","text":"Linux 磁盘管理。 磁盘管理查看磁盘fdisk -l fdisk /dev/sdb 磁盘分区 指令 m l list known partition 列出所有的分区 n add a new partition 创建一个新的分区 p print the partition table 打印分区内容 t change a partition&#39;s system id 改变分区系统id w write table to disk an exit 保存并退出分区 d delete a partition 删除一个分区 查看分区fdisk -l fdisk /dev/sdb 磁盘分区 n----创建 d----删除 交换分区fdisk /dev/sdb格式化为 swap 命令 mkswp /dev/sdb1 设置分区mkswap /dev/sdb1 (做成交换文件系统） free 查看一下内存 swapon /dev/sdb1 开启交换内存 free 查看内存 swapoff /dev/sdb1 关闭交换内存 free 最后查看 是否存在 文件系统umount 卸载 mount 挂载 1、创建 mkfs - t ext3 /dev/sdb1 mkfs ext3/dev/sdb1 挂载 mount /dev/sdb /mnt 查看 df -hT","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"}]},{"title":"Linux系统程序","slug":"Linux/Linux系统程序","date":"2020-04-25T11:11:14.000Z","updated":"2020-09-11T08:45:25.887Z","comments":true,"path":"posts/60364.html","link":"","permalink":"http://www.a2data.cn/posts/60364.html","excerpt":"Linux 系统程序篇。","text":"Linux 系统程序篇。 系统程序 系统程序管理RPM包 （Red Hat） 命名格式 ： bash-3.1-16.1.i386.rpm 软件包名-版本号-发布次数-硬件平台-后缀名 rpm管理命令 rpm -q [子选项] 【软件名】 rpm -qa 查看系统中已安装的所有rpm软件包列表 rpm -qpi 通过.rpm 包文件查看该软件的详细信息 rpm -qpl 查看.rpm安装包内所包含的目录.文件列表 安装 rpm -i rpm包文件 安装一个新的rpm软件包 rpm - U 升级某个rpm软件包，若原本未安装，则进行安装 rpm -F 更新某个rpm 软件，若原本未安装，则放弃安装 安装 步骤1： tar 解包 步骤2： ./configure 配置 步骤3： make 编译 步骤4： make instal 步骤5: service httpd restart service network restart 步骤6: cd /var/www/ Yum本地：Yum(file本地） 命令： cd /etc/yum.repos.d/xd 挂载： 1. 挂载光盘镜像到/mnt mount /dev/cdrom /mnt 2. 配置yum源 vim /etc/yum.repos.d/xxx.repo [xxx] baseurl=file:///mnt/Server(flie本地) enabled=1(是否启动文件 0否 1是） gpgcheck=0 3. 安装 yum -y install 软件名称 （vsftpd） 4. 重启 yum service vsftpd start 服务器Yum ------服务器yum 0、命令： cd /etc/yum.repos.d/ 1、服务器端提供共享 -- 服务器安装一个ftp -- 把光盘镜像挂载ftp的共享目录 挂载： mount /dev/cdrom /var/ftp/pub 必须保证两台机器能够正常通信（能够ping通） 2、配置客户端 vim /etc/yum.repos.d/xxx.repo [xxx] baseurl=[ftp://192.168.18.221/dev/cdrom](ftp://192.168.18.221/dev/cdrom) /var/ftp/pub 【服务器ip地址及共享目录】 enabled=1(是否启动文件 0否 1是） gpgcheck=0 开启 service vsftpd start 卸载 rpm -e 软件名 源代码（灵活定制） tarball 封包 tar.gz 或者 tar.bz2 效验工具 md5 sum","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"}]},{"title":"Linux网络设置","slug":"Linux/Linux网络设置","date":"2020-04-25T11:10:58.000Z","updated":"2020-09-11T08:45:25.891Z","comments":true,"path":"posts/37390.html","link":"","permalink":"http://www.a2data.cn/posts/37390.html","excerpt":"Linux 网络设置配置。","text":"Linux 网络设置配置。 网络设置 存放位置 —- 以RedHat为例 /etc/sysconfig/network-scripts/ifcfg-etc0 修改ipsetup 交互式图形化工具 vim /etc/sysconfig/network-scripts/ifcfg-eth0 修改 DNS/etc/resolv.conf 修改主机名vim /etc/sysconfig/network 网卡控制1.ifdown 关闭网卡 丨 ifup 开启网卡 2.service network stop 丨 start 丨restart 停止 开启 重启 开机自启动chkconfig httpd on 开机自动挂载 设置开机自动挂载的路径这个是当时学习在虚拟机上使用的多。 /etc/fstab 网络配置IP：是一个逻辑地址，是由32位二进制构成 ------------------------------------------------------- setup vim /etc/sysconfig/network-scripts/ifcfg-eth0 DEVICE=eth0 网卡 BOOTPROTO=none 是否自动获取IP ---&gt; dhcp HWADDR=00:0c:29:d6:96:fb MAC地址 ONBOOT=yes 是否随网络服务启动，eth0生效 NETMASK=255.255.255.0 子网掩码 IPADDR=192.168.18.76 IP地址 TYPE=Ethernet 类型为以太网 ------------------------------------------------------ 修改DNS vim /etc/resolv.conf search localdomain nameserver 192.168.40.2 nameserver 202.106.0.20 联通 nameserver 114.114.114.114 nameserver 8.8.8.8 谷歌 nameserver 4.4.4.4 谷歌","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"}]},{"title":"Linux权限控制","slug":"Linux/Linux权限控制","date":"2020-04-25T11:10:30.000Z","updated":"2020-09-11T08:45:25.898Z","comments":true,"path":"posts/16586.html","link":"","permalink":"http://www.a2data.cn/posts/16586.html","excerpt":"Linux 权限控制详解。","text":"Linux 权限控制详解。 权限控制属组权限 字符制表示八进制 000 - 777 字符表示法 八进制表示法 含义 r 4 读 w 2 写 x 1 执行 修改权限的命令 【 su - u2 切换用户】 1、 chmod 修改文件权限 2、 chown，chgrp 修改文件权属 U----所有者 O----其他人 a-----所有人 g-----所属组 chomd a=rwx root 所有都拥有读写执行权限 cat /etc/passwd|grep -v nologin|grep -v halt|grep -v shutdown|awk -F&quot;:&quot; &#39;&#123; print $1&quot;|&quot;$3&quot;|&quot;$4 &#125;&#39;|more 用户控制命令 useradd 添加用户 useradd -g 指定用户所属用户组 useradd -G 用户组 指定用户所属的附加组 useradd -u 用户号 指定用户的用户号 命令：指定用户所属组 useradd -g 组名 -u 用户号 用户名 例如 useradd -g g3 -u 510 u5 指定用户附属组 useradd -g 组名 -G 所在组 用户名 例如: useradd -g g4 -G g1 u7 修改账户信息 usermod 修改账户信息 usermod -g 用户组指定用户所属的用户组 usermod -l 锁定账号 usermod -u 解锁账号 userdel 删除账户 userdel -r 删除宿主目录 设置密码 passwd 设置密码 passwd -l 锁定账号 passwd -u 解锁账号 passwd -s 查看账号状态 usermod -L u1 u1账号被锁定 usermod -U u1 u1账号被解锁 passwd u1 设置u1 账号密码 linux 组账户 groupadd 添加组成员 groupdel 删除组成员 gpasswd 设置组成员 -a 添加成员 -d 删除成员 -M 定义成员列表 gpasswd -a u1 g1 将u1加入到g1组中 gpasswd -M u1,u2,u3,u4,u5 g2 将u1到u5添加g2组里","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"}]},{"title":"Linux基本操作","slug":"Linux/Linux基本操作","date":"2020-04-25T11:10:17.000Z","updated":"2020-09-11T08:45:25.867Z","comments":true,"path":"posts/46411.html","link":"","permalink":"http://www.a2data.cn/posts/46411.html","excerpt":"Linux 基本操作。","text":"Linux 基本操作。 本文精心整理，如需转载，请联系小编。谢谢。相关安装包可以加小编获取。 服务器路径 命令符号 释义 / 根目录 /bin 二进制可执行命令 /dev 设备特殊文件 /etc 系统管理和配置文件 /etc/rc.d 启动的配置文件和脚本 /home 用户主目录的基点 /lib 标准程序设计库 /sbin 超级管理命令 /mnt 系统提供这个目录是让用户临时挂载其他的文件系统 /root 系统管理员的主目录 /Lost+found 这个目录平时是空的， 系统非正常关机而留下“无家可归”的文件 /proc 虚拟的目录，是系统内存的映射 /usr 应用程序和文件几乎都在这个目录. /var 某些大文件的溢出区 boot 内核文件 Linux 系统文件（100MB-200MB） 服务器500MB opt 临时文件 常用快捷键图形界面 到 字符界面Ctrl Alt Fn （F1-----F6） init 3 字符界面 到 图形界面 Alt F7 init 5 Tab键 ：自动补齐 反斜杠\\ ：强制换行 ctrl+u 清空至行首 ctrl+k 清空至行尾 ctrl+L 清屏 ctrl+c 取消本次命令编辑 touch 创建文件 mkdir 创建目录 mkdir -p 创建嵌套的多层目录结构 cd 切换工作目录 cd - 切换两个目录 cd .. 返回上个目录 du 统计目录及文件 du -s 只统计大小 du -a 统计所有文件 du -h 人性化显示 du -sh \\* 查看所有文件及大小 pwd ------- 查看当前所在位置 vim ------查看日志（编辑器） Ls ------ 打印（当前目录下所包含的内容）ls 显示目录内容（ls=ll） ./ ------直接运行脚本 查看帮助help， -help man info （man ls） 常用命令 uname 查看系统信息及内核版本（-a 显示主机；-r 显示内核版本） hostname 查看主机名 vim /etc/sysconfig/network 更改主机名 ifconfig 查看网络信息 shutdown -h now | poweroff | init 0 关闭计算机 shutdown -r now | reboot | init 6 重启计算机 Ln软链Ln链接文件 Ln 要链接的文件 链接到什么地方 ln 创建链接文件 ln -s 软链接 ln 硬链 CP 复制cp -r 递归复制整个目录树 cp=cp-i cp -r 递归复制 cp -p 保持源文件的属性不变 cp -f 强制覆盖目标同名文件或目录 cp -i 需要覆盖文件或目录时进行提醒 RM 删除rm -rf 递归强行删除文件或者目录 不进行提醒 rm -f 强行删除文件或者目录，不进行提醒 rm -r 递归删除整个目录树 rm - i 删除文件或者目录时提醒用户确认 MV 移动（改名）Cat 查看文件 More 分页查看文件 （不可返回） Less 分页查看文件 （可返回） Head 查看文件头（前10行） Tail 查看文件尾 （后10行） WC 统计wc -l 统计行数 wc -w 统计单词个数 wc -c 统计字节数 压缩指令 压缩 （仅限文件） gzip bzip2 表示高压缩比： gzip -9 bzip2 -9 解开已经压缩的文件 gzip -d bzip2 -d Tar 归档 口令打包压缩： Tar 要打包压缩到什么地方 要打包压缩的文件 单个解释用法： tar -c 创建 . tar格式的包文件 tar -x 解开. tar格式的包文件 tar -v 查看详情信息 tar -f 表示使用归档文件 tar -p 打包时保留原始文件及目录的权限 tar -t 列表查看包内文件 tar -C 解包时指定释放的目标文件夹 tar -z 调用gzip程序进行压缩或者解压 tar -j 调用bzip2 程序进行压缩或者解压 组合命令： tar -cvf 打包 tar -zcvf 打包压缩 tar -zcvf XXX.tar.gz XX tar -xvf 解压 tar -xvf xxxx.tar.gz -C aaa 解压到指定目录 打包压缩---- tar -zcvf 解压 ----- tar -zxvf 指定位置解压--- tar -zxcf -C xx.bz2用bzip2 -d解压 xx.gz用gzip -d解压 xx.tar.gz 用-zxvf解压 xx.tar.bz2用-jxvf解压 常用 打包： 1、tar -zcvf a2data.tar.gz ./a2data.cn/* 2、tar -zcvf a2data.tar.bz2 ./a2data.cn/* ---- 将a2data.cn文件夹下统一打包 ------ 解压(万能)： tar -xf a2data.tar.bz2 ./ ---- 解压到当前路径下---- VI 编辑器命令模式: vim/vi ESC 输出模式: a、i、o等键 末行模式： (大写)A键 工作模式：命令模式 输入模式 末行模式 a #光标后面写 i #光标前面写 o #下一行写 dd #删一行 n+dd #删几行 d$ #删除光标后面的同一行 （删光标） d^ #删除光标前面的同一行 （不删光标） x #删光标 X #删光标前面的 yy #复制 p #黏黏到下一行 P #黏黏到上一行 u #撤销上一步 U #撤销这一行的所有修改 :q! #不保存退出 :w #保存 :wq #保存退出 :/ #搜索的东西 搜索什么 从上到下搜索 % #搜索的东西 搜索什么 从下到上搜索 行号 :set nu #设置行号 :set nonu #不要行号了 跳转到首行gg 跳转到尾行G \\#G跳转到到第几行 ：e/etc/passwd 打开新的编辑文件 ：r/etc/passwd 读入其他文件内容 文件内个替换 s/old/new 替换行里的一个old换成new s/old/new/g 整行替换 old换成new #，#s/old/new/g #到#行替换 old换成new %s/old/new/g 整篇替换 old换成new c 末尾加入c 对每个替换提示用户进行确定","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"}]},{"title":"Hexo博客疑难杂症","slug":"Hexo/Hexo博客疑难杂症","date":"2020-04-19T10:57:28.000Z","updated":"2025-05-05T06:08:16.268Z","comments":true,"path":"posts/f92cb63f.html","link":"","permalink":"http://www.a2data.cn/posts/f92cb63f.html","excerpt":"Hexo 疑难杂症","text":"Hexo 疑难杂症 墙裂推荐Hexo博客前言 www.a2data.cn —– 小编小站 Q: 为什么要搭建一个属于自己的个人博客呢？ 个性化 用自己喜欢的域名，选择自己喜欢的主题，布局，特效等都可以自己编写代码完成，不会的也可以进入对应开源主题交流群, 你会发现这些人更加随和、热心,例如闪烁之狐主题的创作者 — blinkfox 成就感 当网站被搜索引擎收录，输入相应关键字即可，可以小小的炫耀一番 拓展交流圈 如果你对某类感兴趣的话，可以通过个人博客找到一些志同道合的朋友。例如：sitoi 学会坚持 刚开始搭建好属于自己的博客，那真的是三分钟热度，但是真的坚持下来的人很少.很多人就跑个主页,就像很多公众号一样,注册了没创作。小编虽然是体育僧，不论是跨行，还是博客,公众号，都坚持(没发表可能是忙,或者持续充电中)。 简历加分项 当我们苦于该如何写一份个人简历时，当你拿出一个你坚持 3 年、5 年的个人博客时，或许你的机会就比别人大一点。更直观，更好的了解你得技术栈。更有信服力。 个人空间 在这个地方，你可以写一些自己的东西(不管有没有人看)，你可以自己快速定位自己查找过的东西，不用每次都去百度同样的问题，也不用担心每次找不到最优解 以至于很多朋友直接去我的网站找资料 写作水平的提高 坚持写作，你的写作水平会得到很到的提高，对你今后的人生会有很大的帮助。包括语言，架构，排版 。。 总之短期是看不出效果的，只有长期坚持。 好比： 你去学习一个月跆拳道，你说你会，一个练了十年的人，同样是一拳一腿 跟你有可比性吗？ 赚取一点钱 当你的博客足够好，公众号粉丝足够多，内容足够丰富，你可以开始尝试赚钱，当然啦，和坚持是离不开的。 折腾中学会知识，互访中找到友情，写作中读懂人生，坚持中找到方向。 比如 像小编的目标一直没变，用大数据人工智能推动传统行业的发展而奋斗！！！ 心动，为何不动？ 相信大家刚开始都是这么想的,搭建博客？ 需要具备： 网站,域名,备案 服务器 自己写代码(前端+后端+服务器部署) … …… 啊，我太南了 —– 臣妾做不到啊 不要慌，问题不大！没关系,小编一步步带你飞。教你如何从零开始拥有属于自己的博客网站。(仅面向Windows用户,就会有人问Mac 不香吗？ 香，但是太贵，买不起,也不太会用!) 小编推荐： windows神器： utools 生成力工具集:https://www.u.tools/ 环境准备: Node.js Hexo Git GitHub SSH key Coding Typora (Md格式书写工具) idea(就是编辑工具,推荐webstorm) 拓展： 服务器部署 域名配置 PWA离线访问 SEO优化 加速访问 ……… 安装Node.js 中文网：https://nodejs.org/zh-cn/download/ 官方网站：https://nodejs.org/en/ 直接下载对应的安装包，之后一顿操作,跟安装QQ一样。 安装步骤如下： 选择安装 安装完成 查看是否安装成功 启动： win键(就是windows图标得那个按键) + R 输入： cmd 清空： cls 安装hexo npm install hexo-cli -g 输入npm install hexo -g，开始安装Hexo 输入 hexo -v 查看是否安装成功 创建博客方式1： # 方式1 一定要是一个空的文件夹 mkdir sqlsq.github.io cd sqlsq.github.io hexo init 方式2： hexo init sqlsq.github.io cd sqlsq.github.io 本地访问 到此，你已经可以搭建hexo 博客了，恭喜一波。 hexo 命令问题命令找不到解决方案 *首先可以安装一波 配置环境变量 找到这东西就好说了。配置一下环境变量即可。soeazy 设置之后再次查看 安装Git 官网：https://git-scm.com/downloads 下载直接默认下一步即可： 配置自己的ssh 桌面鼠标右键，点击Git Base Here。 # 设置 git 相关信息 git config --global user.name &quot;你得昵称&quot; git config --global user.email &quot;your.email&quot; # 生成密钥 ssh-keygen -t rsa -C &quot;youemail&quot; # a2data@vip@qq.com `连续回车 3连击` 即可完成密钥的生成创建。 查看密钥 cd ~/.ssh 输入cd ~/.ssh，检查是否由.ssh的文件夹 ls 查看 备份 单独一个 可以不用这样做 直接看下边快捷操作输入 eval “$(ssh-agent -s)”，添加密钥到ssh-agent 其实就是对ssh做了复制添加 eval &quot;$(ssh-agent -s)&quot; ssh-add ~/.ssh/id_rsa #添加生成的SSH key到ssh-agent 快捷操作 # 本部分需要在 github上使用，别着急请往下看。 cat id_rsa.pub Git拓展 此部分针对多个博客，多个key的，单独的跟着上边走即可。 参考博文配置：https://www.cnblogs.com/a2data/p/12597940.html 多个账号建议使用局部的。 # 取消全局 用户名/邮箱 配置 git config –global –unset user.name git config –global –unset user.email # 单独设置每个repo 用户名/邮箱 git config user.name &quot;用户名&quot; //在config后加上--global即全局 git config user.email &quot;邮箱&quot; 如下图： ssh-keygen -t rsa -f ~/.ssh/xxx_id_rsa -C &quot;yourmail@xxx.com&quot; 或者 ssh-keygen -t rsa -C &quot;yourmail@xxx.com&quot; #第一次时输入名字 注册Github 如果你有Github想体验一波删除，重新创建小编也不介意的。毕竟写教程，我也是操作了一波。 删除github登录github账号 *找到自己的邮件 重新注册 打开github官网：https://github.com 选择你得职业相关信息： 创建并且会给你发邮件激活： 登录邮箱激活： 配置Github 配置key 完成配置 测试配置是否成功输入ssh -T git@github.com，测试添加ssh是否成功。 输入yes， 如果看到Hi后面是你的用户名，就说明成功了 执行git port22 异常解决方案 应该是小编特殊情况导致。解决顺便做个记录。 新手忽略即可。 配置博客到Github 再你博客的根目录中(sqlsq.github.io) 配置Deployment，在其文件夹中，找到_config.yml文件，修改repo值（在末尾） 大概在 98行。 打开推荐方式： sublime text(未破解有广告) webstrom vscode ( 免费) deploy: type: git repository: git@github.com:nianshaofeng/nianshaofeng.github.io.git branch: master 回到你的项目 复制你得repo值 创建文章 如果使用GitBash 请到博客根目录执行。 Hexo命令# 全部命令 hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server） hexo deploy #部署到GitHub hexo help # 查看帮助 hexo version #查看Hexo的版本 # 缩写： hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy # 组合命令： hexo s -g #生成并本地预览 hexo d -g #生成并上传 发布部署# 在生成以及部署文章之前，需要安装一个扩展： 如下图 # mac 用户 需要加 `sudo` npm install hexo-deployer-git --save npm报错# 主要是镜像源的问题 npm config set registry http://registry.npmjs.org/ 查看部署首先先设置一下你得配置： 之后便会有你的域名： 打开结果一看 卧槽，无情。 这是什么鬼。 怎么跟我想要看的不一样（与本地不一样啊） 不要慌，问题不大。小编告诉你为什么。 重新创建项目，如下图。 我们看看问题在哪 1、https://minesql.github.io/sqlsq.github.io/ 2、https://minesql.github.io/ 我们将config.yml 地址换成第二次创建的项目地址。 再次提交。 我们再次访问看一下效果吧 目前小编博客： https://a2data.github.io/ https://www.a2data.cn/ 应朋友有要求，写了一篇炒鸡详细的，以及遇到的各种坑。 如果有帮助就收藏吧。 拓展内容下期见： 个性化主题 图床(为什么要有图床呢 自己研究) seo 等等","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.a2data.cn/tags/Hexo/"}]},{"title":"资料分享","slug":"Tools/资料分享","date":"2020-04-14T02:55:49.000Z","updated":"2020-09-11T09:28:58.963Z","comments":true,"path":"posts/45997.html","link":"","permalink":"http://www.a2data.cn/posts/45997.html","excerpt":"这里是分享资源整理学习资源，分享。","text":"这里是分享资源整理学习资源，分享。 示例 不断更新 本站链接已隐藏，关注公众号获取密码提取 链接: https://pan.baidu.com/s/1bLYT-nJf7UwT2Y_6xzS_5Q 提取码: g4ej 本站下载绝不收费，输入验证码后查看（防止机器采集被和谐）验证码：请关注本站微信公众号，回复“我要学习”，获取验证码。在微信里搜索“DataScience”或者“A2Data”微信扫描右侧二维码 function lock(){ var code =document.getElementById(\"verifycode\"); if(code.value !== '666888'){ alert(\"密码错误，请关注本站公众号获取\"); } else{ $('#link').html($('#link .code').html()); alert(\"密码输入正确，成功获取到链接\"); } } Document .user{ display: flex; background: bisque; padding: 10px; margin-bottom:10px; } .user ul { list-style: none; } document.getElementById(\"btn\").addEventListener(\"click\",Gethubdata); function Gethubdata(){ let her = new XMLHttpRequest(); her.open(\"GET\",'https://api.github.com/users',true);//第三个参数表示是否以异步的方式打开 her.onreadystatechange = function(){ if(this.readyState===4) { let data = JSON.parse(this.responseText); let output = \"\"; for (const key in data) { //下面用的了模板字符串，不了解的参见文末的文章推荐 output+=` id:${data[key].id} login:${data[key].login} type:${data[key].type} ` }; document.getElementById(\"users\").innerHTML = output; } }; her.send(); }; 表格 Document 课程表 星期一 星期二 星期四 星期五 语文 数学 英语 生物 ​","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/categories/Tools/"}],"tags":[{"name":"资料分享","slug":"资料分享","permalink":"http://www.a2data.cn/tags/%E8%B5%84%E6%96%99%E5%88%86%E4%BA%AB/"}]},{"title":"Hexo部署到码云","slug":"Hexo/Hexo部署服务器","date":"2020-04-07T08:15:10.000Z","updated":"2025-05-05T06:09:14.862Z","comments":true,"path":"posts/8f004046.html","link":"","permalink":"http://www.a2data.cn/posts/8f004046.html","excerpt":"Hexo 部署到Gitte","text":"Hexo 部署到Gitte Hexo 部署到码云 其实使用码云和使用github没有太大的区别，最近开始使用码云，为了避免忘记，还是做一下记录吧。 1、注册账号 码云网址：https://gitee.com/。 如果想以http://a2data.gitee.io这种一级域名的形式访问bolg，那么我们需要建立一个与自己个性地址同名的项目，如 https://gitee.com/a2data 这个用户，在创建项目时项目名称应该为A2Data。 2、创建仓库 3、复制项目 4、配置仓库 5、部署到码云# 这块会输入账号密码 ，稍后配置以下ssh 以后就不用输入账号密码了 hexo d 6、Page服务 启动服务 7、配置SSH 8、成功访问 https://sqlsq_admin.gitee.io/","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.a2data.cn/tags/Hexo/"}]},{"title":"手把手教你玩git","slug":"Git/手把手教你玩git","date":"2020-03-31T14:51:33.000Z","updated":"2025-05-05T06:07:54.186Z","comments":true,"path":"posts/47936.html","link":"","permalink":"http://www.a2data.cn/posts/47936.html","excerpt":"Git 深入浅出，史无前例的详细教程。","text":"Git 深入浅出，史无前例的详细教程。 0、查看本机公钥 步骤： 1、进入.ssh目录 cd ~/.ssh 2、找到id_rsa.pub文件 ls / ll 3、查看文件 cat id_rsa.pub JackFeng@JackFeng MINGW64 ~/Desktop $ cd ~/.ssh JackFeng@JackFeng MINGW64 ~/.ssh $ ls config id_rsa id_rsa.pub id_rsa_sql id_rsa_sql.pub known_hosts JackFeng@JackFeng MINGW64 ~/.ssh $ cat id_rsa.pub 1、配置多个git仓库多仓库之间 &#39;ssh-key切换&#39; #1、生成客户端自己的密钥对 ssh-keygen ---- 一顿回车即可 # 实际操作 换成你的邮箱即可 ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 可以在客户端的家目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥。 生成新的ssh-key #second@mail.com 工作邮箱地址 ssh-keygen -t rsa -C &#39;second@mail.com&#39; -f id_rsa_second 配置多个仓库 在.ssh目录创建config文本文件并完成相关配置(最核心的地方)每个账号单独配置一个Host，每个Host要取一个别名，每个Host主要配置HostName和IdentityFile两个属性即可 Host的名字可以取为自己喜欢的名字，不过这个会影响git相关命令，例如： HostName 这个是真实的域名地址IdentityFile 这里是id_rsa的地址PreferredAuthentications 配置登录时用什么权限认证–可设为publickey,password publickey,keyboard-interactive等User 配置使用用户名 config # 配置github.com Host github.com HostName github.com IdentityFile ~\\.ssh\\id_rsa PreferredAuthentications publickey User yinjie.feng # 配置SQLSQ Host SQL HostName github.com IdentityFile ~\\.ssh\\id_rsa_sql PreferredAuthentications publickey User yinjie.feng 测试是否调通 JackFeng@JackFeng MINGW64 ~/.ssh $ vim config JackFeng@JackFeng MINGW64 ~/.ssh $ ssh -T git@github.com Hi A2Data! You&#39;ve successfully authenticated, but GitHub does not provide shell access. JackFeng@JackFeng MINGW64 ~/.ssh $ vim config JackFeng@JackFeng MINGW64 ~/.ssh $ ssh -T git@SQL Hi MineData-SQL! You&#39;ve successfully authenticated, but GitHub does not provide shell access. git add、git commit、git remote add、git push需要说明的一点，在git commit 时需要一次身份验证，正确输入你的用户名和邮箱就可以了。 另外注意：github根据配置文件的user.email来获取github帐号显示author信息，所以对于多帐号用户一定要记得将user.email改为相应的email(monster@mail.com)。 总结一下:其实建立第二个密钥对的区别就在于对第二密钥对的声明，因此需要在.ssh目录下添加config文件，添加语句dentityFile ~/.ssh/id_rsa_sql声明这是第二个密钥对。这条连接命令就体现出来了。 查看用户名git config user.name git config user.email 修改用户名git config --global user.name &quot;xxx&quot; git config --global user.email &quot;xxx&quot; 2、从远程项目拉取git clone 项目地址 3、提交代码到远程仓库常规操作 ##添加 git add . . #查看状态 git status # 提交 git commit -m &quot;代码描述&quot; # 再次查看状态 git status # 拉取最新代码 git pull # 提交 git push 4、git分支操作Git初始化 解决 fatal: Not a git repository (or any of the parent directories): .git 问题 git init git clone --- 克隆项目 JackFeng@JackFeng MINGW64 /d/Practice $ git clone git@github.com:MineData-SQL/SQL.git Cloning into &#39;SQL&#39;... remote: Enumerating objects: 3, done. remote: Counting objects: 100% (3/3), done. remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 Receiving objects: 100% (3/3), done. 创建分支git branch &lt;branch_name&gt; #指定分支名称 git checkout -b [&quot;分支名&quot;] 查看分支git branch # 查看所有分支,* 号所属代表当前分支 git branch # 查看分支详情，包括分支指向得commitid及提交信息 切换分支git checkout &lt;branch_name&gt; #切换到指定分支 git checkout -b &lt;branch_name&gt; #创建并切换到指定分支 删除分支git branch -d &lt;branch_name&gt; .#删除一个干净的分支(即相对当前分支而言该分支没有新的提交记录) git branch -D &lt;branch_name&gt; .#强制删除一个分支，该分支有没有合并到当前分支的提交记录 注意：删除分支前都需要先切换到其他分支才能进行删除操作 分支恢复 思路：对于已经有提交记录的分支删除后，实际上只是删除指针，commit记录还保留，如果想恢复，需要使用git reflog查找该分支指向的 commitId，然后根据commitId创建新的分支 HEAD@&#123;1&#125; git reflog git branch &lt;branch_name&gt; &lt;hash_val&gt; #根据指定commit创建新分支 分支改名git branch -m &lt;branch_name&gt; newname JackFeng@JackFeng MINGW64 /d/Practice/SQL (master-two) $ git branch -m master-one master-O JackFeng@JackFeng MINGW64 /d/Practice/SQL (master-two) $ git branch master master-O * master-two 分支合并 git merge #将指定分支合并到当前分支如果两个分支没有产生分叉情况，那么会进行快速合并，即fast-forward方式，它并不会产生新的commitId，只是改变了指针的指向，产生分叉合并可能会有冲突情况。 示例： 合并master-O分支到master分支，此时合并为fast-forward方式 分支合并细节 git merge -ff -m &quot;msg&quot; #合并分支时禁用Fast forward模式 如果使用fast-forward方式进行分支合并，只是简单改变了分支指针，而不会产生新的commit记录。 为了保证合并数据的完整性，我们也可以在合并时指定不使用fast-forward方式，使用 --ff 选项。这样，在merge时就会生成一个新的commit，从日志上就可以看到分支合并记录了。 示例：我们在master-two分支上新增一次提交，然后合并到master分支上，git log查看最新一次的提交记录，显示的正是我们合并分支时的记录 git log --pretty=oneline -1 JackFeng@JackFeng MINGW64 /d/Practice/SQL (master) $ git checkout master-two Switched to branch &#39;master-two&#39; JackFeng@JackFeng MINGW64 /d/Practice/SQL (master-two) $ echo &quot; thank you for attention DataScience &quot; &gt;&gt; a2data.txt JackFeng@JackFeng MINGW64 /d/Practice/SQL (master-two) $ git add a2data.txt warning: LF will be replaced by CRLF in a2data.txt. The file will have its original line endings in your working directory JackFeng@JackFeng MINGW64 /d/Practice/SQL (master-two) $ git commit -m &quot; add file&quot; [master-two 59a8816] add file 1 file changed, 1 insertion(+) create mode 100644 a2data.txt JackFeng@JackFeng MINGW64 /d/Practice/SQL (master-two) $ git checkout master Switched to branch &#39;master&#39; Your branch is up to date with &#39;origin/master&#39;. JackFeng@JackFeng MINGW64 /d/Practice/SQL (master) $ git merge --ff -m &quot;meger master-two branch&quot; master-two Updating ab83ffb..59a8816 Fast-forward (no commit created; -m option ignored) a2data.txt | 1 + 1 file changed, 1 insertion(+) create mode 100644 a2data.txt JackFeng@JackFeng MINGW64 /d/Practice/SQL (master) $ git log --pretty=oneline -1 59a88161e630f0853b852946fddb6c7e787906fe (HEAD -&gt; master, master-two) add file 冲突解决 当对分叉分支进行合并时，如果两个分支都对同一文件进行了修改，那么合并时就有可能会产生冲突情况。 如果两个分支对同一文件的修改是有规律的，比如对不同地方的修改，那么git工具可以实现自动合并. 如果无法自动合并，则需要对冲突文件进行手动修改，修改完成后使用git add表示冲突已经解决，然后使用git commit进行提交 示例：在master分支上对两个文件进行修改提交. a2data.txt和*DataScience。 然后切换到master-O分支上对两个文件进行修改提交. 文件由于修改的是不同地方，所以自动合并。 我们查看DataScience文件的内容，==上面和下面的内容分别代表了不同分支的修改内容，将冲突标记去掉，然后内容根据需求进行恰当的修改，然后进行一次提交即完成了冲突的解决。 修改文件相同则会产生合并冲突 (merge conflict) master master-O 合并分支 分支同步 主要是 自己的分支与主分支保持同步。 步骤： 1、git remote add master &#103;&#105;&#x74;&#64;&#x67;&#105;&#x74;&#104;&#117;&#x62;&#x2e;&#99;&#111;&#109;:A2Data/A2Data.github.io.git // 主分支master 2、 git branch -v 查看是否添加 3、git fetch master // 获取主分支的最新修改到本地 4、git merge master/master-O // 将master分支修改内容merge到本地个人分支； // 该步骤或者可以分成2步： 1） # git checkout master-O； // checkout到master-O分支 2） # git merge master； //合并主分支修改到本地master分支； 5、git push //本地分支提交到github上的个人分支 分支暂存 git stash #将工作暂存git stash list #列出所有的暂存状态 从暂存区之中进行恢复，有两种处理方式：1.先恢复，而后再删除暂存git stash applygit stash drop2.恢复的同时也将stash内容删除git stash pop 当我们在分支上进行代码开发时，有可能会接到突发需求，而当前的代码尚未完成，所以还**不能直接提交。** 为了解决这样的问题，git就提供了分支暂存的机制，可以将开发一半的分支进行保存，在适当的时候进行代码恢复。 示例：在master-two分支上新建文件，然后添加到暂存区表示尚未完成的任务，对当前分支进行暂存，git status显示工作空间是干净的。 欢迎关注","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://www.a2data.cn/tags/Git/"}]},{"title":"带你玩转idea","slug":"Tools/带你玩转idea","date":"2020-03-31T14:51:10.000Z","updated":"2020-09-11T09:28:58.975Z","comments":true,"path":"posts/64846.html","link":"","permalink":"http://www.a2data.cn/posts/64846.html","excerpt":"IDEA 玩转详细教程","text":"IDEA 玩转详细教程 IDEA快捷键操作 颜色主题插件： **Material Theme UI Plugin ** 快捷键提醒： **Key Promoter X ** 查找Bug： QAPlig-FindBugs 热部署: JRebel 代码规范： Alibaba Java Coding Guidelines 字体推荐： Droid Sans Mono 代码检测：SonarLint(Sonarqube) 主题网站： http://www.riaway.com/index.php idea结合sonarLint进行的代码分析 idea结合sonar的话，可以下载sonarLint插件，操作步骤如下： 进入idea ，进入插件安装，在插件市场中搜索sonarLint，点击进行安装后重启idea； 配置sonarLint插件，设置settings中，查找到other settings,然后选择sonarLint General Setting ,在右侧的输入 接下来输入要连接的服务器的登录信息，如输入token或者是使用账号和密码的方式 配置当前的项目和sonar的关系,点击进入设置settings-&gt;other settings-&gt;SonarLint Project Settings Bind to Server 选择刚才配置的服务器信息。SonarQube project的选择可以点击Search in list查看sonar仓库中配置的项目信息，完成选择以后点击ok即可 代码分析，可以查看到当前的窗口中多了一个SonarLint的窗口（如无此窗口，可以点击analysis菜单进行查找），在其中选择report，点击文件夹图标，会弹窗提示，点击process之后即可进行项目分析。 JRebel 激活 GUIDS： https://www.guidgen.com/ 步骤： 步骤1:生成一个GUID：在线生成GUID地址 步骤2: 根据反向代理服务器地址拼接激活地址 服务器地址： https://jrebel.qekang.com/{GUID} Top1 循环.打印,Mainfori/sout/psvm+Tab 即可生成循环、System.out、main方法等boilerplate样板代码例如要输入for(User user : users)只需输入user.for+Tab 比如，要输入Date birthday = user.getBirthday(); 只需输入user.getBirthday().var+Tab即可。代码标签输入完成后，按Tab，生成代码。 Top2 类和包操作 Alt+Insert 生成代码(如get,set方法等) (右键 Generate） Ctrl+Alt+T 生成 try catch 或者 Alt+enter CTRL+ALT+T 把选中的代码放在 TRY{} IF{} ELSE{} 里 Ctrl + O 重写方法 Ctrl + I 实现方法 Ctr+shift+U 大小写转化 ALT+回车 导入包,自动修正 ALT+/ 代码提示 CTRL+空格 代码提示 CTRL+J 自动代码 Ctrl+Shift+J 整合两行为一行 CTRL+SHIFT+SPACE 自动补全代码 CTRL+ALT+L 格式化代码 CTRL+ALT+I 自动缩进 CTRL+ALT+O 优化导入的类和包 CTRL+E 最近更改的代码 CTRL+ALT+SPACE 类名或接口名提示 CTRL+P 方法参数提示 CTRL+Q 可以看到当前方法的声明 Shift+F6 重构-重命名 (包、类、方法、变量、甚至注释等) Ctrl+Alt+V 提取变量 Top3 查询快捷键 Ctrl＋Shift＋Backspace 可以跳转到上次编辑的地方 CTRL+ALT+ left/right 前后导航编辑过的地方 ALT+7 靠左窗口显示当前文件的结构 Ctrl+F12 浮动显示当前文件的结构 ALT+F7 找到你的函数或者变量或者类的所有引用到的地方 CTRL+ALT+F7 找到你的函数或者变量或者类的所有引用到的地方 Ctrl+Shift+Alt+N 查找类中的方法或变量 双击SHIFT 在项目的所有目录查找文件 Ctrl+N 查找类 Ctrl+Shift+N 查找文件 CTRL+G 定位行 CTRL+F 在当前窗口查找文本 CTRL+SHIFT+F 在指定窗口查找文本 CTRL+R 在 当前窗口替换文本 CTRL+SHIFT+R 在指定窗口替换文本 ALT+SHIFT+C 查找修改的文件 CTRL+E 最近打开的文件 F3 向下查找关键字出现位置 SHIFT+F3 向上一个关键字出现位置 选中文本，按Alt+F3 高亮相同文本，F3逐个往下查找相同文本 F4 查找变量来源 CTRL+SHIFT+O 弹出显示查找内容 Ctrl+W 选中代码 连续按会有其他效果 F2 或Shift+F2 高亮错误或警告快速定位 Ctrl+Up/Down 光标跳转到第一行或最后一行下 Ctrl+B 快速打开光标处的类或方法 CTRL+ALT+B 找所有的子类 CTRL+SHIFT+B 找变量的类 Ctrl+Shift+上下键 上下移动代码 Ctrl+Alt+ left/right 返回至上次浏览的位置 Ctrl+X 删除行 Ctrl+D 复制行 Ctrl+/ 或 Ctrl+Shift+/ 注释（// 或者/…/） Ctrl+H 显示类结构图 Ctrl+Q 显示注释文档 Alt+F1 查找代码所在位置 Alt+1 快速打开或隐藏工程面板 Alt+ left/right 切换代码视图 ALT+ ↑/↓ 在方法间快速移动定位 CTRL+ALT+ left/right 前后导航编辑过的地方 Ctrl＋Shift＋Backspace 可以跳转到上次编辑的地 Alt+6 查找TODO Top4 其它快捷键 SHIFT+ENTER 另起一行 CTRL+Z 倒退(撤销) CTRL+SHIFT+Z 向前(取消撤销) CTRL+ALT+F12 资源管理器打开文件夹 ALT+F1 查找文件所在目录位置 SHIFT+ALT+INSERT 竖编辑模式 CTRL+F4 关闭当前窗口 Ctrl+Alt+V 可以引入变量。例如：new String(); 自动导入变量定义 Ctrl+~ 快速切换方案（界面外观、代码风格、快捷键映射等菜单） Top5 svn快捷键 ctrl+k 提交代码到SVNctrl+t 更新代码 Top6 调试快捷键 常用的 F8 F7 F9 最值得一提的 就是 Drop Frame 可以让运行过的代码从头再来 alt+F8 debug时选中查看值 Alt+Shift+F9，选择 Debug Alt+Shift+F10，选择 Run Ctrl+Shift+F9，编译 Ctrl+Shift+F8，查看断点 F7，步入 Shift+F7，智能步入 Alt+Shift+F7，强制步入 F8，步过 Shift+F8，步出 Alt+Shift+F8，强制步过 Alt+F9，运行至光标处 Ctrl+Alt+F9，强制运行至光标处 F9，恢复程序 Alt+F10，定位到断点 Top7 重构 Ctrl+Alt+Shift+T，弹出重构菜单Shift+F6，重命名F6，移动F5，复制Alt+Delete，安全删除 Top8 Ctrl+Alt+N，内联Ø 命令： Ctrl+Shift+A 可以查找所有Intellij的命令，并且每个命令后面还有其快捷键。所以它不仅是一大神键，也是查找学习快捷键的工具。 Ø 新建： Alt+Insert可以新建类、方法等任何东西。 Ø 格式化代码： 格式化import列表Ctrl+Alt+O，格式化代码Ctrl+Alt+L。 Ø 切换窗口： Alt+Num，常用的有1-项目结构，3-搜索结果，4/5-运行调试。Ctrl+Tab切换标签页，Ctrl+E/Ctrl+Shift+E打开最近打开过的或编辑过的文件。 Ø 单元测试： Ctrl+Alt+T创建单元测试用例。 Ø 运行： Alt+Shift+F10运行程序，Shift+F9启动调试，Ctrl+F2停止。 Ø 调试： F7/F8/F9分别对应Step into，Step over，Continue。 Top9 自定义Ø 水平分屏 Ctrl+| 小功能Ctrl+Shift+V粘贴很早以前拷贝过的， Alt+Shift+Insert进入到列模式进行按列选中。 Ø切来切去： Ctrl+Tab Ø选你所想： Ctrl+W Ø代码生成： Template/Postfix +Tab Ø发号施令： Ctrl+Shift+A Ø无处藏身： Shift+Shift Ø自动完成： Ctrl+Shift+Enter Ø创造万物： Alt+Insert Top10 舍我其谁Ø智能补全： Ctrl+Shift+Space Ø自我修复： Alt+Enter Ø重构一切： Ctrl+Shift+Alt+T CTRL+ALT+ left/right 前后导航编辑过的地方Ctrl＋Shift＋Backspace可以跳转到上次编辑的地","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/categories/Tools/"}],"tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://www.a2data.cn/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}]},{"title":"GitBook","slug":"Tools/GitBook","date":"2019-12-30T07:44:58.000Z","updated":"2020-09-11T09:28:58.965Z","comments":true,"path":"posts/44947.html","link":"","permalink":"http://www.a2data.cn/posts/44947.html","excerpt":"‘GitBook文档，安装使用’","text":"‘GitBook文档，安装使用’ GitBook1、安装 安装和使用GitBook 完成GitBook的安装只需要几分钟。 GitBook.com GitBook.com为您提供简单高效的图书在线撰写、发布和托管方案， 你可以通过 进行在线编辑、或者使用GitBook 本地编辑器在本地电脑上编辑。 本地安装 要求 GitBook的安装非常简单。 您的系统只需满足这两个要求： NodeJS（推荐使用v4.0.0及以上版本） Windows，Linux，Unix或Mac OS X 使用NPM安装 安装GitBook的最好方法是通过 NPM 安装。 在已经安装好NodeJS和NPM的电脑上，通过命令行窗口，输入以下命令安装GitBook： npm install gitbook-cli -g gitbook-cli 2、使用 创建一本书 gitbook init 如果你想用现有的目录来创建一本书，你可以通过运行 gitbook init ./directory来实现 使用下面的命令预览您创建的图书： gitbook serve 或者使用以下命令构建静态网站： gitbook build 安装其他版本gitbook命令可以方便地下载和安装不同版本的GitBook来测试你的书：$ gitbook fetch 4.0.0-alpha.1 使用gitbook ls-remote列出可用于安装的远程版本。 $ gitbook ls-remote Available GitBook Versions: 4.0.0-alpha.5, …部分省略…, 4.0.0-alpha.1, 3.2.2, 3.2.1, …部分省略…, 2.0.0-alpha.1 Tags: latest : 3.2.2 pre : 4.0.0-alpha.5 调试 您可以使用–log=debug和–debug来获得更详细的错误消息（堆栈跟踪）。例如： $ gitbook build ./ –log=debug –debug or $ gitbook serve ./ –log=debug –debug","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/categories/Tools/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/tags/Tools/"}]},{"title":"14.Python强化练习","slug":"Python/Python速成/14、Python强化练习","date":"2019-12-30T07:43:39.000Z","updated":"2020-09-11T08:14:26.808Z","comments":true,"path":"posts/47220.html","link":"","permalink":"http://www.a2data.cn/posts/47220.html","excerpt":"Python学习阶段钱","text":"Python学习阶段钱 Python强化练习1、给程序传参数import sys print(sys.argv) 2、列表推导式 所谓的列表推导式，就是指的轻量级循环创建列表 2.1、基本的方式 请忽略手残的错误。。。 2.2、在循环的过程中使用if 2.3、2个for循环 2.4、3个for循环 2.5、练习 请写出一段 Python 代码实现分组一个 list 里面的元素,比如 [1,2,3,…100]变成 [[1,2,3],[4,5,6]….] 参考答案 3、set、list、tuple set是集合类型 set、list、tuple之间可以相互转换使用set，可以快速的完成对list中的元素去重复的功能","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python速成","slug":"Python/Python速成","permalink":"http://www.a2data.cn/categories/Python/Python%E9%80%9F%E6%88%90/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"从零搭建ubuntu","slug":"Tools/从零搭建ubuntu","date":"2019-12-30T02:09:23.000Z","updated":"2020-09-11T09:28:58.982Z","comments":true,"path":"posts/48061.html","link":"","permalink":"http://www.a2data.cn/posts/48061.html","excerpt":"安装ubuntu、sublime骚操作","text":"安装ubuntu、sublime骚操作 Ubuntu系统1、虚拟机操作系统VMware Virtualbox 1、https://www.vmware.com/cn.html 2、https://www.virtualbox.org/ 2、小编哪个都玩得很溜此处采用 Virtualbox 原因是不用破解。 支持一下官方。 3、 下载ubuntu镜像 这里说明一下，官方下载贼慢。 https://ubuntu.com/download/desktop # 所以小编收集了一个镜像网站 比官网快NNN倍不止 http://mirrors.aliyun.com/ubuntu-releases/ #以及上传到自己的微云网盘，供大家使用。如有需要，请加小编微信。 4、万事具备开始安装 每一步都是截图，这样更加直观明了。 走你！！！ 5、ubuntu安装5.1、启动 5.2、选择语言 5.3、根据自己需求安装 5.4、选择地区 5.5、创建用户信息 6、安装完成重启 7、安装扩展组件 支持全屏，自定义大小。 双向拖动等。 Vmware 中安装的是 Tools 需要sudo ./ 执行解压的文件即可 Vbox 直接根据菜单操作安装即可。 8、Python 安装pip 9、安装sublime 对于Ubuntu 18.04及更高版本，只需打开Ubuntu软件搜索并安装sublime-text即可 对于Ubuntu 16.04，打开终端（Ctrl + Alt + T）并运行snap命令来安装： sudo apt install snapd &amp;&amp; sudo snap install sublime-text 1.通过Ctrl + Alt + T键盘快捷键或从应用程序启动器打开终端。 打开时，运行命令添加密钥环： wget -qO - https://download.sublimetext.com/sublimehq-pub.gpg | sudo apt-key add - 在提示时键入用户密码（无星号反馈），然后按Enter键。 2.然后运行命令添加apt存储库： echo “deb https://download.sublimetext.com/ apt/stable/“ | sudo tee /etc/apt/sources.list.d/sublime-text.list 3.最后通过Synaptic包管理器或运行命令安装sublime-text包： sudo apt update &amp;&amp; sudo apt install sublime-text 卸载：要删除编辑器，请运行命令：sudo apt remove –autoremove sublime-text要删除apt存储库，请转到“软件和更新” - &gt;“其他软件”。 10、玩转sublime 选择类Ctrl+D 选中光标所占的文本，继续操作则会选中下一个相同的文本。 此功能很好。当你想同时修改多个相同代码的时候，比如，将echo 统一改成print，可以双击选中echo，然后Ctrl+D，会向下连选echo，重复，直到你满意的位置，然后就可以统一编辑了。 有人说了，这不就是查找替换呀，是的，查找替换是可以实现，但这种方式更直观一些，而且不易出错。 Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。举个例子：快速选中并更改所有相同的变量名、函数名等。Ctrl+L 选中整行，继续操作则继续选择下一行，效果和 Shift+↓ 效果一样。Ctrl+Shift+L 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。Ctrl+Shift+M 选择括号内的内容（继续选择父括号）。举个栗子：快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容。Ctrl+M 光标移动至括号内结束或开始的位置。Ctrl+Enter 在下一行插入新行。举个栗子：即使光标不在行尾，也能快速向下插入一行。Ctrl+Shift+Enter 在上一行插入新行。举个栗子：即使光标不在行首，也能快速向上插入一行。Ctrl+Shift+[ 选中代码，按下快捷键，折叠代码。Ctrl+Shift+] 选中代码，按下快捷键，展开代码。Ctrl+K+0 展开所有折叠代码。Ctrl+← 向左单位性地移动光标，快速移动光标。Ctrl+→ 向右单位性地移动光标，快速移动光标。shift+↑ 向上选中多行。shift+↓ 向下选中多行。Shift+← 向左选中文本。Shift+→ 向右选中文本。Ctrl+Shift+← 向左单位性地选中文本。Ctrl+Shift+→ 向右单位性地选中文本。Ctrl+Shift+↑ 将光标所在行和上一行代码互换（将光标所在行插入到上一行之前）。Ctrl+Shift+↓ 将光标所在行和下一行代码互换（将光标所在行插入到下一行之后）。Ctrl+Alt+↑ 向上添加多行光标，可同时编辑多行。Ctrl+Alt+↓ 向下添加多行光标，可同时编辑多行。 编辑类Ctrl+J 合并选中的多行代码为一行。举个栗子：将多行格式的CSS属性合并为一行。Ctrl+Shift+D 复制光标所在整行，插入到下一行。Tab 向右缩进。Shift+Tab 向左缩进。Ctrl+K+K 从光标处开始删除代码至行尾。Ctrl+Shift+K 删除整行。Ctrl+/ 注释单行。Ctrl+Shift+/ 注释多行。Ctrl+K+U 转换大写。Ctrl+K+L 转换小写。Ctrl+Z 撤销。Ctrl+Y 恢复撤销。Ctrl+U 软撤销，感觉和 Gtrl+Z 一样。Ctrl+F2 设置书签Ctrl+T 左右字母互换。F6 单词检测拼写 搜索类Ctrl+F 打开底部搜索框，查找关键字。Ctrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找，略高端，未研究。Ctrl+P 打开搜索框。举个栗子：1、输入当前项目中的文件名，快速搜索文件，2、输入@和关键字，查找文件中函数名，3、输入：和数字，跳转到文件中该行代码，4、输入#和关键字，查找变量名。Ctrl+G 打开搜索框，自动带：，输入数字跳转到该行代码。举个栗子：在页面代码比较长的文件中快速定位。Ctrl+R 打开搜索框，自动带@，输入关键字，查找文件中的函数名。举个栗子：在函数较多的页面快速查找某个函数。Ctrl+： 打开搜索框，自动带#，输入关键字，查找文件中的变量名、属性名等。Ctrl+Shift+P 打开命令框。场景栗子：打开命名框，输入关键字，调用sublime text或插件的功能，例如使用package安装插件。 Esc 退出光标多行选择，退出搜索框，命令框等。 显示类Ctrl+Tab 按文件浏览过的顺序，切换当前窗口的标签页。Ctrl+PageDown 向左切换当前窗口的标签页。Ctrl+PageUp 向右切换当前窗口的标签页。Alt+Shift+1 窗口分屏，恢复默认1屏（非小键盘的数字）Alt+Shift+2 左右分屏-2列Alt+Shift+3 左右分屏-3列Alt+Shift+4 左右分屏-4列Alt+Shift+5 等分4屏Alt+Shift+8 垂直分屏-2屏Alt+Shift+9 垂直分屏-3屏Ctrl+K+B 开启/关闭侧边栏。 F11 全屏模式Shift+F11 免打扰模式","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://www.a2data.cn/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"}]},{"title":"MapReduce深入解析","slug":"Hadoop/MapReduce深入解析","date":"2019-12-27T03:04:21.000Z","updated":"2025-05-05T06:07:54.175Z","comments":true,"path":"posts/39508.html","link":"","permalink":"http://www.a2data.cn/posts/39508.html","excerpt":"MapReduce必备原理解析","text":"MapReduce必备原理解析 分布式计算框架MapReduce 1、概念 MapReduce是一个基于集群的计算平台，是一个简化分布式编程的计算框架，是一个将分布式计算抽象为Map和Reduce两个阶段的编程模型。（这句话记住了是可以用来装逼的） 2、执行流程 MapReduce程序执行图。 1. JobClient：运行于client node，负责将MapReduce程序打成Jar包存储到HDFS，并把Jar包的路径提交到Jobtracker，由Jobtracker进行任务的分配和监控。 2. JobTracker：运行于name node，负责接收JobClient提交的Job，调度Job的每一个子task运行于TaskTracker上，并监控它们，如果发现有失败的task就重新运行它。 3. TaskTracker：运行于data node，负责主动与JobTracker通信，接收作业，并直接执行每一个任务。 4. HDFS：用来与其它实体间共享作业文件。 MapReduce作业流程 1、JobClient通过RPC协议向JobTracker请求一个新应用的ID，用于MapReduce作业的ID 2、JobTracker检查作业的输出说明。例如，如果没有指定输出目录或目录已存在，作业就不提交，错误抛回给JobClient，否则，返回新的作业ID给JobClient 3、JobClient将作业所需的资源（包括作业JAR文件、配置文件和计算所得得输入分片）复制到以作业ID命名的HDFS文件夹中 4、JobClient通过submitApplication()提交作业 5、JobTracker收到调用它的submitApplication()消息后，进行任务初始化 6、JobTracker读取HDFS上的要处理的文件，开始计算输入分片，每一个分片对应一个TaskTracker 7、TaskTracker通过心跳机制领取任务（任务的描述信息） 8、TaskTracker读取HDFS上的作业资源（JAR包、配置文件等） 9、TaskTracker启动一个java child子进程，用来执行具体的任务（MapperTask或ReducerTask） 10、TaskTracker将Reduce结果写入到HDFS当中 3、工作原理 4、Map任务处理 1、读取HDFS中的文件。每一行解析成一个&lt;k,v&gt;。每一个键值对调用一次map函数 2、重写map()，对第一步产生的&lt;k,v&gt;进行处理，转换为新的&lt;k,v&gt;输出 3、对输出的key、value进行分区 4、对不同分区的数据，按照key进行排序、分组。相同key的value放到一个集合中 5、(可选) 对分组后的数据进行归约 5、Reduce任务处理 1、多个map任务的输出，按照不同的分区，通过网络复制到不同的reduce节点上 2、对多个map的输出进行合并、排序。 3、重写reduce函数实现自己的逻辑，对输入的key、value处理，转换成新的key、value输出 4、把reduce的输出保存到文件中","categories":[],"tags":[{"name":"MapReduce","slug":"MapReduce","permalink":"http://www.a2data.cn/tags/MapReduce/"}],"author":"JackFeng"},{"title":"13.Python面向对象(4)","slug":"Python/Python速成/13、Python面向对象-4","date":"2019-12-25T15:22:13.000Z","updated":"2020-09-11T08:14:26.856Z","comments":true,"path":"posts/55248.html","link":"","permalink":"http://www.a2data.cn/posts/55248.html","excerpt":"Python面向对象异常、模块","text":"Python面向对象异常、模块 Python面向对象(4)1、异常的传递1.1、try嵌套 首先从 test.txt 文件中读取到信息 ^c 关闭文件 没有这个文件 最后的finally 1.2、函数嵌套调用中 如果try嵌套，那么如果里面的try没有捕获到这个异常，那么外面的try会接收到这个异常，然后进行处理，如果外边的try依然没有捕获到，那么再进行传递。。。 如果一个异常是在一个函数中产生的，例如函数A—-&gt;函数B—-&gt;函数C,而异常是在函数C中产生的，那么如果函数C中没有对这个异常进行处理，那么这个异常会传递到函数B中，如果函数B有异常处理那么就会按照函数B的处理方式进行执行；如果函数B也没有异常处理，那么这个异常会继续传递，以此类推。。。如果所有的函数都没有处理，那么此时就会进行异常的默认处理，即通常见到的那样 注意观察上图中，当调用test3函数时，在test1函数内部产生了异常，此异常被传递到test3函数中完成了异常处理，而当异常处理完后，并没有返回到函数test1中进行执行，而是在函数test3中继续执行 2、抛出自定义的异常 可以用``raise`语句来引发一个异常。异常/错误对象必须有一个名字，且它们应是Error或Exception类的子类 以上程序中，关于代码#super().__init__()的说明 这一行代码，可以调用也可以不调用，建议调用，因为__init__方法往往是用来对创建完的对象进行初始化工作，如果在子类中重写了父类的__init__方法，即意味着父类中的很多初始化工作没有做，这样就不保证程序的稳定了，所以在以后的开发中，如果重写了父类的__init__方法，最好是先调用父类的这个方法，然后再添加自己的功能 3、异常处理中抛出异常 4、模块介绍4.1、模块 说的通俗点：模块就好比是工具包，要想使用这个工具包中的工具(就好比函数)，就需要导入这个模块 4.2、import 在python中主要是 用关键字，import 来引入某个模块， 在调用math模块中的函数时，必须这样引用： 模块名.函数名 import math #这样会报错 print sqrt(2) #这样才能正确输出结果 print math.sqrt(2) 4.3、from…import Python的from语句让你从模块中导入一个指定的部分到当前命名空间中 语法如下： from modname import name1[, name2[, ... nameN]] 例如，要导入模块fib的fibonacci函数，使用如下语句： from fib import fibonacci 注意 不会把整个fib模块导入到当前的命名空间中，它只会将fib里的fibonacci单个引入 4.4、from … import * 把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明： from modname import * 注意 这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。 4.5、 as 4.6、定位模块 当你导入一个模块，Python解析器对模块位置的搜索顺序是： 当前目录 如果不在当前目录，Python则搜索在shell变量PYTHONPATH下的每个目录。 如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/ 模块搜索路径存储在system模块的sys.path变量中。变量里包含当前目录，PYTHONPATH和由安装过程决定的默认目录。 5、模块制作5.1、定义自己的模块 在Python中，每个Python文件都可以作为一个模块，模块的名字就是文件的名字。比如有这样一个文件test.py，在test.py中定义了函数add #test.py def add(a,b): return a+b 5.2、调用自己定义的模块 那么在其他文件中就可以先import test，然后通过test.add(a,b)来调用了，当然也可以通过from test import add来引入 #test1.py import test result = test.add(66,22) print(result) 5.3、测试模块 在实际开中，当一个开发人员编写完一个模块后，为了让模块能够在项目中达到想要的效果，这个开发人员会自行在py文件中添加一些测试信息，例如： #test.py def add(a,b): return a+b # 用来进行测试 ret = add(123,543) print(&#39;int test.py file,,,,123+543=%d&#39;%ret) 如果此时，在其他py文件中引入了此文件的话，想想看，测试的那段代码是否也会执行呢！ #test1.py import test result = test.add(66,22) print(result) 6、模块中的_all_6.1、没有 6.2、有 7、使用Pip安装模块 pip 是 python 自带的一个软件，相当于手机里的应用市场，可以用来安装、卸载、搜索 python 的常见模块。 直接输入 pip 后回车，可以查看 pip 命令的所有可用参数。 7.1、安装模块在命令行执行 pip install 模块名 7.2、卸载模块在命令行执行 pip uninstall 模块名 7.3、搜索模块在命令行执行 pip search 模块名","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python速成","slug":"Python/Python速成","permalink":"http://www.a2data.cn/categories/Python/Python%E9%80%9F%E6%88%90/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"12.Python面向对象(3)","slug":"Python/Python速成/12、Python面向对象-3","date":"2019-12-25T13:08:42.000Z","updated":"2020-09-11T08:14:26.803Z","comments":true,"path":"posts/59346.html","link":"","permalink":"http://www.a2data.cn/posts/59346.html","excerpt":"Python面向对象单例模式","text":"Python面向对象单例模式 Python面向对象(3)1、_new_方法 __new__和__init__的作用 __new__至少要有一个参数cls，代表要实例化的类，此参数在实例化时由Python解释器自动提供 __new__必须要有返回值，返回实例化出来的实例，这点在自己实现__new__时要特别注意，可以return父类__new__出来的实例，或者直接是object的__new__出来的实例 __init__有一个参数self，就是这个__new__返回的实例，__init__在__new__的基础上可以完成一些其它初始化的动作，__init__不需要返回值 我们可以将类比作制造商，__new__方法就是前期的原材料购买环节，__init__方法就是在有原材料的基础上，加工，初始化商品环节 注意点 2、单例模式 单例模式： ​ 确保某一个类，只有一个实例，并且自行实例化向整个系统提供这个实例，这个类称为 单例类，单例模式 是一种对象创建型模式。 创建单例，保证只有1个对象 创建单例模式，只执行1次__init__方法 3、异常介绍异常简介 如下 说明: 打开一个不存在的文件123.txt，当找不到123.txt 文件时，就会抛出给我们一个IOError类型的错误，No such file or directory：123.txt （没有123.txt这样的文件或目录） 异常: 当Python检测到一个错误时，解释器就无法继续执行了，反而出现了一些错误的提示，这就是所谓的”异常” 4、捕获异常4.1、捕获异常(try..except…) 把可能出现问题的代码，放在try中 把处理异常的代码，放在except中 说明: 此程序看不到任何错误，因为用except 捕获到了IOError异常，并添加了处理的方法 pass 表示实现了相应的实现，但什么也不做；如果把pass改为print语句，那么就会输出其他信息 4.2、except捕获多个异常 想一想: 上例程序，已经使用except来捕获异常了，为什么还会看到错误的信息提示？ 答: except捕获的错误类型是IOError，而此时程序产生的异常为 NameError ，所以except没有生效 4.3、获取异常的信息描述 4.5、else 咱们应该对else并不陌生，在if中，它的作用是当条件不满足时执行的实行；同样在try…except…中也是如此，即如果没有捕获到异常，那么就执行else中的事情 4.6、try…finally… try…finally…语句用来表达这样的情况： 在程序中，如果一个段代码必须要执行，即无论异常是否产生都要执行，那么此时就需要使用finally。 比如文件关闭，释放锁，把数据库连接返还给连接池等 test.txt文件中每一行数据打印，但是我有意在每打印一行之前用time.sleep方法暂停2秒钟。这样做的原因是让程序运行得慢一些。在程序运行的时候，按Ctrl+c中断（取消）程序。 我们可以观察到KeyboardInterrupt异常被触发，程序退出。但是在程序退出之前，finally从句仍然被执行，把文件关闭。","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python速成","slug":"Python/Python速成","permalink":"http://www.a2data.cn/categories/Python/Python%E9%80%9F%E6%88%90/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"11.Python面向对象(2)","slug":"Python/Python速成/11、Python面向对象-2","date":"2019-12-23T14:59:23.000Z","updated":"2020-09-11T08:14:26.846Z","comments":true,"path":"posts/30675.html","link":"","permalink":"http://www.a2data.cn/posts/30675.html","excerpt":"Python面向对象介绍中篇","text":"Python面向对象介绍中篇 Python面向对象(2)1、保护对象的属性 如果有一个对象，当需要对其进行修改属性时，有两种方法 对象名.属性名 = 数据 —-&gt;直接修改 对象名.方法名() —-&gt;间接修改 为了更好的保存属性安全，即不能随意修改，一般的处理方式为 将属性定义为私有属性 添加一个可以调用的方法，供调用 私有共有属性区分 它是以属性命名方式来区分，如果在属性名前面加了2个下划线’__’，则表明该属性是私有属性，否则为公有属性（方法也是一样，方法名前面加了2个下划线的话表示该方法是私有的，否则为公有的）。 2、_del_()方法 当有1个变量保存了对象的引用时，此对象的引用计数就会加1 当使用del删除变量指向的对象时，如果对象的引用计数不会1，比如3，那么此时只会让这个引用计数减1，即变为2，当再次调用del时，变为1，如果再调用1次del，此时会真的把对象进行删除 3、单继承3.1、继承的概念 在程序中，继承描述的是事物之间的所属关系，例如猫和狗都属于动物，程序中便可以描述为猫和狗继承自动物；同理，波斯猫和巴厘猫都继承自猫，而沙皮狗和斑点狗都继承自狗，如下如所示： 3.2、继承示例 说明： 虽然子类没有定义__init__方法，但是父类有，所以在子类继承父类的时候这个方法就被继承了，所以只要创建Bosi的对象，就默认执行了那个继承过来的__init__方法 总结 子类在继承的时候，在定义类时，小括号()中为父类的名字 父类的属性、方法，会被继承给子类 3.3、注意点 私有的属性，不能通过对象直接访问，但是可以通过方法访问 私有的方法，不能通过对象直接访问 私有的属性、方法，不会被子类继承，也不能被访问 一般情况下，私有的属性、方法都是不对外公布的，往往用来做内部的事情，起到安全的作用 4、多继承 所谓多继承，即子类有多个父类，并且具有他们的特征 注意点 想一想: 如果在上面的多继承例子中，如果父类A和父类B中，有一个同名的方法，那么通过子类去调用的时候，调用哪个？ 5、重写与调用父类方法5.1、重写父类方法 所谓重写，就是子类中，有一个和父类相同名字的方法，在子类中的方法会覆盖掉父类中同名的方法 5.2、调用父类方法 6、多态 其实多态的概念，一般应用于Java这类强类型语言中， 而Python崇尚“鸭子类型” 所谓多态：定义时的类型和运行时的类型不一样，此时就成为多态 Python伪代码实现Java或C#的多态 鸭子类型 7、类、实例 | 属性7.1、类属性class People(object): name = &#39;A2Data&#39; #公有的类属性 __age = 22 #私有的类属性 p = People() print(p.name) #正确 print(People.name) #正确 print(p.__age) #错误，不能在类外通过实例对象访问私有的类属性 print(People.__age) #错误，不能在类外通过类对象访问私有的类属性 7.2、实例属性(对象属性)class People(object): address = &#39;北京&#39; #类属性 def __init__(self): self.name = &#39;A2Data&#39; #实例属性 self.age = 22 #实例属性 p = People() p.age =18 #实例属性 print(p.address) #正确 print(p.name) #正确 print(p.age) #正确 print(People.address) #正确 print(People.name) #错误 print(People.age) #错误 通过实例(对象)去修改类属性 class People(object): country = &#39;china&#39; #类属性 print(People.country) p = People() print(p.country) p.country = &#39;japan&#39; print(p.country) #实例属性会屏蔽掉同名的类属性 print(People.country) del p.country #删除实例属性 print(p.country) 归纳 如果需要在类外修改类属性，必须通过类对象去引用然后进行修改。如果通过实例对象去引用，会产生一个同名的实例属性，这种方式修改的是实例属性，不会影响到类属性，并且之后如果通过实例对象去引用该名称的属性，实例属性会强制屏蔽掉类属性，即引用的是实例属性，除非删除了该实例属性。 8、静态和类 | 方法8.1、类方法 类对象所拥有的方法，需要用修饰器@classmethod来标识其为类方法，对于类方法，第一个参数必须是类对象，一般以cls作为第一个参数（当然可以用其他名称的变量作为其第一个参数，但是大部分人都习惯以’cls’作为第一个参数的名字，就最好用’cls’了），能够通过实例对象和类对象去访问。 用类方法对类属性修改之后，通过类对象和实例对象访问都发生了改变 8.2、静态方法 需要通过修饰器@staticmethod来进行修饰，静态方法不需要多定义参数","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python速成","slug":"Python/Python速成","permalink":"http://www.a2data.cn/categories/Python/Python%E9%80%9F%E6%88%90/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"Python烤地瓜案例","slug":"Python/Python速成/Python烤地瓜案例","date":"2019-12-23T04:26:20.000Z","updated":"2020-09-11T07:51:20.131Z","comments":true,"path":"posts/16550.html","link":"","permalink":"http://www.a2data.cn/posts/16550.html","excerpt":"Python烤地瓜实例解析","text":"Python烤地瓜实例解析 Python烤地瓜实例建议跟着操作，所以小编多数以截图的方式 为了更好的理解面向对象编程，下面以“烤地瓜”为案例，进行分析 定义地瓜类，存储烤熟的程度和添加的佐料，同时要提供烤地瓜和添加佐料的功能 1、分析属性事例方法 cook() : 把地瓜烤一段时间 addCondiments() : 给地瓜添加配料 __init__() : 设置默认的属性 __str__() : 让print的结果看起来更好一些 2、定义类并且测试 3、测试cook方法 4、自定义方法 5、完整代码 6、测试输出效果","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python速成","slug":"Python/Python速成","permalink":"http://www.a2data.cn/categories/Python/Python%E9%80%9F%E6%88%90/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"10.Python面向对象(1)","slug":"Python/Python速成/10、Python面向对象-1","date":"2019-12-23T02:31:34.000Z","updated":"2020-09-11T08:14:26.843Z","comments":true,"path":"posts/34771.html","link":"","permalink":"http://www.a2data.cn/posts/34771.html","excerpt":"Python面向对象介绍上篇","text":"Python面向对象介绍上篇 Python面向对象1、面向对象介绍 思考 例如：你有一个想法，你要做一个项目。然后呢，你聚集了n个人，说明你要做啥，然后大家开始干。 根据小编的经验，这个项目肯定是失败的。 因为每个人做的事情很多，分工不明确，有些肯定到最后都是没人做的，所以问题来了，必须要进行分工， 哪些人搭架子，做什么。哪些负责哪一块。 例如：数一下如下字符串有多少个字符 a2datahelloworldwwwa2datacn a2data,helloworld,www,a2data,cn 显然，被分组后的字符更容易计数 总结： 大型的项目，必须要进行分工，将函数分为几个不同的类型，每个人负责一个或多个类型，比如一个人负责网站首页，一个人负责订单界面，一个人负责用户设置页面。 面向对象与面向过程 面向过程：根据业务逻辑从上到下写代码 面向对象：将数据与函数绑定到一起，分类进行封装，每个程序员只要负责分配给自己的分类，这样能够更快速的开发程序，减少了重复代码 对于小编而已，跟大家一样，刚开始都喜欢面向过程开发。其往往用一长段代码来实现指定功能，开发过程的思路是将数据与函数按照执行的逻辑顺序组织在一起，数据与函数分开考虑。 面向对象编程（Object Oriented Programming，OOP，面向对象程序设计） 解决吃啤酒鸭的问题 第一种方式（面向过程）: 1、养鸭子 2、鸭子长成 3、杀 4、作料 5、烹饪 6、吃 7、卒 第二种方式（面向对象）: 1、找个卖啤酒鸭的人 2、给钱 交易 3、吃 需要了解的定义性文字: 面向对象(object-oriented ;简称: OO) 至今还没有统一的概念 我这里把它定义为: 按人们 认识客观世界的系统思维方式,采用基于对象(实体)的概念建立模型,模拟客观世界分析、设 计、实现软件的办法。 面向对象编程(Object Oriented Programming-OOP) 是一种解决软件复用的设计和编程方法。 这种方法把软件系统中相近相似的操作逻辑和操作 应用数据、状态,以类的型式描述出来,以对象实例的形式在软件系统中复用,以达到提高软件开发效率的作用。 2、类和对象2.1、类 人以类聚 物以群分 具有相似内部状态和运动规律的实体的集合（抽象） 具有相同属性和行为事物的统称 类是抽象的，使用的时候，通常一个类可以找到多个对象。 例如：轮胎，汽车，飞机，推车..等等 2.2、对象 某一个具体事物的存在，现实中就是看得见摸得着的。 code: 可以直接使用的 2.3、类与对象的关系 类就是创建对象的模板 2.4、类的构成 类(Class) 由3个部分构成 类的名称:类名 类的属性:一组数据 类的方法:允许对进行操作的方法 (行为) 狗类的设计 类名:狗(Dog) 属性:品种 、毛色、性别、名字、 腿儿的数量 方法(行为/功能):叫 、跑、咬人、吃、摇尾巴 2.5、类的抽象 拥有相同(或者类似)属性和行为的对象都可以抽像出一个类 方法:一般名词都是类(名词提炼法) 3、定义类 定义一个类，格式如下： class 类名: 方法列表 说明： 定义类时有2种：新式类和经典类，如下的Car为经典类，如果是Car(object)则为新式类 类名 的命名规则按照”大驼峰” 4、创建对象python中，可以根据已经定义的类去创建出一个个对象 创建对象的格式为: 对象名 = 类名() 创建对象demo: # 定义类 class Car: # 移动 def move(self): print(&#39;车在奔跑...&#39;) # 鸣笛 def toot(self): print(&quot;车在鸣笛.....&quot;) # 创建一个对象，并用变量BMW来保存它的引用 BM = Car() BM.color = &#39;黑色&#39; BM.wheelNum = 4 #轮子数量 BM.move() BM.toot() print(BM.color) print(BM.wheelNum) 5、Self理解Self 所谓的self，可以理解为自己 某个对象调用其方法时，python解释器会把这个对象作为第一个参数传递给self，所以开发者只需要传递后面的参数即可 6、init6.1、使用方式def 类名: #初始化函数，用来完成一些默认的设定 def __init__(): pass 6.2、init()方法调用# 定义汽车类 class Car: def __init__(self): self.wheelNum = 4 self.color = &#39;蓝色&#39; def move(self): print(&#39;车在跑，目标:北京&#39;) # 创建对象 BM = Car() print(&#39;车的颜色为:%s&#39;%BM.color) print(&#39;车轮胎数量为:%d&#39;%BM.wheelNum) __init__()方法，在创建一个对象时默认被调用，不需要手动调用 __init__(self)中，默认有1个参数名字为self，如果在创建对象时传递了2个实参，那么__init__(self)中出了self作为第一个形参外还需要2个形参，例如__init__(self,x,y) __init__(self)中的self参数，不需要开发者传递，python解释器会自动把当前的对象引用传递进去 7、“魔法”方法 定义 __str__() 方法 在python中方法名如果是__xxxx__()的，那么就有特殊的功能，因此叫做“魔法”方法 当使用print输出对象的时候，只要自己定义了__str__(self)方法，那么就会打印从在这个方法中return的数据","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python速成","slug":"Python/Python速成","permalink":"http://www.a2data.cn/categories/Python/Python%E9%80%9F%E6%88%90/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"面试拆招详解","slug":"Tools/面试拆招详解","date":"2019-12-22T01:43:28.000Z","updated":"2020-09-11T09:28:58.972Z","comments":true,"path":"posts/9812.html","link":"","permalink":"http://www.a2data.cn/posts/9812.html","excerpt":"面试精选！！！","text":"面试精选！！！ 面试拆招1、请你自我介绍一下自己好吗? 回答提示:一般人回答这个问题过于平常,只说姓名、年龄、爰好、工作经验,这些在简历上都有。其实,企业最希望知道的是求职者能否胜任工作,包括:*最强的技能、最深研究的知识领域、个性中最积极的部分、做过的最成功的事、可以和学习无关,也可以和学习有关,但要突出积极的个性和做事的能力,说得合情合理企业才会相信。企业很重视一个人的礼貌,求职者要尊重考官,在回答每个问题之后都说一句“谢谢”,企业喜欢有礼貌的求职者。 2、你觉得你个性上最大的优点是什么? 回答提示: 沉着冷静、条理清楚、立场坚定、顽强向上、乐于助人和关心他人、适应能力和幽默感、乐观和友爱。我在xxxx经过一到两年的培训及项目实战,加上实习工作，使我适合这份工作。(此处根据自己情况而改) 3、说说你最大的缺点? 回答提示: 这个问题企业问的概率很大,通常不希望听到直回答的缺点是什么等,如果求职者说自己小心眼、爱忌妒非常懒、脾气大、工作效率低,企业肯定不会录用你绝对不要自作聪明地回答“我最大的缺点是过于追求完美”,有的人以为这样回答会显得自己比较出色,但事实上,他已经岌岌可危了。企业喜欢求职者从自己的优点说起,中间加一些小缺点,最后再把问题转回到优点上,突出优点的部分,企业喜欢聪明的求职者。 4、你对薪资的要求? 回答提示: 如果你对薪酬的要求太低,那显然贬低自己的能力;如果你对薪酣的要求太高,那又会显得你分量过重,公司受用不起。一些雇主通常都事先对求聘的职位定下开支预算,因而他们第一次提出的价钱往往是他们所能给予的最高价钱,他们问你只不过想证实一下这笔钱是否足以引起你对该工作的兴趣。 回答样本一: 我对工资没有硬性要求,我相信贵公司在处理我的问题上会友善合理。我注重的是找对工作机会,所以只要条件公平,我则不会计较太多 回答祥本二: 我受过系统的软件编程的训练,不需要进行大量的培训,而且我本人也对编程特别感兴趣。因此,我希望公司能根据我的情况和市场标准的水平,给我合理的薪水 回答样本三: 如果你必须自己说出具体数目,请不要说一个宽泛的范围,那样你将只能得到最低限庋的数字。最好给出一个具体的数字,这样表明你已经对当今的人才市场作了调查,知道像自己这样学历的雇员有什么样的价值 5、你对加班的看法? 回答提示: 实际上好多公司问这个问题,并不证明一定要加班,只是想测试你是否愿意为公司奉献。 回答样本: 如果工作需要我会义不容辞加班,我现在单身没有任何家庭负担,可以全身心的投入工作。但同时我也会提高工作效率,减少不必要的加班。 6、如果通过这次面试我们录用了你,但工作一段时间却发现你根本不适合这个职位,你怎么办? 回答提示: 一段时间发现工作不适合我,有两种情况: ①如果你确实热爱这个职业,那你就要不断学习,虚心向领导和同事学习业务知识和处事经验,了解这个职业的精神内涵和职业要求,力争减少差距; ②你觉得这个职业可有可无,那还是趁早换个职业,去发现适合你的,你热爱的职业,那样你的发展前途也会大点,对单位和个人都有好处。 7、谈谈你对跳槽的看法? 回答提示: ①正常的“跳槽”能促进人才合理流动,应该支持。 ②频繁的跳槽对单位和个人双方都不利,应该反对。 8、工作中难以和同事、上司相处,你该怎么办? 回答提示: ①我会服从领导的指挥,配合同事的工作。 ②我会从自身找原因,仔鈿分析是不是自己工作做得不好让领导不满意,同事看不惯。还要看看是不是为人处世方面做得不好,如果是这样的话我会努力改正。 ③如果我找不到原因,我会找机会跟他们沟通,请他们指出我的不足,有问题就及时改正。 ④作为优秀的员工,应该时刻以大局为重,即使在段时间内,领导和同事对我不理解,我也会做好本职工作,虚心向他们学习,我相信,他们会看见我在努力,总有天会对我微笑的。 9、你对于我们公司了解多少? 回答提示: 在去公司面试前上网查一下该公司主营业务。如回答:贵公司有意改变策略,加强与国外大厂的QFM合作,自有品牌的部分则透过海外经销商. 10、最能慨括你自己的三个词是什么? 回答提示: 我经常用的三个词是:适应能力强,有责任心和做事有始终,结合具体例子向主考官解释。 11、你的业余爱好是什么? 回答提示: 找一些富于团体合作精神的,这里有一个真实的故事:有人被否决掉,因为他的爰好是深海潜水。主考官说:因为这是一项单人活动,我不敢肯定他能否适应团体工作 12、作为被面试者给我打一下分? 回答提示: 试着列出四个优点和一个非常非常非常小的缺点可以抱怨一下设施,没有明确责任人的缺点是不会有人介意的) 13、你为什么要离开原来的公司? 回答提示: ①回答这个问题时一定要小心,就算在前一个工作受到再大的委屈,对公司有多少的怨言,都千万不要表现出来,尤其要避免对公司本身主管的批评,避免面试官的负面情绪及印象。 建议此时最好的回答方式是将问题归咎在自己身上,例如觉得工作没有学习发展的空间,自己想在面试工作的相关产业中多加学习,或是前一份工作与自己的生涯规划不合等等,回答的答案最好是积极正面的。 ②我希望能获得一份更好的工作,如果机会来临,我会抓住。我觉得目前的工作,已经达到顶峰,即沒有升迁机会。 14、你欣赏哪种性格的人? 回答提示: 诚实、不死板而且容易相处的人、有“实际行动”的人。 15、你通常如何对待别人的批评? 回答提示: ①沈默是金,不必说什么,否则情况更糟,不过我会接受建设性的批评。 ②我会等大家冷靜下来再讨论。 16、怎样对待自己的失败? 回答提示: 我们大家生来都不是十全十美的,我相信我有第二个机会改正我的错误。 17、你为什么原意到我们公司来工作? 回答提示: 对于这个问题,你要格外小心,如果你已经对该单位作了研究,你可以回答一些详细的原因,像“公司本身的高技术开发环境很吸引我”,“我同公司出生在同样的时代,我希望能够进入一家与我共同成长的公司。”、“你们公司一直都稳定发展,在近几年来在市场上很有竞争力。”、“我认为贵公司能够给我禔供一个与众不同的发展道路。”这都显示出你已经做了一些调查,也说明你对自己的未来有了较为具体的远景规划。 18、对这项工作,你有哪些可预见的困难? 回答提示: ①不宜直接说出具体的困难,否则可能令对方怀疑应聘者不行。 ②可以尝试迂回战术,说出应聘者对困难所持有的态度一一工作中出现一些困难是正常的,也是难免的,但是只要有坚忍不拔的毅力、良好的合作精神以及事前周密而充分的准备,任何困难都是可以克服。 19、如果录用了你,你将怎样开展工作? 回答提示: ①如果应聘者对于应聘的职位缺乏足够的了解,最好不要直接说出自己开展工作的具体办法。 ②可以尝试采迂回战术来回答,如“首先听取领导的指示和要求,然后就有关情况进行了解和熟悉,接下来制定一份近期的工作计划并报领导批准,最后根据计划开展工作。” 分析 这个问题的主要目的也是了解应聘者的工作能力和计划性、条理性,而且重点想要知道细节。如果向思路中所讲灼迂回战术,面试官会认为回避问题,如果引导了几次仍是回避的话,此人绝对不会录用了。 20、你希望与什么样的上级共事? 回答提示: ①通过应聘者对上级的“希望”可以判断出应聘者对自我要求的意识,这既是一个陷阱,又是一次机会。 ②最好回避对上级具体的希望,多谈对自己的要求。 ③如“做为刚步入社会的新人,我应该多要求自己尽快熟悉环境、适应环境,而不应该对环境提出什么要求,只要能发挥我的专长就可以了。 分析: 这个问题比较好的回答是,希望我的上级能够在工作中对我多指导,对我工作中的错误能够立即指出。总之，从上级指导这个方面谈,不会有大的纰漏 21、与上级意见不一时,你将怎么办? 回答提示: ①一般可以这样回答“我会给上级以必要的解释和提醒,在这种情况下,我会服从上级的意见。” ②如果面试你的是总经理,而你所应聘的职位另有一位经理,且这位理当时不在场,可以这样回答:“对于非原则性问题,我服从上级的意见,对于涉及公司利益的重大问题,我希望能向更高层领导反映” 分析: 这个问题的标准答案是思路①,如果用②的回答,必死无疑。你没有摸清楚改公司的内部情况,先想打小报告,这样的人没有人敢要。 22、为什么选择我们公司? 回答提示: 曾经在报章杂志看过关于贵公司的报道,与自己所追求的理念有志一同。而贵公司在业界的成绩也是有目共睹的,而且对员工的教育训练、升迁等世都很有制度。 分析: 去面试前先做功课,了解一下该公司的背景,让对方觉得你真的很有心想得到这份工作,而不只是探探路。 23、谈谈如何话应办公室工作的新环境? 回答提示: ①办公室里每个人有各自的岗位与职责,不得擅离岗位。 ②根据领导指示和工作安排,制定工作计划,提前预备,并按计划完成。 ③多请示并及时汇报,遇到不明白的要虚心请教。 ④抓间隙时间,多学习,努力提高自己的政治素质和业务水平 24、除了本公司外,还应聘了哪些公司 回答提示: 很奇怪,这是相当多公司会问的问题,其用意是要概略知道应徵者的求职志向,所以这并非绝对是负面答案,就算不便说出公司名称,也应回答“销售同种产品的公司”,如果应聘的其他公司是不同业界,容易让人产生无法信任的感觉。 25、你还有什么问题要问吗? 回答提示: 企业的这个问题看上去可有可无,其实很关键,企业不喜欢说“没问题”的人,因为其很注重员工的个性和创新能力。企业不喜欢求职者问个人福利之类的问题,如果有人这样问:贵公司对新入公司的员工有没有什么培训项目,我可以参加吗?或者说贵公司的晋升机制是什么样的?企业将很欢迎,因为体现出你对学习的热情和对公司的忠诚度以及你的上进心。 26、如果你被录用,何时可以到职? 回答提示: 大多数企业会关心就职时间,最好是回答“如果被录用的话,到职日可按公司规定上班”,但如果还未辞去上一个工作、上班时间又太近,似乎有些强人所难,因为交接至少要一个月的时间,应进一步说明原因,录取公司应该会通融的。","categories":[{"name":"职场","slug":"职场","permalink":"http://www.a2data.cn/categories/%E8%81%8C%E5%9C%BA/"}],"tags":[{"name":"面经","slug":"面经","permalink":"http://www.a2data.cn/tags/%E9%9D%A2%E7%BB%8F/"}]},{"title":"9.Python文件操作及应用","slug":"Python/Python速成/9、Python文件操作及应用","date":"2019-12-19T14:21:43.000Z","updated":"2020-09-11T08:14:26.854Z","comments":true,"path":"posts/8573.html","link":"","permalink":"http://www.a2data.cn/posts/8573.html","excerpt":"Python的基础语法","text":"Python的基础语法 Python文件操作、应用1、文件操作介绍 文件是什么呢？ 文件的作用呢？ 大家应该听说过一句话：“好记性不如烂笔头”。 不仅人的大脑会遗忘事情，计算机也会如此，比如一个程序在运行过程中用了九牛二虎之力终于计算出了结果，试想一下如果不把这些数据存放起来，相比重启电脑之后，“哭都没地方哭了” 相信很多做ps的朋友，深有体会 可见，在把数据存储起来有做么大的价值 使用文件的目的： 就是把一些存储存放起来，可以让程序下一次执行的时候直接使用，而不必重新制作一份，省时省力 2、文件的打开与关闭2.1、打开文件 在python，使用open函数，可以打开一个已经存在的文件，或者创建一个新文件 open(文件名，访问模式)示例如下： f = open(&#39;test.txt&#39;, &#39;w&#39;) 说明: 访问模式 说明 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 w 打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 w+ 打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 2.2、关闭文件 close( ) 示例如下： # 新建一个文件，文件名为:test.txt f = open(&#39;test.txt&#39;, &#39;w&#39;) # 关闭这个文件 f.close() 3、文件读写3.1、写文件(write) 注意： 如果文件不存在那么创建，如果存在那么就先清空，然后写入数据 3.2、读数据(read) 使用read(num)可以从文件中读取数据，num表示要从文件中读取的数据的长度（单位是字节），如果没有传入num，那么就表示读取文件中所有的数据 3.3、读数据(readlines) 3.4、读数据(readline) 注意： 如果open是打开一个文件，那么可以不用写打开的模式，即只写 open(&#39;text.txt&#39;) 如果使用读了多次，那么后面读取的数据是从上次读完后的位置开始的 3.5、文件定位读写3.5.1、获取当前读写的位置 在读写文件的过程中，如果想知道当前的位置，可以使用tell()来获取 # 打开一个已经存在的文件 f = open(&quot;test.txt&quot;, &quot;r&quot;) str = f.read(3) print &quot;读取的数据是 : &quot;, str # 查找当前位置 position = f.tell() print &quot;当前文件位置 : &quot;, position str = f.read(3) print &quot;读取的数据是 : &quot;, str # 查找当前位置 position = f.tell() print &quot;当前文件位置 : &quot;, position f.close() 3.5.2、定位到某个位置 如果在读写文件的过程中，需要从另外一个位置进行操作的话，可以使用seek() seek(offset, from)有2个参数 offset:偏移量 from:方向 0:表示文件开头 1:表示当前位置 2:表示文件末尾 demo:把位置设置为：从文件开头，偏移5个字节 # 打开一个已经存在的文件 f = open(&quot;test.txt&quot;, &quot;r&quot;) str = f.read(30) print &quot;读取的数据是 : &quot;, str # 查找当前位置 position = f.tell() print &quot;当前文件位置 : &quot;, position # 重新设置位置 f.seek(5,0) # 查找当前位置 position = f.tell() print &quot;当前文件位置 : &quot;, position f.close() demo:把位置设置为：离文件末尾，3字节处 # 打开一个已经存在的文件 f = open(&quot;test.txt&quot;, &quot;r&quot;) # 查找当前位置 position = f.tell() print &quot;当前文件位置 : &quot;, position # 重新设置位置 f.seek(-3,2) # 读取到的数据为：文件最后3个字节数据 str = f.read() print &quot;读取的数据是 : &quot;, str f.close() 4、制作文件备份 输入文件的名字，然后程序自动完成对文件的备份操作 5、文件、文件夹相关操作 有些时候，需要对文件进行重命名、删除等一些操作，python的os模块中都有这么功能 5.1、文件重命名 os模块中的rename()可以完成对文件的重命名操作 rename(需要修改的文件名, 新的文件名) import os os.rename(&quot;text.txt&quot;, &quot;test.txt&quot;) # 需要注意以下 5.2、删除文件 os模块中的remove()可以完成对文件的删除操作 remove(待删除的文件名) import os os.remove(&quot;text.txt&quot;) 5.3、创建文件夹import os os.mkdir(&quot;小风&quot;) 5.4、获取当前目录import os os.getcwd() 5.5、改变默认目录import os os.chdir(&quot;../&quot;) 5.6、获取目录列表import os os.listdir(&quot;./&quot;) 5.7、删除文件夹import os os.rmdir(&quot;小风&quot;) 6、批量修改文件名 例如，我们有很多文件，想批量修改，该怎么办呢？ # 批量在文件名前加前缀 import os funFlag = 1 # 1表示添加标志 2表示删除标志 folderName = &#39;./小风/&#39; # 获取指定路径的所有文件名字 dirList = os.listdir(folderName) # 遍历输出所有文件名字 for name in dirList: if funFlag == 1: newName = &#39;[A2Data出品-]&#39; + name elif funFlag == 2: num = len(&#39;[A2Data出品]-&#39;) newName = name[num:] print (newName) os.rename(folderName+name,folderName+newName)","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python速成","slug":"Python/Python速成","permalink":"http://www.a2data.cn/categories/Python/Python%E9%80%9F%E6%88%90/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"8.Python函数(下)","slug":"Python/Python速成/8、Python函数-下","date":"2019-12-19T00:29:40.000Z","updated":"2020-09-11T08:14:26.817Z","comments":true,"path":"posts/6275.html","link":"","permalink":"http://www.a2data.cn/posts/6275.html","excerpt":"Python函数介绍下篇","text":"Python函数介绍下篇 Python函数(下) 1、引用 在python中，值是靠引用来传递来的。 我们可以用id()来判断两个变量是否为同一个值的引用。 我们可以将id值理解为那块内存的地址标示。 &gt;&gt;&gt; a = 1 &gt;&gt;&gt; b = a &gt;&gt;&gt; id(a) 13033816 &gt;&gt;&gt; id(b) # 注意两个变量的id值相同 13033816 &gt;&gt;&gt; a = 2 &gt;&gt;&gt; id(a) # 注意a的id值已经变了 13033792 &gt;&gt;&gt; id(b) # b的id值依旧 13033816 &gt;&gt;&gt; a = [1, 2] &gt;&gt;&gt; b = a &gt;&gt;&gt; id(a) 139935018544808 &gt;&gt;&gt; id(b) 139935018544808 &gt;&gt;&gt; a.append(3) &gt;&gt;&gt; a [1, 2, 3] &gt;&gt;&gt; id(a) 139935018544808 &gt;&gt;&gt; id(b) # 注意a与b始终指向同一个地址 139935018544808 2、递归函数2.1、什么是递归函数 通过前面的学习知道一个函数可以调用其他函数。 如果一个函数在内部不调用其它的函数，而是自己本身的话，这个函数就是递归函数。 2.2、递归函数的作用 举个例子，我们来计算阶乘 n! = 1*2 * 3 * … * n 方案1： 阶乘的规律 1! = 1 2! = 2 × 1 = 2 × 1! 3! = 3 × 2 × 1 = 3 × 2! 4! = 4 × 3 × 2 × 1 = 4 × 3! ... n! = n × (n-1)! 方案2： 递归原理 3、匿名函数 用lambda关键词能创建小型匿名函数。这种函数得名于省略了用def声明函数的标准步骤。 lambda函数的语法只包含一个语句，如下： lambda [arg1 [,arg2,.....argn]]:expression 如下实例： sum = lambda arg1, arg2: arg1 + arg2 #调用sum函数 print &quot;Value of total : &quot;, sum( 10, 20 ) print &quot;Value of total : &quot;, sum( 20, 20 ) 以上实例输出结果： Value of total : 30 Value of total : 40 Lambda函数能接收任何数量的参数但只能返回一个表达式的值 匿名函数不能直接调用print，因为lambda需要一个表达式 应用场合 3.1函数作为参数传递 自己定义函数 &gt;&gt;&gt; def fun(a, b, opt): ... print &quot;a =&quot;, a ... print &quot;b =&quot;, b ... print &quot;result =&quot;, opt(a, b) ... &gt;&gt;&gt; fun(1, 2, lambda x,y:x+y) a = 1 b = 2 result = 3 作为内置函数的参数 3.2想一想，下面的数据如何指定按age或name排序？# A2Data制作 stus = [ &#123;&quot;name&quot;:&quot;zhangsan&quot;, &quot;age&quot;:18&#125;, &#123;&quot;name&quot;:&quot;lisi&quot;, &quot;age&quot;:19&#125;, &#123;&quot;name&quot;:&quot;wangwu&quot;, &quot;age&quot;:17&#125; ] 3.3 按name排序：&gt;&gt;&gt; stus.sort(key = lambda x:x[&#39;name&#39;]) &gt;&gt;&gt; stus [&#123;&#39;age&#39;: 19, &#39;name&#39;: &#39;lisi&#39;&#125;, &#123;&#39;age&#39;: 17, &#39;name&#39;: &#39;wangwu&#39;&#125;, &#123;&#39;age&#39;: 18, &#39;name&#39;: &#39;zhangsan&#39;&#125;] 3.4按age排序：&gt;&gt;&gt; stus.sort(key = lambda x:x[&#39;age&#39;]) &gt;&gt;&gt; stus [&#123;&#39;age&#39;: 17, &#39;name&#39;: &#39;wangwu&#39;&#125;, &#123;&#39;age&#39;: 18, &#39;name&#39;: &#39;zhangsan&#39;&#125;, &#123;&#39;age&#39;: 19, &#39;name&#39;: &#39;lisi&#39;&#125;] 4、函数使用注意事项4.1、自定义函数 1、无参数、无返回值 def 函数名(): 语句 2、无参数、有返回值 def 函数名(): 语句 return 需要返回的数值 注意: 一个函数到底有没有返回值，就看有没有return，因为只有return才可以返回数据 在开发中往往根据需求来设计函数需不需要返回值 函数中，可以有多个return语句，但是只要执行到一个return语句，那么就意味着这个函数的调用完成 3、有参数、无返回值 def 函数名(形参列表): 语句 注意： 在调用函数时，如果需要把一些数据一起传递过去，被调用函数就需要用参数来接收 参数列表中变量的个数根据实际传递的数据的多少来确定 4、有参数、有返回值 def 函数名(形参列表): 语句 return 需要返回的数值 5、函数名不能重复（如下所示） 4.2、调用函数 1、调用的方式为： 函数名([实参列表]) 2、调用时，到底写不写 实参 如果调用的函数 在定义时有形参，那么在调用的时候就应该传递参数 3、调用时，实参的个数和先后顺序应该和定义函数中要求的一致 4、如果调用的函数有返回值，那么就可以用一个变量来进行保存这个值 4.3、作用域 1、在一个函数中定义的变量，只能在本函数中用(局部变量) 2、在函数外定义的变量，可以在所有的函数中使用(全局变量)","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python速成","slug":"Python/Python速成","permalink":"http://www.a2data.cn/categories/Python/Python%E9%80%9F%E6%88%90/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"7.Python函数(中)","slug":"Python/Python速成/7、Python函数(中)","date":"2019-12-18T00:15:35.000Z","updated":"2020-09-11T08:14:26.812Z","comments":true,"path":"posts/30873.html","link":"","permalink":"http://www.a2data.cn/posts/30873.html","excerpt":"Python函数介绍中篇","text":"Python函数介绍中篇 Python函数(中)1、回顾函数应用 函数的嵌套应用 程序设计的思路，复杂问题分解为简单问题 Demo # 1.写一个函数打印一条直线 # 2.打印自定义行数的横线 # 打印一条 def printOneLine(): print(&quot;-&quot;*30) # 打印多条 def printNumLine(num): i = 0 # printOneLine 函数已经完成了打印横线的功能 # 只需要多次调用此函数即可 while i &lt; num: printOneLine() i+=1 # 调用 printNumLine(3) Demo1 1.写一个函数求三个数的和 2.写一个函数求三个数的平均值 # 求三个数的和 def sum3Number(a,b,c): return a+b+c #return的后面可以是数值，也可以是表达式 # 完成三个数的平均值 def average3Number(a,b,c): # 因为sum3Number函数已经完成3个数的求和 # 将接收到的3个数，当做实参传递即可 sumResult = sum3Number(a,b,c) aveResult = sumResult/3.0 return aveResult # 调用函数，完成对3个数求平均值 result = average3Number(11,2,55) print(&quot;average is %d&quot;%result) 2、局部变量 归纳分析 局部变量，就是在函数内部定义的变量 不同的函数，可以定义相同的名字的局部变量，但是各用个的不会产生影响 局部变量的作用，为了临时保存数据需要在函数中定义变量来进行存储，这就是它的作用 3、全局变量3.1、全局变量是什么？ 如果一个变量，既能在一个函数中使用，也能在其他的函数中使用，这样的变量就是全局变量 Demo # 定义全局变量 a = 100 def test1(): print(a) def test2(): print(a) # 调用函数 test1() test2() # 结果显而易见 100 100 3.2、全局和局部变量名一致的情况 3.3、修改全局变量 3.4、可变类型的全局变量&gt;&gt;&gt; a = 1 &gt;&gt;&gt; def f(): ... a += 1 ... print a ... &gt;&gt;&gt; f() Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;&lt;stdin&gt;&quot;, line 2, in f UnboundLocalError: local variable &#39;a&#39; referenced before assignment &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; li = [1,] &gt;&gt;&gt; def f2(): ... li.append(1) ... print li ... &gt;&gt;&gt; f2() [1, 1] &gt;&gt;&gt; li [1, 1] 3.5、 归纳总结 在函数外边定义的变量叫做全局变量 全局变量能够在所有的函数中进行访问 如果在函数中修改全局变量，那么就需要使用global进行声明，否则出错 如果全局变量的名字和局部变量的名字相同，那么使用的是局部变量的，小技巧强龙不压地头蛇 在函数中不使用global声明全局变量时不能修改全局变量的本质是不能修改全局变量的指向，即不能将全局变量指向新的数据。 对于不可变类型的全局变量来说，因其指向的数据不能修改，所以不使用global时无法修改全局变量。 对于可变类型的全局变量来说，因其指向的数据可以修改，所以不使用global时也可修改全局变量。 4、函数返回值 在python中我们可不可以返回多个值？ 本质是利用了元组 &gt;&gt;&gt; def divid(a, b): ... shang = a//b ... yushu = a%b ... return shang, yushu ... &gt;&gt;&gt; sh, yu = divid(5, 2) &gt;&gt;&gt; sh 5 &gt;&gt;&gt; yu 1 5、函数参数5.1、 缺省参数 调用函数时，缺省参数的值如果没有传入，则被认为是默认值。下例会打印默认的age，如果age没有被传入： def printinfo( name, age = 35 ): # 打印任何传入的字符串 print &quot;Name: &quot;, name print &quot;Age &quot;, age # 调用printinfo函数 printinfo(name=&quot;miki&quot; ) printinfo( age=9,name=&quot;miki&quot; ) 以上实例输出结果： Name: miki Age 35 Name: miki Age 9 注意：带有默认值的参数一定要位于参数列表的最后面。&gt;&gt;&gt; def printinfo(name, age=35, sex): ... print name ... File &quot;&lt;stdin&gt;&quot;, line 1 SyntaxError: non-default argument follows default argument 5.2、不定长参数 有时可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，声明时不会命名。 基本语法如下： def functionname([formal_args,] *args, **kwargs): &quot;函数_文档字符串&quot; function_suite return [expression] 加了星号（*）的变量args会存放所有未命名的变量参数，args为元组；而加**的变量kwargs会存放命名参数，即形如key=value的参数， kwargs为字典。 &gt;&gt;&gt; def fun(a, b, *args, **kwargs): ... &quot;&quot;&quot;可变参数演示示例&quot;&quot;&quot; ... print &quot;a =&quot;, a ... print &quot;b =&quot;, b ... print &quot;args =&quot;, args ... print &quot;kwargs: &quot; ... for key, value in kwargs.items(): ... print key, &quot;=&quot;, value ... &gt;&gt;&gt; fun(1, 2, 3, 4, 5, m=6, n=7, p=8) # 注意传递的参数对应 a = 1 b = 2 args = (3, 4, 5) kwargs: p = 8 m = 6 n = 7 &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; c = (3, 4, 5) &gt;&gt;&gt; d = &#123;&quot;m&quot;:6, &quot;n&quot;:7, &quot;p&quot;:8&#125; &gt;&gt;&gt; fun(1, 2, *c, **d) # 注意元组与字典的传参方式 a = 1 b = 2 args = (3, 4, 5) kwargs: p = 8 m = 6 n = 7 &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; fun(1, 2, c, d) # 注意不加星号与上面的区别 a = 1 b = 2 args = ((3, 4, 5), &#123;&#39;p&#39;: 8, &#39;m&#39;: 6, &#39;n&#39;: 7&#125;) kwargs: &gt;&gt;&gt; &gt;&gt;&gt; 5.3、引用传参 可变类型与不可变类型的变量分别作为函数参数时，会有什么不同吗？ Python有没有类似C语言中的指针传参呢？ &gt;&gt;&gt; def selfAdd(a): ... &quot;&quot;&quot;自增&quot;&quot;&quot; ... a += a ... &gt;&gt;&gt; a_int = 1 &gt;&gt;&gt; a_int 1 &gt;&gt;&gt; selfAdd(a_int) &gt;&gt;&gt; a_int 1 &gt;&gt;&gt; a_list = [1, 2] &gt;&gt;&gt; a_list [1, 2] &gt;&gt;&gt; selfAdd(a_list) &gt;&gt;&gt; a_list [1, 2, 1, 2] Python中函数参数是引用传递（注意不是值传递）。对于不可变类型，因变量不能修改，所以运算不会影响到变量自身；而对于可变类型来说，函数体中的运算有可能会更改传入的参数变量。 想一想为什么&gt;&gt;&gt; def selfAdd(a): ... &quot;&quot;&quot;自增&quot;&quot;&quot; ... a = a + a # 我们更改了函数体的这句话 ... &gt;&gt;&gt; a_int = 1 &gt;&gt;&gt; a_int 1 &gt;&gt;&gt; selfAdd(a_int) &gt;&gt;&gt; a_int 1 &gt;&gt;&gt; a_list = [1, 2] &gt;&gt;&gt; a_list [1, 2] &gt;&gt;&gt; selfAdd(a_list) &gt;&gt;&gt; a_list [1, 2] # 想一想为什么没有变呢？","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python速成","slug":"Python/Python速成","permalink":"http://www.a2data.cn/categories/Python/Python%E9%80%9F%E6%88%90/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"6.Python函数(上)","slug":"Python/Python速成/6、Python函数(上)","date":"2019-12-14T03:40:19.000Z","updated":"2020-09-11T08:14:26.851Z","comments":true,"path":"posts/34946.html","link":"","permalink":"http://www.a2data.cn/posts/34946.html","excerpt":"Python函数介绍上篇","text":"Python函数介绍上篇 Python函数(上)1、什么是函数 如过在开发程序时，需要某块代码使用多次，但是为了提高编写的效率以及代码的复用。 将具有独立功能的代码块组织为一个小模块—-&gt;函数 2、函数的定义和调用2.1、定义函数 格式如下： def 函数名(): 代码 定义一个函数打印信息 def printinfo(): print (&#39;-&#39;*21) print(&#39;--人生苦短，我用Python--&#39;) print(&#39;-&#39;*21) 2.2、调用函数 定义函数之后，就相当于具备一些功能的代码块，想要这些代码执行，就需要调用函数。 （定义函数后，函数不会自动执行的）如何调用呢？ 函数名（） 2.3、动动手 定义一个函数，能够输出自己的姓名和年龄，并且调用这个函数让它执行！ 使用def 定义函数 编写函数完成之后，通过 函数名（）调用 2.4、函数的文档说明&gt;&gt;&gt; def test(a,b): ... &quot;用来完成对2个数求和&quot; ... print(&quot;%d&quot;%(a+b)) ... &gt;&gt;&gt; &gt;&gt;&gt; test(11,22) 33 如果执行，以下代码 &gt;&gt;&gt; help(test) 能够看到test函数的相关说明 Help on function test in module __main__: test(a, b) 用来完成对2个数求和 (END) 3、函数参数3.1、定义带有参数的函数def addnum(a,b): c =a+b print (c) 3.2、调用带参函数# 调用带有参数的函数时，需要在小括号中，传递数据 addnum(12,28) 3.3、参数练习题 要求：定义一个函数，完成前2个数完成加法运算，然后对第3个数，进行减法；然后调用这个函数 使用def定义函数，要注意有3个参数 调用的时候，这个函数定义时有几个参数，那么就需要传递几个参数 3.4、调用函数时参数的顺序&gt;&gt;&gt; def test(a,b): ... print(a,b) ... &gt;&gt;&gt; test(1,2) 1 2 &gt;&gt;&gt; test(b=1,a=2) 2 1 &gt;&gt;&gt; &gt;&gt;&gt; test(b=1,2) File &quot;&lt;stdin&gt;&quot;, line 1 SyntaxError: positional argument follows keyword argument &gt;&gt;&gt; 3.5、总结 定义时小括号中的参数，用来接收参数用的，称为 “形参” 调用时小括号中的参数，用来传递给函数用的，称为 “实参” 4、返回值 所谓“返回值”，就是程序中函数完成一件事情后，最后给调用者的结果 4.1、返回值的函数 想要在函数中把结果返回给调用者，需要在函数中使用return 如下示例 def add2num(a, b): c = a+b return c 或者 def add2num(a, b): return a+b 4.2、保存函数的返回值 #定义函数 def add2num(a, b): return a+b #调用函数，顺便保存函数的返回值 result = add2num(100,98) #因为result已经保存了add2num的返回值，所以接下来就可以使用了 print result 结果 198 5、函数的类型 根据有没有参数，有没有返回值，可以互相结合，一共有4种 无参数，无返回值 无参数，有返回值 有参数，无返回值 有参数，有返回值 5.1、无参数，无返回值 此类函数，不能接收参数，也没有返回值，一般情况下，打印提示灯类似的功能，使用这类的函数 def printMenu(): print(&#39;-----------&#39;) print(&quot;欢迎关注A2Data&quot;) 5.2、无参数，有返回值 此类函数，不能接收参数，但是可以返回某个数据，一般情况下，像采集数据，用此类函数 # 获取温度 def getTemperature(): #这里是获取温度的一些处理过程 #为了简单起见，先模拟返回一个数据 return 24 temperature = getTemperature() print(&#39;当前的温度为:%d&#39;%temperature) 5.3、有参数，无返回值 此类函数，能接收参数，但不可以返回数据，一般情况下，对某些变量设置数据而不需结果时，用此类函数 5.4、有参数，又返回值 此类函数，不仅能接收参数，还可以返回某个数据，一般情况下，像数据处理并需要结果的应用，用此类函数 # 计算1~num的累积和 def calculateNum(num): result = 0 i = 1 while i&lt;=num: result = result + i i+=1 return result result = calculateNum(100) print(&#39;1~100的累积和为:%d&#39;%result) 结果 1~100的累积和为: 5050 5.5、小归纳 函数根据有没有参数，有没有返回值可以相互组合 定义函数时，是根据实际的功能需求来设计的，所以不同开发人员编写的函数类型各不相同 6、函数的嵌套调用","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python速成","slug":"Python/Python速成","permalink":"http://www.a2data.cn/categories/Python/Python%E9%80%9F%E6%88%90/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"5.Python元组与字典","slug":"Python/Python速成/5、Python元组与字典","date":"2019-12-13T00:48:16.000Z","updated":"2020-09-11T08:14:26.836Z","comments":true,"path":"posts/520.html","link":"","permalink":"http://www.a2data.cn/posts/520.html","excerpt":"Python的元组与字典","text":"Python的元组与字典 元组 Python的元组与列表类似，不同之处在于元组的元素不能修改。元组使用小括号，列表使用方括号。 &gt;&gt;&gt; aTuple = (&#39;a2data&#39;,66,99.9) &gt;&gt;&gt; aTuple (&#39;a2data&#39;,66,99.9) 1、访问元组 2、修改元组 说明： python中不允许修改元组的数据，包括不能删除其中的元素。 3、元组的内置函数count, index index和count与字符串和列表中的用法相同 &gt;&gt;&gt; a = (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;, &#39;b&#39;) &gt;&gt;&gt; a.index(&#39;a&#39;, 1, 3) # 注意是左闭右开区间 Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; ValueError: tuple.index(x): x not in tuple &gt;&gt;&gt; a.index(&#39;a&#39;, 1, 4) 3 &gt;&gt;&gt; a.count(&#39;b&#39;) 2 &gt;&gt;&gt; a.count(&#39;d&#39;) 0 字典 字典介绍 定义字典 获取字典数据(键、get) 想一想： 如果有列表 nameList = [&#39;a2data&#39;, &#39;a2data1&#39;, &#39;a2data2&#39;]; 需要对”xiaoWang”这个名字写错了，通过代码修改： nameList[1] = &#39;a2data112&#39; 如果列表的顺序发生了变化，如下 nameList = [&#39;a2data&#39;, &#39;a2data2&#39;, &#39;a2data112&#39;]; 此时就需要修改下标，才能完成名字的修改 nameList[2] = &#39;a2data112&#39; 有没有方法，既能存储多个数据，还能在访问元素的很方便就能够定位到需要的那个元素呢？ 答： 字典 另一个场景： 学生信息列表，每个学生信息包括学号、姓名、年龄等，如何从中找到某个学生的信息？ &gt;&gt;&gt; studens = [[1001, &quot;王宝强&quot;, 24], [1002, &quot;马蓉&quot;, 23], [1005, &quot;宋喆&quot;，24], ...] 循环遍历？ No！ 0、根据键访问值 info = &#123;&#39;name&#39;:&#39;班长&#39;, &#39;id&#39;:100, &#39;sex&#39;:&#39;f&#39;, &#39;address&#39;:&#39;地球亚洲中国北京&#39;&#125; print(info[&#39;name&#39;]) print(info[&#39;address&#39;]) 结果: 班长 地球亚洲中国北京 若访问不存在的键，则会报错： &gt;&gt;&gt; info[&#39;age&#39;] Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; KeyError: &#39;age&#39; 在我们不确定字典中是否存在某个键而又想获取其值时，可以使用get方法，还可以设置默认值： &gt;&gt;&gt; age = info.get(&#39;age&#39;) &gt;&gt;&gt; age #&#39;age&#39;键不存在，所以age为None &gt;&gt;&gt; type(age) &lt;type &#39;NoneType&#39;&gt; &gt;&gt;&gt; age = info.get(&#39;age&#39;, 18) # 若info中不存在&#39;age&#39;这个键，就返回默认值18 &gt;&gt;&gt; age 18 1、常见操作11.1、查看元素除了使用key查找数据，还可以使用get来获取数据 1.2、修改元素字典的每个元素中的数据是可以修改的，只要通过key找到，即可修改 1.3、添加元素访问不存在的元素 如果在使用 变量名[‘键’] = 数据 时，这个“键”在字典中，不存在，那么就会新增这个元素 添加新的元素 1.4、删除元素对字典进行删除操作，有一下几种： del clear() del 删除指定的元素 del 删除整个字典 clear 清空整个字典 info = &#123;&#39;name&#39;:&#39;a2data&#39;, &#39;sex&#39;:&#39;f&#39;, &#39;address&#39;:&#39;China&#39;&#125; print(&#39;清空前,%s&#39;%info) info.clear() print(&#39;清空后,%s&#39;%info) 2、常见操作22.1、len() 测量字典中，键值对的个数 2.2、keys 返回一个包含字典所有KEY的列表 2.3、values 返回一个包含字典所有value的列表 2.4、items 返回一个包含所有（键，值）元祖的列表 2.5、has_key dict.has_key(key)如果key在字典中，返回True，否则返回False 在python3之后删除了这个方法。 contains(key) 3、字典遍历 通过for … in …:的语法结构，我们可以遍历字符串、列表、元组、字典等数据结构。 注意python语法的缩进 3.1、字符串遍历&gt;&gt;&gt; a_str = &quot;hello itcast&quot; &gt;&gt;&gt; for char in a_str: ... print(char,end=&#39; &#39;) ... h e l l o i t c a s t 3.2、列表遍历&gt;&gt;&gt; a_list = [1, 2, 3, 4, 5] &gt;&gt;&gt; for num in a_list: ... print(num,end=&#39; &#39;) ... 1 2 3 4 5 3.3、元组遍历&gt;&gt;&gt; a_turple = (1, 2, 3, 4, 5) &gt;&gt;&gt; for num in a_turple: ... print(num,end=&quot; &quot;) 1 2 3 4 5 3.4字典遍历3.4.1、key（键） 3.4.2、value（值） 3.4.3、项（元素） 3.4.4、 key-value（键值对） 想一想，如何实现带下标索引的遍历 &gt;&gt;&gt; chars = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] &gt;&gt;&gt; i = 0 &gt;&gt;&gt; for chr in chars: ... print(&quot;%d %s&quot;%(i, chr)) ... i += 1 ... 0 a 1 b 2 c 3 d enumerate() &gt;&gt;&gt; chars = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] &gt;&gt;&gt; for i, chr in enumerate(chars): ... print i, chr ... 0 a 1 b 2 c 3 d 4、公共方法4.1、运算符 运算符 Python 表达式 结果 描述 支持的数据类型 + [1, 2] + [3, 4] [1, 2, 3, 4] 合并 字符串、列表、元组 * ‘Hi!’ * 4 [‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’] 复制 字符串、列表、元组 in 3 in (1, 2, 3) True 元素是否存在 字符串、列表、元组、字典 not in 4 not in (1, 2, 3) True 元素是否不存在 字符串、列表、元组、字典 +&gt;&gt;&gt; &quot;hello &quot; + &quot;a2data&quot; &#39;hello a2data&#39; &gt;&gt;&gt; [1, 2] + [3, 4] [1, 2, 3, 4] &gt;&gt;&gt; (&#39;a&#39;, &#39;b&#39;) + (&#39;c&#39;, &#39;d&#39;) (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;) *&gt;&gt;&gt; &#39;ab&#39;*4 &#39;ababab&#39; &gt;&gt;&gt; [1, 2]*4 [1, 2, 1, 2, 1, 2, 1, 2] &gt;&gt;&gt; (&#39;a&#39;, &#39;b&#39;)*4 (&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;) in&gt;&gt;&gt; &#39;a2&#39; in &#39;hello a2data&#39; True &gt;&gt;&gt; 3 in [1, 2] False &gt;&gt;&gt; 4 in (1, 2, 3, 4) True &gt;&gt;&gt; &quot;name&quot; in &#123;&quot;name&quot;:&quot;小风&quot;, &quot;age&quot;:24&#125; True 注意，in在对字典操作时，判断的是字典的键 4.2、python内置函数 Python包含了以下内置函数 Python3 使用 import operator 序号 方法 描述 1 cmp(item1, item2) 比较两个值 2 len(item) 计算容器中元素个数 3 max(item) 返回容器中元素最大值 4 min(item) 返回容器中元素最小值 5 del(item) 删除变量 cmp&gt;&gt;&gt; cmp(&quot;hello&quot;, &quot;a2data&quot;) -1 &gt;&gt;&gt; cmp(&quot;a2data&quot;, &quot;hello&quot;) 1 &gt;&gt;&gt; cmp(&quot;a2data&quot;, &quot;a2data&quot;) 0 &gt;&gt;&gt; cmp([1, 2], [3, 4]) -1 &gt;&gt;&gt; cmp([1, 2], [1, 1]) 1 &gt;&gt;&gt; cmp([1, 2], [1, 2, 3]) -1 &gt;&gt;&gt; cmp(&#123;&quot;a&quot;:1&#125;, &#123;&quot;b&quot;:1&#125;) -1 &gt;&gt;&gt; cmp(&#123;&quot;a&quot;:2&#125;, &#123;&quot;a&quot;:1&#125;) 1 &gt;&gt;&gt; cmp(&#123;&quot;a&quot;:2&#125;, &#123;&quot;a&quot;:2, &quot;b&quot;:1&#125;) -1 注意：cmp在比较字典数据时，先比较键，再比较值。 len&gt;&gt;&gt; len(&quot;hello a2data&quot;) 12 &gt;&gt;&gt; len([1, 2, 3, 4]) 4 &gt;&gt;&gt; len((3,4)) 2 &gt;&gt;&gt; len(&#123;&quot;a&quot;:1, &quot;b&quot;:2&#125;) 2 注意：len在操作字典数据时，返回的是键值对个数。 max&gt;&gt;&gt; max(&quot;hello a2data&quot;) &#39;t&#39; &gt;&gt;&gt; max([1,4,522,3,4]) 522 &gt;&gt;&gt; max(&#123;&quot;a&quot;:1, &quot;b&quot;:2&#125;) &#39;b&#39; &gt;&gt;&gt; max(&#123;&quot;a&quot;:10, &quot;b&quot;:2&#125;) &#39;b&#39; &gt;&gt;&gt; max(&#123;&quot;c&quot;:10, &quot;b&quot;:2&#125;) &#39;c&#39; del del有两种用法，一种是del加空格，另一种是del() &gt;&gt;&gt; a = 1 &gt;&gt;&gt; a 1 &gt;&gt;&gt; del a &gt;&gt;&gt; a Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; NameError: name &#39;a&#39; is not defined &gt;&gt;&gt; a = [&#39;a&#39;, &#39;b&#39;] &gt;&gt;&gt; del a[0] &gt;&gt;&gt; a [&#39;b&#39;] &gt;&gt;&gt; del(a) &gt;&gt;&gt; a Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; NameError: name &#39;a&#39; is not defined 4.3、多维列表/元祖访问的示例&gt;&gt;&gt; tuple1 = [(2,3),(4,5)] &gt;&gt;&gt; tuple1[0] (2, 3) &gt;&gt;&gt; tuple1[0][0] 2 &gt;&gt;&gt; tuple1[0][2] Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; IndexError: tuple index out of range &gt;&gt;&gt; tuple1[0][1] 3 &gt;&gt;&gt; tuple1[2][2] Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; IndexError: list index out of range &gt;&gt;&gt; tuple2 = tuple1+[(3)] &gt;&gt;&gt; tuple2 [(2, 3), (4, 5), 3] &gt;&gt;&gt; tuple2[2] 3 &gt;&gt;&gt; tuple2[2][0] Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; TypeError: &#39;int&#39; object is not subscriptable","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python速成","slug":"Python/Python速成","permalink":"http://www.a2data.cn/categories/Python/Python%E9%80%9F%E6%88%90/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"4.Python列表介绍","slug":"Python/Python速成/4、Python列表介绍","date":"2019-12-12T00:35:16.000Z","updated":"2020-09-11T08:14:26.840Z","comments":true,"path":"posts/58489.html","link":"","permalink":"http://www.a2data.cn/posts/58489.html","excerpt":"Python列表介绍","text":"Python列表介绍 Python列表解析章节1、列表介绍想一想： 前面学习的字符串可以用来存储一串信息，那么想一想，怎样存储公号所有粉丝的名字呢？ 定义100个变量，每个变量存放一个粉丝的姓名可行吗？有更好的办法吗？ 答： 列表 1.1、列表的格式变量A的类型为列表 namesList = [&#39;a2data&#39;,&#39;a2data1&#39;,&#39;a2data2&#39;] 比C语言的数组强大的地方在于列表中的元素可以是不同类型的 testList = [1, &#39;a&#39;] 1.2、打印列表demo: namesList = [&#39;a2data&#39;,&#39;a2data1&#39;,&#39;a2data2&#39;] print(namesList[0]) print(namesList[1]) print(namesList[2]) 结果： a2data a2data1 a2data2 2、列表的循环2.1、 使用for循环 为了更有效率的输出列表的每个数据，可以使用循环来完成 demo: namesList = [&#39;a2data&#39;,&#39;a2data1&#39;,&#39;a2data2&#39;] for name in namesList: print(name) 结果: a2data a2data1 a2data 2.2、 使用while循环为了更有效率的输出列表的每个数据，可以使用循环来完成 demo: namesList = [&#39;a2data&#39;,&#39;a2data1&#39;,&#39;a2data2&#39;] length = len(namesList) i = 0 while i&lt;length: print(namesList[i]) i+=1 结果: a2data a2data1 a2data2 3、列表的常见操作 列表中存放的数据是可以进行修改的，比如”增”、”删”、”改”、”查” 3.1、添加元素 (“增”append, extend, insert) append通过append可以向列表添加元素 demo: #定义变量A，默认有3个元素 A = [&#39;a2data&#39;,&#39;a2data1&#39;,&#39;a2data2&#39;] print(&quot;-----添加之前，列表A的数据-----&quot;) for tempName in A: print(tempName) #提示、并添加元素 temp = input(&#39;请输入要添加的学生姓名:&#39;) A.append(temp) print(&quot;-----添加之后，列表A的数据-----&quot;) for tempName in A: print(tempName) extend通过extend可以将另一个集合中的元素逐一添加到列表中 &gt;&gt;&gt; a = [1, 2] &gt;&gt;&gt; b = [3, 4] &gt;&gt;&gt; a.append(b) &gt;&gt;&gt; a [1, 2, [3, 4]] &gt;&gt;&gt; a.extend(b) &gt;&gt;&gt; a [1, 2, [3, 4], 3, 4] insertinsert(index, object) 在指定位置index前插入元素object &gt;&gt;&gt; a = [0, 1, 2] &gt;&gt;&gt; a.insert(1, 3) &gt;&gt;&gt; a [0, 3, 1, 2] 3.2、修改元素(“改”)：修改元素的时候，要通过下标来确定要修改的是哪个元素，然后才能进行修改 demo: #定义变量A，默认有3个元素 A = [&#39;a2data&#39;,&#39;a2data1&#39;,&#39;a2data2&#39;] print(&quot;-----修改之前，列表A的数据-----&quot;) for tempName in A: print(tempName) #修改元素 A[1] = &#39;a2data666&#39; print(&quot;-----修改之后，列表A的数据-----&quot;) for tempName in A: print(tempName) 结果: -----修改之前，列表A的数据----- a2data a2data1 a2data2 -----修改之后，列表A的数据----- a2data a2data666 a2data2 3.3、查找元素 (“查”in, not in, index, count) 所谓的查找，就是看看指定的元素是否存在 in, not in python中查找的常用方法为： in（存在）,如果存在那么结果为true，否则为false not in（不存在），如果不存在那么结果为true，否则false demo #待查找的列表 nameList = [&#39;a2data&#39;,&#39;a2data1&#39;,&#39;a2data2&#39;] #获取用户要查找的名字 findName = input(&#39;请输入要查找的姓名:&#39;) #查找是否存在 if findName in nameList: print(&#39;在字典中找到了相同的名字&#39;) else: print(&#39;没有找到&#39;) 说明： in的方法只要会用了，那么not in也是同样的用法，只不过not in判断的是不存在 index, countindex和count与字符串中的用法相同 &gt;&gt;&gt; a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;, &#39;b&#39;] &gt;&gt;&gt; a.index(&#39;a&#39;, 1, 3) # 注意是左闭右开区间 Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; ValueError: &#39;a&#39; is not in list &gt;&gt;&gt; a.index(&#39;a&#39;, 1, 4) 3 &gt;&gt;&gt; a.count(&#39;b&#39;) 2 &gt;&gt;&gt; a.count(&#39;d&#39;) 0 3.4、删除元素 (“删”del, pop, remove) 类比公号中，如果掉粉了，那么就应该把这个取关粉丝的姓名删除掉；在开发中经常会用到删除这种功能。 列表元素的常用删除方法有： del：根据下标进行删除 pop：删除最后一个元素 remove：根据元素的值进行删除 demo:(del) movieName = [&#39;a2data&#39;,&#39;a2data1&#39;,&#39;a2data2&#39;,&#39;a2data3&#39;,&#39;a2data4&#39;,&#39;a2data5&#39;] print(&#39;------删除之前------&#39;) for tempName in movieName: print(tempName) del movieName[2] print(&#39;------删除之后------&#39;) for tempName in movieName: print(tempName) 结果: ------删除之前------ a2data a2data1 a2data2 a2data3 a2data4 a2data5 ------删除之后------ a2data a2data1 a2data3 a2data4 a2data5 demo:(pop) movieName = [&#39;a2data&#39;,&#39;a2data1&#39;,&#39;a2data2&#39;,&#39;a2data3&#39;,&#39;a2data4&#39;,&#39;a2data5&#39;] print(&#39;------删除之前------&#39;) for tempName in movieName: print(tempName) movieName.pop() print(&#39;------删除之后------&#39;) for tempName in movieName: print(tempName) 结果: ------删除之前------ a2data a2data1 a2data2 a2data3 a2data4 a2data5 ------删除之后------ a2data a2data1 a2data2 a2data3 a2data4 demo:(remove) movieName = [&#39;a2data&#39;,&#39;a2data1&#39;,&#39;a2data2&#39;,&#39;a2data3&#39;,&#39;a2data4&#39;,&#39;a2data5&#39;] print(&#39;------删除之前------&#39;) for tempName in movieName: print(tempName) movieName.remove(&#39;a2data3&#39;) print(&#39;------删除之后------&#39;) for tempName in movieName: print(tempName) 结果: ------删除之前------ a2data a2data1 a2data2 a2data3 a2data4 a2data5 ------删除之后------ a2data a2data1 a2data2 a2data4 a2data5 3.5、排序(sort, reverse) sort方法是将list按特定顺序重新排列，默认为由小到大，参数reverse=True可改为倒序，由大到小。 reverse方法是将list逆置。 &gt;&gt;&gt; a = [1, 4, 2, 3] &gt;&gt;&gt; a [1, 4, 2, 3] &gt;&gt;&gt; a.reverse() &gt;&gt;&gt; a [3, 2, 4, 1] &gt;&gt;&gt; a.sort() &gt;&gt;&gt; a [1, 2, 3, 4] &gt;&gt;&gt; a.sort(reverse=True) &gt;&gt;&gt; a [4, 3, 2, 1] 4、列表的嵌套4.1 列表嵌套 类似while循环的嵌套，列表也是支持嵌套的 一个列表中的元素又是一个列表，那么这就是列表的嵌套 schoolNames = [[&#39;北京&#39;,&#39;山西&#39;], [&#39;湖南&#39;,&#39;天津&#39;,&#39;深圳&#39;], [&#39;长沙&#39;,&#39;上海&#39;]] 4.2、 应用 一个公号，有5个长期运营，现在要分配其中3个位置，但是有8位运营者等待分配，请编写程序，完成随机的分配 #encoding=utf-8 import random # 定义 一个运营管理者的列表 offices = [[],[],[]] # 定义一个列表用来存储8位运营者的名字 names = [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;,&#39;G&#39;,&#39;H&#39;] i = 0 for name in names: index = random.randint(0,2) offices[index].append(name) i = 1 for tempNames in offices: print(&#39;运营%d的人数为:%d&#39;%(i,len(tempNames))) i+=1 for name in tempNames: print(&quot;%s&quot;%name,end=&#39;&#39;) print(&quot;\\n&quot;) print(&quot;-&quot;*20)","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python速成","slug":"Python/Python速成","permalink":"http://www.a2data.cn/categories/Python/Python%E9%80%9F%E6%88%90/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"3.Python的字符串","slug":"Python/Python速成/3、Python的字符串","date":"2019-12-10T23:30:21.000Z","updated":"2020-09-11T08:14:26.834Z","comments":true,"path":"posts/29055.html","link":"","permalink":"http://www.a2data.cn/posts/29055.html","excerpt":"Python的字符串","text":"Python的字符串 Python的字符串1、字符串介绍 想一想： 当打来浏览器登录某些网站的时候，需要输入密码，浏览器把密码传送到服务器后，服务器会对密码进行验证，其验证过程是把之前保存的密码与本次传递过去的密码进行对比，如果相等，那么就认为密码正确，否则就认为不对；服务器既然想要存储这些密码可以用数据库（比如MySQL），当然为了简单起见，咱们可以先找个变量把密码存储起来即可；那么怎样存储带有字母的密码呢？ 答： 字符串 python中字符串的格式 如下定义的变量a，存储的是数字类型的值 a = 100 如下定义的变量b，存储的是字符串类型的值 b = &quot;hello a2data.cn&quot; 或者 b = &#39;hello www.a2data.cn&#39; 小总结： 双引号或者单引号中的数据，就是字符串 2、字符串输出demo name = &#39;小风&#39; position = &#39;大数据分析狮&#39; address = &#39;北京市朝阳区xxxx&#39; print(&#39;--------------------------------------------------&#39;) print(&quot;姓名：%s&quot;%name) print(&quot;职位：%s&quot;%position) print(&quot;公司地址：%s&quot;%address) print(&#39;--------------------------------------------------&#39;) 结果 -------------------------------------------------- 姓名： 小风 职位： 大数据分析狮 公司地址： 北京市朝阳区xxxx -------------------------------------------------- 3、字符串输入 在input的时候，通过它能够完成从键盘获取数据，然后保存到指定的变量中； 注意：input获取的数据，都以字符串的方式进行保存，即使输入的是数字，那么也是以字符串方式保存 demo userName = input(&#39;请输入用户名:&#39;) print(&quot;用户名为：%s&quot;%userName) password = input(&#39;请输入密码:&#39;) print(&quot;密码为：%s&quot;%password) 4、下标和切片4.1、下标索引 字符串中”下标”的使用 列表与元组支持下标索引好理解，字符串实际上就是字符的数组， 所以也支持下标索引。 如果有字符串:name = &#39;abcdef&#39;，在内存中的实际存储如下: 如果想取出部分字符，那么可以通过下标的方法，（注意python中下标从 0 开始） name = &#39;abcdef&#39; print(name[0]) print(name[1]) print(name[2]) 运行结果 4.2、切片 切片是指对操作的对象截取其中一部分的操作。字符串、列表、元组都支持切片操作。 切片的语法：[起始:结束:步长]注意：选取的区间属于左闭右开型，即从”起始”位开始，到”结束”位的前一位结束（不包含结束位本身)。 我们以字符串为例讲解。 如果取出一部分，则可以在中括号[]中使用 : name = &#39;abcdef&#39; print(name[0:3]) # 取 下标0~2 的字符 print(name[0:5]) # 取 下标为0~4 的字符 print(name[3:5]) # 取 下标为3、4 的字符 print(name[2:]) # 取 下标为2开始到最后的字符 print(name[1:-1]) # 取 下标为1开始 到 最后第2个 之间的字符 a = &quot;abcdef&quot; a[:3] &#39;abc&#39; a[::2] &#39;ace&#39; a[5:1:2] &#39;&#39; a[1:5:2] &#39;bd&#39; a[::-2] &#39;fdb&#39; a[5:1:-2] &#39;fd&#39; 想一想 （面试题）给定一个字符串aStr, 请反转字符串 例如： ‘www.a2data.cn&#39; 5、字符串常见操作 如有字符串mystr = &#39;hello world a2data and jackfeng&#39;，以下是常见的操作 5.1、find 检测 str 是否包含在 mystr中，如果是返回开始的索引值，否则返回-1 mystr.find(str,start=0, end=len(mystr)) mystr = &#39;hello world a2data and jackfeng&#39; 5.2、index 跟find()方法一样，只不过如果str不在 mystr中会报一个异常. mystr.index(str, start=0, end=len(mystr)) mystr = &#39;hello world a2data and jackfeng&#39; 5.3、count 返回 str在start和end之间 在 mystr里面出现的次数 mystr.count(str, start=0, end=len(mystr)) mystr = &#39;hello world a2data and jackfeng&#39; 5.4、replace 把 mystr 中的 str1 替换成 str2,如果 count 指定，则替换不超过 count 次. mystr.replace(str1, str2, mystr.count(str1)) name =&quot;hello world ha ha&quot; 5.5、split 以 str 为分隔符切片 mystr，如果 maxsplit有指定值，则仅分隔 maxsplit 个子字符串 mystr.split(str=&quot; &quot;, 2) name =&quot;hello world ha ha&quot; 5.6、capitalize 把字符串的第一个字符大写 mystr.capitalize() 5.7、title 把字符串的每个单词首字母大写 5.8、startswith 检查字符串是否是以 obj 开头, 是则返回 True，否则返回 False mystr.startswith(obj) 5.9、endswith 检查字符串是否以obj结束，如果是返回True,否则返回 False. mystr.endswith(obj) 5.10、lower 转换 mystr 中所有大写字符为小写 mystr.lower() 5.11、upper 转换 mystr 中的小写字母为大写 mystr.upper() 5.12、ljust 返回一个原字符串左对齐,并使用空格填充至长度 width 的新字符串 mystr.ljust(width) 5.13、rjust 返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串 mystr.rjust(width) 5.14、center 返回一个原字符串居中,并使用空格填充至长度 width 的新字符串 mystr.center(width) 5.15、lstrip 删除 mystr 左边的空白字符 mystr.lstrip() 5.16、rstrip 删除 mystr 字符串末尾的空白字符 mystr.rstrip() 5.17、strip 删除mystr字符串两端的空白字符 5.18、rfind 类似于 find()函数，不过是从右边开始查找. mystr.rfind(str, start=0,end=len(mystr) ) 5.19、rindex 类似于 index()，不过是从右边开始. mystr.rindex( str, start=0,end=len(mystr)) 5.20、partition 把mystr以str分割成三部分,str前，str和str后 mystr.partition(str) 5.21、rpartition 类似于 partition()函数,不过是从右边开始. mystr.rpartition(str) 5.22、splitlines 按照行分隔，返回一个包含各行作为元素的列表 mystr.splitlines() 5.23、isalpha 如果 mystr 所有字符都是字母 则返回 True,否则返回 False mystr.isalpha() 5.24、isdigit 如果 mystr 只包含数字则返回 True 否则返回 False. mystr.isdigit() 5.25、isalnum 如果 mystr 所有字符都是字母或数字则返回 True,否则返回 False mystr.isalnum() 5.26、isspace 如果 mystr 中只包含空格，则返回 True，否则返回 False. mystr.isspace() 5.27、join mystr 中每个字符后面插入str,构造出一个新的字符串 mystr.join(str) 想一想 （面试题）给定一个字符串aStr，返回使用空格或者’\\t’分割后的倒数第二个子串","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python速成","slug":"Python/Python速成","permalink":"http://www.a2data.cn/categories/Python/Python%E9%80%9F%E6%88%90/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"python第二天作业答案","slug":"Python/Python速成/python第二天作业答案","date":"2019-12-10T23:20:20.000Z","updated":"2020-09-11T08:01:01.043Z","comments":true,"path":"posts/27081.html","link":"","permalink":"http://www.a2data.cn/posts/27081.html","excerpt":"有东西被加密了, 请输入密码查看.","text":"您好, 这里需要密码.如若不知,请联系小编。163d7990d844d85d4b343793961f88f6691b2ac9101dd433f612620dfb90183d31e09db63073007a33e2b728c9a812009dd567a3a438edff90b577fc447c8740b188e61ce4f73c1d8513edab492988ad22a26d9e1f46e1144816a2c963d0f156b6fafb9bc916774c22578761919c6219cd1f211c263dc850ed564f1feb2857b5df1b237bf8435eace63a1e1302f1e0e204da10bdd477c53fa7b7a6dfa042301e50847a85fd3e4e28da320c92e46782c60afbcfce17c56e1ab4e9a12998bab7600548465b9601e8dce4a5a9aaf48820c195b7da5c85823c632200dc59188d6aac1c0701ab1cfc487004e3b9a0aca8d60b9d1a5ae1b0a78336a4d66eef8789efa0022700f3fec319f5925f6e217ca55c03d311f644da8f9dcf6cccbaa60410486930a90e6223749486d3c89cc5fd00f9a67276e04415358db052877bb86c4e25a1f0de8ced4e1f86e307ac22fa8db40fc9871857e0525c41be2eb62334f2929200fec9287930de17e2463a774a2bee815b5ab51bde0f6f97a9bd596183ed83764d65cd2df4aca4165fe675f0ddef88531306d16be9ec65d8a3211787a8fa1ba9e223e2983077788aabd7ffb5560fd3713d487d6e3c33353bd739710160549ec08ed46da901c2cc1d40b2c35cf9fc76d030303534beee5f7db5af36f97f8dc974c448628baed1510a97b4ec20378094561e94ee315f8f1edd69f5593b4cbdc7d0e8fe5a796365cc320c0562106f133ccebb46e4d180fc81a79105a7105ed3d55f18da488e67c7e798b89f31e8a72c451b10d05a189a919f4319499a726e151b7ee6eccbf151585a9002453b6f4f80d11f8ab2dca61770ed65568e62fe5e45b1502cece027e9ab0131aa7c6d16fe3c709758506acee09374fcfdc8446f0146f0603fb58ecbce032664e00a98da0bf9721ac691f7f87e84105e9142c71c6a54414a9130f0fa0e6cf9770d4107468a89097ee29cb62cd472dcfda436e177ee83f6763cbcf6297a11c4b7309343104aae31fe74ec6615bad4633873862cc337c8227bd69b94c0f70b6a31286084f536dceeff79d7e4ece1160aaad6266422b2b6d5711549ff314284f88ad9860bcdeaac2904d446929e090f6887e2c5415e74d7ba815081c57d1f97e8248fc8c2416590302ca882a8a820063c056083eec623ca2a57315fd6ef5e0c2e1ec3f256156b7a74ef6804c45e29130d30486e6aa34836755d47d50c8a5455faa8ab222e7782a6fdb71b9890ac82add0d5593babe16adfe24902fddbc540daecb6ec194478a3eb3e14e9f86e570ea83b51dbae54e9deb1940b09a69f001f8ff534e9ed4cef813b9ea6b4c040016f494134a448bb4efc135a145027c65301f970c7768b78b0bbb59f12cfa88532062b4a3aeb7a1e5608664405e5ee0e73ee66cc34847927f941cb1c30e5a2fc336c142c5427ccafee0adc47b21a28af951e30c2860f186bc7c5f5d434ca535b0891796c9c6ff4fd54daa1d7254d6890cac41efa3ba118b57022a870542922e6d4dd972292ffc1b5f8d1472315e7ad6fc02dfaf3004d86f00fc72528823c0e9d9809536d6791852e2ed72796ced29d9396072612fad3200e81eb2685a49a1bba160d637641a68d4786fec5bbf512fc91400516d651adfad4bdb14fd6c854c252a8ece5da2a9eb9b6fd49c7ce1103fb84515bbeb0befddc447e9e9c31438aaa8ab769fc1447ee41a037118912f69e3c641f444a985da4d5f8d536badcefaa59baab0fca3ceea299836b46c2d5926106c04377ff16833f80ee527c43c16417aee9d9df0e96bfa2b805e946d2d27f1dd743ab96c817973ff16e2fabe5814e50d5e0afac90d53fa15eb8436f5f0471f5d824d5cb182e13b34590c2434ca4b89e71596dd5f754b2d274e48a3c67fefe12faaec12d519b0b6fa37171d7384e2b40c1b588522fac7323ba38ccdcb3b7bac315c64a0677bed5ec3c3e56ef968e3b7f0c1ba5ac611575fff42d11ed616a6cd843f8c54d1151fb8021a4dfe4f4628ab86eb5366d5593c899e0430fadd389d1112beccf81b662fdb7dbb53d574c00c827b317e56c5312bd4d3df1993ebfab4f65938975b6556f2d3a64cde061e647b27c0114bc35549d28446b4eb487a1c96e6fa873b1b988b20d4e670cc1630a88af0e65afbbc27fbe532a420da261d9a234270a243dada463a2662517b7b17036dd699c5848771b87195fcfc9645d715d9569f18e1acde2ae84f0deccac8dd927afae68b54db27786a0ce7e4292eda5402d802aa6dd9fab9a67e8de309c2ca028196406074803acf54ac1bfb13b3bacd5de36ce0fde8742c34e61490bc3eaee4fcfd940d674dde4006d116ffad1565f5eef88b28b21ce9d1506e5ce4c4308fe1fd6be298cb38ea64ac9bfece0cfe4167d1098f2c4b485faa4ab6affb490c76d4e92e81bfb662a054cc5b41a317c19402e7d59a36c944611e95e0e2e88ae58edf740479e28fbe5d9e2e920f548e17dcd97c3f853f11196fa5885ce1226194500697cb03c3c62298eba9b7c7d939cdd61f5d69fedd21811f57b73d5fd039845c6bf822ae6ef1efbdaab48094a9c8f2d6c93658eb1445943fb31e89ee6dd57bd0f9e18bb520578e1777464551924c739c3c1207c09a9c8c25edc3c9575bc0e756a5210d7435197e25bc4a71760b3a548437f5a9ac6628454c6a701efcecac44bfecc3862a49d32dd5dc55faa4a79c6eb53d535e4af0e507902174b42203e75476b9abb396e6062494b4adb2e9bc9a773dcae7e8a5e632be95ecee32a9d07a9775c2c48c67ddcb63b2123b94b1c6eee6ef24038ebc131fb17e8031b2cf04dfa97c4bd4c892cda2f67fd52aaf6516a3d8b89af373540d4d3eaebe75de935f779c9b21618140631548fb6a7e530e48c29bf7310869fd0383d16be0d9e5969c37f939faeaf71785c65d67efb24d81684766e086866e4d864b1220169aef0e702b736705bc094b1c7ed4014f0f6a9032a17ae7bc7c32affdf1b7baf6921bb4292bece5ee1009db16edf64684c18044340d5f5aee751c144f2f92e4cfb559a207e83bf69838a8591342a467798acdf6df97e8a0ff410da0345b9977bb7e2ac7a2cbe3978181ffb36296a431c9cd3050256b42bdced11bcca3790e186ab0ed98d6bdf059b993310716a30a6d5e36e5e4ac39557c4ce3ac70de8050331f2d9afc6b3596fdd9bbe097f8ef7b749caa5bc28df129b134b15bb3800cc671cfff79d2a6a146ac618a5a6e99767036fa05a36a54c81b1e4dba48e5d798ca99ebb4863d1165f34b580715d0296f452e4ea07d48a505d8314cd9f9b03e8c51efb4950b9288ae7addadd6b8cc3837d6121361a9b1d5f13b60e43fb3f8d15df7612b88a7e21225ae12f33c33603810e5745b4e77de8af116284356a2ce5b433626cbed099dd9d170b32279bd265da082486f9a2bec18275f04b72adf54762fd0ba92fbe2d3727d79d411796e322d258cee8305817626cf703da7bd05afc47f72134b3868bd63c08dcaf39b82eaaa132c3993b73d500dea533f803ae735cbec2f563735b6e920b9b2849ed34645e89bc80b73c15a188102c44237bac76b4daba31f1eb014ee47417a926f7d17317a7a1c721b163a474447fb913275d84836ba5ebe63bf934c58180806b543032f219d4af3ddf5c8fa8c0960e1f442d843d2f3891d673d8ee30eab08da2c0df19c85891d6f6ab5ea3097b0b19a6197fba8e44258dc02b9e4fae4a3b01b5ed79955a44a00aa41a210d853c0b0352b2dd8fa40fd0606da35de312d98590b0e02ff796a1acc198696355a693cea8920536d5dba6dc0782045f141ef116cd1e9d76a16a22266cf776a94a2876eb0125603b576b6b8f01270635a80e26cff0c015aeae1d378575873df53d3ddd7a1715ebf866092412c2bee7c95dde818d35e715debe3586b66b626d5202fa8550cb78204bd5784beecc18a1a6296eed3de60b5a7c40a17dce9c217226c91aaf9ba220ab6c7f8abec4396b4d3b14acd27c9a3bf7e2a287a45b41365347a23fb194770c0c08a9aec9b38e3481b3125de2d60cf39f57923b53b133c332a4a9773958f72e85e43bcf92d826aa3fbe0af6cbbeb5a803c89657c3fa0e30edb3ec5dd91897599333c34542d1921b13a611534e465f9affea23160438798c40acfe624b4bc36675365a35d16cc6c6b120fa7dff11a5cb9f93b1fb4a9fee3f1c2118cec8eb8bafa6540d34aca0823476ddd1c77000d95cd0c857e4d1cc5c68633f92cf3c0555ba9da3ca4e0b07f999d23d523cdef625994c31dec2ed00840600b0265cc4df3e1bea9c1767487fba9439a44084d4dba340a49e8b869c3f505b974c30419a7c26bb2493024a138ec2e3ddd3e24dbebd046e5f035b78d512f8d24869866415c261f735ea96bad16cbeb917370ca26faf028d0e039d23b68dff0058b8e999461c8b857c19d721b8ef8751c1a5b1fbccef0e6578ea8ddda36da3acdd9ca72460d109b4a1fb1c66ed15c9bb9a8a9442931c5aab12b0519feb4ffae1a410979e6d19f7cda1429b93d6acab4531f8d3eac227a5ba199fe353fe5d963d4b4edf36ec94d897a4113221ba9f99e3a76fa4f4647cadcb8aed60891dba048e2cef2e0b98a89836b6f4288fb8523aaec6c7ff37d1aa8b51e4aa26dde5463f02234e570ac03e66d1d83301be8b3580e92c10a76da852f8c8ccfcf089855c2d2ba61598c889019e9a8631fa007ec911a40f6da5a0259fa1b3314ffec9cfde55b27085fc815a8712c2bcb4a582e2ad69a1f870ea718c328d4a40401b8ef79af6467b37f7a53550a4c80fe2991c9fd249dd9db825e5514121fd7eb6e3512022a2f7e80d5ee45f8198005581d84a04028e56a74819b0f6a38259ad49afe7791dc7a6357ed01d0293bd98f554a123825cbd075e3d222c98a84311caf2ec64789b679f8bc9a3f1e44168cb30c73a1838a2999c72c962bdfa03da4a3bdfe83c38d7a360e4630707d612566883b52da5874655ea36ed7a0c61ba5c5af24c8094efe4cc68170f3427af25c50dc976dbf0ac32d01df798194ae27350c90776d74625b19e12b2d8b929447df9a382c55612c735de4489508e2a039bb1f44a22e7671b1ab71db69f708619e69b0bc84f9375d8780f5003b15842b692ef6a7e48b1bdac074e189e0f23ddd5a3d2c821258578f75caf6cfa306001c5b0e6e5ee3c28d75c67a9bce6c6602ca62ee3a9d46104f36179dc8539cfe85315f78673c76e1f02cd03adfa55b78c03e111eecf4be53dfc374461b5ef5b2a2f89fc71230574903a2421fb6c54f521d52efe48922cac0bc8683b0b00344bae4f61b3a43a16eceeb1e102f86a5cb59d3cf320095b6d2f68a24a22cbfb705fefaa908c52ae4535a6a329932a06f356422c4dd9dd06b633b3d712d2d167488f1960f1badee0285ac0d2906f2787d48dd2b580da09dc72ad7e71ecc6f4f21501de9f4cf2b9e751cbe6c3ef2fa41865a9c978a494ea3817f15499c4291e0819e128a1be77c1a05e2d53ce98d8f4adde9e9b20ecae1a124e41ee3fa5fe954e982c461bfe7f6b4523a25b1634ed27758ad230dc1c3be24465f4d65dbfe281957578264e96cfcd13560df564fb2ed0f56101287c83c001c668495b49e934b16fda69adac3901304468c4ec144d9caee7fab03fdd1037d79f52ee7f98817c434f0bac6337e808dd681177773155d9d217000828acc28250eab90f48b715f731f5f79f822cf3982ce18a38a70dbbbf1588ac20b1c422ba8ce3768dd036eb2dcc15166ea929499b7e18d29a0f4785d96e5c8daffbd84150bab4080b3151c60757963c642b76cb7c10e2dd568d9efab79bf9cf9bd1d7b96fbcd218a76c5c8baf6659b76e26b89fd8a613dff0493377727cff58692a5bf2bf68ab8c471fb170c1265014691383b69c69ece6280bfb34a35c822e553dd03f80f4f4812cdf7162768726c951d5d3db34a059bdb30dc37d288ec95f1d9b231c3538562fc8ff97c7e4b21be675432cf7f36435d0c29cf2e01063b219789abeab6bb7c478ecef0f1aa97300744e48684523ed489614017a2f94b0f5b6c6d7444e79229310373b97d072536efd8a409668b0ef296323c35dfcfcb72cefb39571421d36d1e44f8799a4ff00189a7f08f0ccde0c19f6a3a7e2a36cf56a849a72914a33f039315961ac4d31103bf4aa95b8ba5278689278531dc56638bac992bb71e567824f2b023d8ee7a2df40c6e6dd783149488c3d936342b4dbef3632a2b54b20358479cc08203ec9625068a8e08837310cd464ee0bf873f8c1f95ffe6353f897f29dd642d760b211b3d374779633d4b977ad7d1d461a3dc6ec2205c3cbc428550a0147ddbf53ae5d837e60a703f4eed8602cbd5161ea970c5b84f0dab6d0199605ebc4ed01e4b41881438b0035f8e846715693be841edbd01758eea3a0f88bc5684d56cead450e358faf12ff50a666d462cd6be6741df17238e26b8641c28bbbb07ece78becdcc1682d3849262a728688853cfc838dbe7020e7939a7805979cd1ac39d522a87a117b8628e9e46f518092c6ac52b8965eb6669a9e2a6488e447bd945e4679fb7765badbe5b2350d8b2dcf8e1389e51018b78c94bc562063fae44054642b0b3dbcfed904c5327b4712d9bab3d5919cf969ee453f05abcf6a198b586ea728f050ea36155090c72c2066311bb0d988728fdf16d521bef09362832a5a1f1d10073c57474718348d911922c9061b558761fc51d7ec61454837aee372f36909aee969baa63ce203db55a952f0811d945c1bacd1ba23e099038ab0f4aa1a0cba654e29c479ba1431a9a240f3be39241d7ddcab8f929b1f4397365669d49c73c2162e19895c36e968156ca46b4ab59714c9a37e53e118822a6799488a75c74775aeffe4f4531dc3a9b45b66f262972af8af5588cbe67056fb5bfccbf1f26ea3c6de68964cda6e188cfff33b3873de432430637d65302d8e5aca4ba1742e709919233a4aa55c55a6cfb09d0bfe9df43f5b019e11f11e14e7047e6b29a8c7692e3bd96b521ee741e7f9dc5a2dab4bf0ece5d69fef496effe775c0642f7a7f11b235963f1b719f685bfe0394c3a66d495d502f94bfe","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python速成","slug":"Python/Python速成","permalink":"http://www.a2data.cn/categories/Python/Python%E9%80%9F%E6%88%90/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"},{"name":"Python习题","slug":"Python习题","permalink":"http://www.a2data.cn/tags/Python%E4%B9%A0%E9%A2%98/"}]},{"title":"2.Python判断和循环语句","slug":"Python/Python速成/2、Python判断和循环语句","date":"2019-12-08T23:47:37.000Z","updated":"2020-09-11T08:14:26.849Z","comments":true,"path":"posts/51417.html","link":"","permalink":"http://www.a2data.cn/posts/51417.html","excerpt":"Python的判断和循环语句","text":"Python的判断和循环语句 Python判断循环语句1、if-else 掌握 if-else 的语法格式 想一想：在使用if的时候，它只能做到满足条件时要做的事情。那万一需要在不满足条件的时候，做某些事，该怎么办呢？ 答：else 1.1、使用格式 if 条件: 满足条件时要做的事情1 满足条件时要做的事情2 满足条件时要做的事情3 ...(省略)... else: 不满足条件时要做的事情1 不满足条件时要做的事情2 不满足条件时要做的事情3 ...(省略)... demo 马上要过年了，又到了抢票的季节。 chePiao = 1 # 用1代表有车票，0代表没有车票 if chePiao == 1: print(&quot;有车票，可以上火车&quot;) print(&quot;终于可以坐着回家了，美滋滋~~~&quot;) else: print(&quot;没有车票，不能上车&quot;) print(&quot;可否上车补票啊，真是一票难求啊~~~~(&gt;_&lt;)~~~~&quot;) 1.2、练一练 要求：从键盘输入刀子的长度，如果刀子长度没有超过10cm，则允许上火车，否则不允许上火车 2、elif 想一想: if能完成当xxx时做事情 if-else能完成当xxx时做事情1，否则做事情2 如果有这样一种情况： 当xxx1时做事情1， 当xxx2时做事情2， 当xxx3时做事情3， 那该怎么实现呢？ 答: elif 2.1、elif的功能elif的使用格式如下 if xxx1: 事情1 elif xxx2: 事情2 elif xxx3: 事情3 说明: 当xxx1满足时，执行事情1，然后整个if结束 当xxx1不满足时，那么判断xxx2，如果xxx2满足，则执行事情2，然后整个if结束 当xxx1不满足时，xxx2也不满足，如果xxx3满足，则执行事情3，然后整个if结束 demo score = 77 if score&gt;=90 and score&lt;=100: print(&#39;本次考试，等级为A&#39;) elif score&gt;=80 and score&lt;90: print(&#39;本次考试，等级为B&#39;) elif score&gt;=70 and score&lt;80: print(&#39;本次考试，等级为C&#39;) elif score&gt;=60 and score&lt;70: print(&#39;本次考试，等级为D&#39;) elif score&gt;=0 and score&lt;60: print(&#39;本次考试，等级为E&#39;) 2.2、注意点 可以和else一起使用 if 性别为男性: 输出男性的特征 ... elif 性别为女性: 输出女性的特征 ... else: 第三种性别的特征 ... 说明: 当 “性别为男性” 满足时，执行 “输出男性的特征”的相关代码 当 “性别为男性” 不满足时，如果 “性别为女性”满足，则执行 “输出女性的特征”的相关代码 当 “性别为男性” 不满足，“性别为女性”也不满足，那么久默认执行else后面的代码，即 “第三种性别的特征”相关代码 elif必须和if一起使用，否则出错 3、if嵌套想一想： 坐火车或者地铁的实际情况是：先进行安检如果安检通过才会判断是否有车票，或者是先检查是否有车票之后才会进行安检，即实际的情况某个判断是再另外一个判断成立的基础上进行的，这样的情况该怎样解决呢？ 答： if嵌套 3.1、嵌套格式 if 条件1: 满足条件1 做的事情1 满足条件1 做的事情2 ...(省略)... if 条件2: 满足条件2 做的事情1 满足条件2 做的事情2 ...(省略)... 说明 外层的if判断，也可以是if-else 内层的if判断，也可以是if-else 根据实际开发的情况，进行选择 3.2、嵌套应用demo chePiao = 1 # 用1代表有车票，0代表没有车票 daoLenght = 9 # 刀子的长度，单位为cm if chePiao == 1: print(&quot;有车票，可以进站&quot;) if daoLenght &lt; 10: print(&quot;通过安检&quot;) print(&quot;终于可以坐着回家了，美滋滋~~~&quot;) else: print(&quot;没有通过安检&quot;) print(&quot;刀子的长度超过规定，等待警察处理...&quot;) else: print(&quot;没有车票，不能进站&quot;) print(&quot;不要方，真是一票难求啊~~~~(&gt;_&lt;)~~~~&quot;) 结果1：chePiao = 1;daoLenght = 9 有车票，可以进站 通过安检 终于可以回家了，美滋滋~~~ 结果2：chePiao = 1;daoLenght = 20 有车票，可以进站 没有通过安检 刀子的长度超过规定，等待警察处理... 结果3：chePiao = 0;daoLenght = 9 没有车票，不能进站 一票难求啊~~~~(&gt;_&lt;)~~~~ 结果4：chePiao = 0;daoLenght = 20 没有车票，不能进站 一票难求啊~~~~(&gt;_&lt;)~~~~ 想一想:为什么结果3和结果4相同？？？ 3.3 、练一练 情节描述：上公交车，并且可以有座位坐下 要求：输入公交卡当前的余额，只要超过2元，就可以上公交车；如果空座位的数量大于0，就可以坐下 4、猜拳游戏 应用，根据if语句相关知识，完善猜拳游戏 优化参考代码 优化以下代码，解决只能玩一次的问题 import random player = input(&#39;请输入：剪刀(0) 石头(1) 布(2):&#39;) player = int(player) computer = random.randint(0,2) # 用来进行测试 # 感谢关注A2Data #print(&#39;player=%d,computer=%d&#39;,(player,computer)) if ((player == 0) and (computer == 2)) or ((player ==1) and (computer == 0)) or ((player == 2) and (computer == 1)): print(&#39;获胜，哈哈，你太厉害了&#39;) elif player == computer: print(&#39;平局，要不再来一局&#39;) else: print(&#39;输了，不要走，洗洗手接着来，决战到天亮&#39;) 5、循环语句 生活中的循环应用场景： 跑道、风扇、空调左右上下摆风、地铁日常运行等 开发中的循环场景。 某天，你惹你女朋友生气了， 需要跟她诚恳地道歉。 print(&quot;亲爱的，我错了&quot;) print(&quot;亲爱的，我错了&quot;) print(&quot;亲爱的，我错了&quot;) ...(还有99997遍)... 使用循环语句呢？ 一句话搞定 i = 0 while i&lt;10000: print(&quot;亲爱的，我错了&quot;) i+=1 # i+=1 同等于 i= i+1 使用场景： 一般情况下，需要多次重复执行的代码，都可以用循环的方式来完成 循环不是必须要使用的，但是为了提高代码的重复使用率，所以有经验的开发者都会采用循环 6、while循环格式 while 条件: 条件满足时，做的事情1 条件满足时，做的事情2 条件满足时，做的事情3 ...(省略)... demo i = 0 while i&lt;5: print(&quot;当前是第%d次执行循环&quot;%(i+1)) print(&quot;i=%d&quot;%i) i+=1 结果 当前是第1次执行循环 i=0 当前是第2次执行循环 i=1 当前是第3次执行循环 i=2 当前是第4次执行循环 i=3 当前是第5次执行循环 i=4 7、while循环应用7.1、计算1~100累积和 注意：包含 1 和 100 # A2Data提供参考代码 i = 1 sum = 0 while i&lt;=100: sum = sum + i i += 1 print(&quot;1~100的累积和为:%d&quot;%sum) 7.2 、计算1~100偶数累积和 注意： 同样包含1 和 100 # 欢迎关注A2Data 转发在看求支持哦 i = 1 sum = 0 while i&lt;=100: if i%2 == 0: sum = sum + i i+=1 print(&quot;1~100的累积和为:%d&quot;%sum) 8、break和continue8.1、break8.1.1、for循环 for循环场景下的使用案例。 具体差别，自己动手输出看。 正常for循环 name = &#39;a2data&#39; for x in name: print(&#39;----&#39;) print(x) 带有break name = &#39;a2data&#39; for x in name: print(&#39;----&#39;) if x == &#39;d&#39;: break print(x) 8.1.2、while循环 普通循环如下 i = 0 while i&lt;10: i = i+1 print(&#39;----&#39;) print(i) 带有‘break’循环 i = 0 while i&lt;10: i = i+1 print(&#39;----&#39;) if i==5: break print(i) break的作用：用来结束整个循环 8.2、continue8.2.1、for循环name = &#39;a2data&#39; for x in name: print(&#39;----&#39;) if x == &#39;d&#39;: continue print(x) 8.2.2、while循环i = 0 while i&lt;10: i = i+1 print(&#39;----&#39;) if i==5: continue print(i) 总结: continue的作用：用来结束本次循环，紧接着执行下一次的循环 8.2.3、注意点 break/continue只能用在循环中，除此以外不能单独使用 break/continue在嵌套循环中，只对最近的一层循环起作用 9、while循环嵌套9.1while嵌套格式 while 条件1: 条件1满足时，做的事情1 条件1满足时，做的事情2 条件1满足时，做的事情3 ...(省略)... while 条件2: 条件2满足时，做的事情1 条件2满足时，做的事情2 条件2满足时，做的事情3 ...(省略)... 9.2、练习打印如下图形 * * * * * * * * * * * * * * * 参考代码 i = 1 while i&lt;=5: j = 1 while j&lt;=i: print(&quot;* &quot;,end=&#39;&#39;) j+=1 print(&quot;\\n&quot;) i+=1 9.3、打印：九九乘法表 10、for循环 掌握 for 循环的语法格式 掌握 for-else 的执行过程 像while循环一样，for可以完成循环的功能。 在Python中 for循环可以遍历任何序列的项目， 如一个列表或者一个字符串等。 请跟着操作如下demo！ demo0 name = &#39;a2data&#39; for x in name: print(x) demo1 name = &#39;hello1&#39; # 皮一下很开心 for x in name: print(x) if x==&#39;l&#39;: break #退出for循环 else: print(&quot;==for循环过程中，如果没有break则执行==&quot;) demo2 name = &#39;hello&#39; for x in name: print(x) #if x==&#39;l&#39;: # break #退出for循环 else: print(&quot;==for循环过程中，如果没有break则执行==&quot;) 11、总结与练习 11.1、必做题：使用if，编写程序，实现以下功能 从键盘获取用户名、密码 如果用户名和密码都正确（预先设定一个用户名和密码），那么就显示“欢迎进入xxx的世界”，否则提示密码或者用户名错误 使用while，完成以下图形的输出 * * * * * * * * * * * * * * * * * * * * * * * * * 11.2、选做题：根据以下信息提示，计算出每月乘坐地铁支出的总费用 提示信息（票价）： 地铁6公里(含)内3元，公交车10公里(含)内2元，使用市政交通一卡通刷卡乘公交车普通卡5折，学生卡2.5折。 一、城市公共电汽车价格调整为：10公里(含)内2元，10公里以上部分，每增加1元可乘坐5公里。使用市政交通一卡通刷卡乘坐城市公共电汽车，市域内路段给予普通卡5折，学生卡2.5折优惠;市域外路段维持现行折扣优惠不变。享受公交政策的郊区客运价格，由各区、县政府按照城市公共电汽车价格制定。 二、轨道交通价格调整为：6公里(含)内3元;6公里至12公里(含)4元;12公里至22公里(含)5元;22公里至32公里(含)6元;32公里以上部分，每增加1元可乘坐20公里。使用市政交通一卡通刷卡乘坐轨道交通，每自然月内每张卡支出累计满100元以后的乘次，价格给予8折优惠;满150元以后的乘次，价格给予5折优惠;支出累计达到400元以后的乘次，不再享受打折优惠。 要求 假设每个月，你都需要上20天班，每次上班需要来回1次，即每天需要乘坐2次同样路线的地铁；每月月初第一次刷公交卡时，扣款5元；编写程序，请计算出你每月乘坐地铁需要的总费用","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python速成","slug":"Python/Python速成","permalink":"http://www.a2data.cn/categories/Python/Python%E9%80%9F%E6%88%90/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"Python第一天作业答案","slug":"Python/Python速成/Python第一天作业答案","date":"2019-12-08T13:04:54.000Z","updated":"2020-09-11T08:01:01.045Z","comments":true,"path":"posts/5010.html","link":"","permalink":"http://www.a2data.cn/posts/5010.html","excerpt":"有东西被加密了, 请输入密码查看.","text":"您好, 这里需要密码.如若不知,请联系小编。3a0b0ebb43c4620dd0164696d76712adda08d924b0619ffca817202e677196d0457eac00861ee754233ca19bb41dadb3eaac2ccbdb2cafeca743a5ea8aa4216f39cf117817137b6781dd72300c7102779da7a4f7c1b37b023a99516a78124280838929c8c7a66fc61426a8263e7d3b59bc50cbcf967d25d5638c014cf437db66f50dd427efc35410e5d24606a045bb977b98be157f2430ab9c5437cddd44ff9116cf71560b7df9c4617959db03165b1d969487a9eb3348b76a1194b9effd9b9ff5a3a6cde78a0512c946463119cc407de7accca511f16ff0f8c09b4b35461126ec7b335fc04e51e6e5512b26b319d92927790557954073f8c3b092365f5180ff0545c87a62c6d35965f239363aa8fcc0df0c92c816e0d2793303b6f3339772130b30c2a79808361d06a26952cbb6825e98d7ff72c0758e84f2dd7fe32fa5e087a1b90126f7d37ce25430773edbcb693cb5dd87933f230ac9dfb4d502db9d544802f7bf092f11f5531537e1639275bc58fdf0ba4462ef673573caa9f7ed715941c550aafadce54407e94a2e054b1d605ded646d231cff331a51a8a6029d9c1972181ae0659b0b77f0e9ddae813fa4812b6b91b407beeb537324c20197616ea4043cf4eaa92406f1d086b85748b77e705628bcda690d9c4811ebc38e63902eabb2f50de36c0a3689273d5b679b6343abdfc9241c7e6f2619adfc13b22723d3f1d0cf40a91a358d2f0544fac19b9f5d286fa232d6abc4920947b049dbeebc7729e392651197a2ac8eda9d85a134e4044482e09dd822986fdf7ee477550b779ea87f5e1b14d842d128e6dbf1e426f8af63c0c19220a25369c0e0c26d2807c23bfa41a64829601f9aa3a21973dd8439b0a76cc3d28073deb221fa4d25bddf734631edc455ac10baccfbeb6cbb0febea8449a7678d508f0db96c024bbbd059525e15f20b81d2980b01009e70415e98821bf4a7a561c1bf4380488e5bfebc8ec7e04c591650ed87742550724687ba070b650dd5082bcaeb5b3f8e9f55d1ecc3769e42965a428c35c2d0a07e85adac205bb14dd33df421630cc66a1cb82e82b7550bfa9c5994fb52ce23ee590e2c82b92cb947d9d6229c90f39210e10737c28542b5d2d9754dd05910d8998fe8955e1d4d5fb4ac93d5d257022b5cfcebb44999ccbc21904d00084065687f7356204ebf76f2513881dc157942ae4f71f855b6fff355a2454dd429d39f3ff980f009b108d36cf80403f6fb52d8507fbf88348ae3f53ce7de608a3f7d5bd4c955c24eb537d770659e39b5d5abc9417b7585e5e48ca954ef13bca83de97bad380794bd6af5a619573a92bd73d902ea7bf8039cff000a84c1fb40e9a7ee7970e5beb5257e075061e56e51191596672ca497ba655f821969321c264841708e6e6e79316852f14a6371d479ad527842b9d6f8c79b35026ea99cb4b54fc3f45c812e8d13f3c4c3ad90a7198e67a1499b2dbfe302b297560f9d0a91b48bda0b88132361c2a6ddaaffbce6da321ffaae351beaf75c3dca01c6fc14776f57f56e789dae999ec203b56fccfc03457d5446203eb37cac3c7fbd10ca5f14cd8f8897f7bb31b0f22088a65d9822dc7ae140ae1e22dee3ad8a47e92d66f885f0e73811dd3ce98251f6f3b618627f58bdfbc50676f301b7d94832769febd1b5e3a39b7e4fef4518d0e4f498c97e8116ded4805636355475c115a93fd5c2bd54d6c519dd6e1b20f2aa1a9d1d44c7b86e48c07c8c7904611eb730c99f41d670ec1b057e3d5e620049e7764f25c961448212b9e03e41f4e2f84308b8ef75bb6712e86ffa30e5f557bb963178931e7f4fbfca1c7b4010fc5234472c7fbbc93fd9d6a330b021ffab2e3a0ac2039ae5f22ea9f3dc37cd782b49a2184593dcdcdbf4778a7241548495cbac811afe6ec5dd4ac4e12424aaa1b850757c250ef1fbe3a2c565674e1b95715b4e97670dd393004ca3a25e52fa4904aaeb2d3ef9718b5a6b1918c54fc683985c440bde9f00279671938a4b8bafd8baffdd54137d84d8e2ac819bab1132d6ac80a75d947383a26396defd30d192895553be49ca07342f93cb6b4ce0afe34cf4da952177175ea1bcd1116e9128caee900cd26bca7c17f38dd835c1b95e222438c829a43fe4b11a568c7cc000fc690c225adbaf3a22a0053443aa1e8ffd146f95f541390b57b7b3061921a791bd385ea9f7d157ec7ca37326122e7beca3cd291a2b9f8aeed442bf3a977429d9366fd7a7c22a97d3785058eb4b4f6ad77e6dc0e70585ef5bd163425893f1fced3940684c99999640f9576043d9f8bf5653291b90c849d661744874b4d50d33be4066a3a7fe86591d548512fd4b84792a9a6301850aa09e9ffff9a965472c9a461ec882de5985a7be6f8180f0b262b2d4cb22ff8f14e4c7af93e4562d00aa7e94a4e7f31a8e242abbc2305bb0fae4115f92bf3b4b8a92841f3198dbf746d46d6550403978e1d82f8435608322d24f736f11b166b84e7d2d2f90ea13c891ab7b8ccff46ace1a6fb5c1ae564295c51b9dd92782a1cd2d948bb6838d34314990c1fd09a053cfde2ab8a7de5a941d5ad336e2c0fcf12352bf2b711b869f68837702180b8246c83998da27c193b4c4dc9731b92ecd8866001b02a87dfb84fa338a4283975dce49c1e8cd0880faf4dd078572d3db2c88b8ea6bc73b228fc8f7aaa3ebcd4cee80f3769b0d9c90557dcd389d0247b9e3ad1a6441aaaf91e1c85af14f08838ca7762a21acf1b4ea631c3789b864ea78f4bbe4feaaeec493434a430fbc2fe9a22489ecf6a7bb0df9007cc0eb991b9e9264a27de8b8c244bd9b1b87ce6d53fd1ebe93137a34b6acca7608ae46c6d55ba2a9ff1a2df95f9a68b3e13ba3e8e49b1f2005c2f52781da84821a70fbc85af8b0ae26d3e4adae58844ae6ff36adf47edc5c3d7763312467b10fedf23e74f5721337840b964994d0a78efc4ba711bda7abfe4d7e2a97158b51eb883190efd8931527d98564e620d6fea6acbb2e48afb7ae29c38854d2cfb4bd04f185da29ffcc0d92068b122fcc99eb5f8aa46a2e8f71b2604b1c4edff38bcbc8ace2f7ddf66249c2438d8fdcc1940674ad6969a14e6654990b11e55abb49273ab9d484c517b3b793b46c7d64f8969b9d8338af91b2dc87387f262156a04f72cd57a170d72560bdb9b6667f6b793156f5805a771686a993dcd03a27472eb3fe3ea8e30f16cb0a9afe1678f9b140bc7052e8250bfd8740a3a3966da4b23f5d39eaece88b0129bfb3dc2030a10f00f259e3c98fb2176ad73972c70158ea43725b757cf5bcbc1de79ca6bd744d21ef64b3e04fe9e48f8b03c33291677f3955cfc5ad5861402f504b61c36fc375406c09809a02f06aa3768a6c23972ea9fb915b7e74d35245597024c2bb92ae585b40a003292ebb3cd08edf7ff838d119fec4455e499e49d589c30821a8702f5888782a43e5037b43ed0c44e78c31082aa506c3bd56594131a7e95439b5f33856ba00a218acab049a8f4fe195844375b395f4664f4622ae1982693ccf7d2b95316efed26e894bd6955740e3077bb4d20a21c227c0c3ae332950a9f403e6c35782cbc68f84297ab5e1aece591a7b80bed0de3f7e0c9367d0193a5f040b5d4c7b52a5f5647e901b81f5754c433cafda7433da37bfd328370a0a4e26f3e34b9823cf7e9f18247b4c31c6db951640a39a4fb51cc5b31b928dd23183730ad491430395b943d78c042e40e0e001a610b8043ef8ed2468f5da4501fce53e0164e74035d17522aa10a61f8544971edb05012f37814bdeb933fbaf32a493612786a7bf06582c4967579509b2341e63a68d742fa062cff5851fe7a4996f3c62ec71da3ed4647b82e8bb14d4edf45d976c3f67432f6e8da66c8ba9450e15951095dd82d16fd9478bd5c12597591a5931de1aa9687b21f803f93f365144096369b8aa7ee94e9d34492e2074f5ccdda13caf810853e644869b4c87d75cf92dff6ba229a224e2a2249fe5c58bed960e715ccc0c1af2e8489d806a00365ed10273fdc6047774d6f03733b6c75836e7f5fdae08f5e1c638841a71499e02b2d6d889bb4a81c5e6009754519e3b55824094dd8791a4059f0f28825c398deec930d03186aa43176829b10760bda3ae3800b5feb8285b1ce09b8eb6d35488f5ef433a9deb2b6f72e2639c2c8f76b93fbb20eb6ddb85eab4f6bc38e6f31849582cfeb55a81b56a691056306da556834a992bed655fbf86e46b59f10419b001ac03c5db3f7b159b57b5f2053a5d8e94ec63dcdcb170230ba32d2bd7840a4bc893b30764e2a23791dd09e0b5777cc256ec021574d2438739da39f7ef64ebf7904066c1a0a33cb2213893a928163785aaefb63af30ca3deb149cd9ec2bea19f0bc02d004174f0fe2ce2335fec68457396e7934765ead14f1d84959a8574227d20f657aa0b81251017a7164a62a166a65e95df4821d9bf9213c9dc4310be1ce2b811053f94cc3019e7ed8064570e705c96d21e22e17dd93b295756fe36f26841cf6697944f7a33eed7e246aaadc07f39c1e870f343d81f679160cedf461e8a3a045586544ce91d7163f83c1703841eb1173853748ab96a3878b53c9e13dd085ae720fc469b976ef85322ef073610a5f6f65ebad43ff86758267b72bd22576295973c6c59535efa472d60126b834378ec1c09dd256231eca4367c4fec500abfd903042d573d22b1a50eddee423b42f445b31c3c054db5b5a0e001ca022e96f401317ea4584ac5cd8a65831648f6595a0e6f1b5a62ddb8a183e8eb0dd3a22932a028777639e67c640bd909cd1a89b62e3609e5125f26a979a5e217db2e5be9d1d7de0ae4eee5eaa5b29ae8e0b9259d9882392deb0f1e9e8cd918c929160ccfdae800b0e23410f8a7dd8707ea033f3306f3dbb3616b0e2679b6f11b641e4ccd50e356f35515a4ee096ac8550c046efbb4afa82942685c7627c00f1bb1897539adf952690fd1078044a0e4f7bca0924621d07555b70f62c1dc168ef84c7a455577da54a57c912b0088d26aa732f496ddf781d3155fd900a39492e2212371adfbdbdc089eba140402fd49f302749557a61723155c7226afff7b00ce4e2cf4e639a831e162e7430fc08b611efea477fe5f3c4a5732ab4026b3f7841667f1f0297c692bbb572c7a36425278bd6e1b1f26f006225ae4bb1b40c2269fe662d671305601c6da74542e496a71df569e78b71af77a3ce3049474e19d2c1e383732abfcf25ebfc53b6357089d3f89b0da1ef70121b8c4087e65f3cf3b8afd90b2bc78b1fd1ab8b911ab6b68f7610d2e9378eab42a67b8ff63fa34451088dca9612c5c0d20b0e35193db957152ac950bf5792a7e9e0a21421bbeadbaec84f4449d7298d86354dfba8bbda7061df9227ce90a4679b4bf83ecb44f4d65a828b7507ebc75546f9f32b37c5a66a3e5eb6a33a13436b775b9aa9e472bfc166ea40aaa658f43b06d97e29b7aae51bb61a574780d5689e477967c75bbc0917c714e2370d599fbda65da24bb73125b006d1c9483d9087016371a0a43dba31f163fbf04a370f8ce5ad9f885af45ceadbdf671c6cdd73e59e53bb6a2bcdb5b055fa94e9bdcf55f732e3dcbf9047ff9175f3f3a4541c2821b7f4e2ae63a8b19f8ccb441276859560bf4c5690c2dd569b45c5678ead6b767b718e413f7ffd79bc1395c9e9d74b041571c6ab454d5f063d192735f9dc336e8b6d05a4c6510eaf012c183e26aa1df3997e5902feb65da7b23ad5d0158b31286f9fcf1c0479228fe25bfce2ebb884af2150eb1a8da51f2b73bb87db112b9c1e6f77d2734687184ba9590289f324caca7d8396467f40e67647f15afe468665d1eca44838eed8475085d101ee2788da9b6c9327df961eaf0c8f0d373edb32c658c8ba6c8c71e8ac1b3e510465c908d0cd61398a4ff39b79ab3f77db92a8e1056849a65c84b4fc3abce30a7f6363880fae3c35ac6daa4cd74dfc93bbb149eb4c5654f90c3177049384482965750a19e37e013f078793e58084c0ee6a60c1705278f24136f8d825a4a511f816b3cb072afe8a84324ca5385e928794a286c58d78319beba9768f7ef8dbe7d1ab1cb53072edb281611a9705d8798060c7d0e99691e14c531d7ee7835f49160f26c7d3ec5d5450e6ab42c4bd009c84a2fce1e03bb898f7d269d5a3e5f9970d24ac41c4d1d0d9f9d347469dd802e519cd8de36192a1c193dc4209e9fb16eb73a113d4a29b45b9b29bdaef5e38a14d467bd9ccc5a54f4028bb19b23d589e7028e0a0d0f7dfafb18578dc797202b131ac8351ae9e40c6652b74eeb75f9f9e24ce5f26c5bea09462ec1e7895607b7b0382e9a295654585169bd7c038d21d5f3d6d162d7b5a7217fbf254f414e2295ef433822c4e8a47a8cf9ec07352d7cebd50ae891fc2522a81ae327afa6819edcb9b26116a892a9e36acfc9db9848f04b2bef67c1e2afc7d2eb39f22145026b70840d97491e9564fbacf4d173965e512f65365e448384253a5a3bf9522b92dcd6a8b76f44f659ec46190807858180ecae24a45a3fcecb02ce3731758bb95640617b24e5effbee0167e08c48f458fe054e65b81501b347373b26de336effc164e854155998d98fa178f8ff7546c5f1b911d3c8534f4787b852050df602c66decfbe1c139e7eccc768daa7aa776988941114a83c3a4e31d02ce7259d1944de4dbabce5f3894e7a00ab2edc6228aec575911cd0d2c05d25115554d6bc61af89327684cb4c86e20c3e750d00956111ef02a03730ea5ebe22328fac36c0c85dd5bf98169719aae0bb1114367cbffd3c6bbcded0176df094339a278244c7a252b717c6366307bd2be4549dc2d9bad70c45be3d63ee7b4628c628211e0ba7bfa3bc56919c46175ae497c8ad19c0bc04cb78f0d84abb5f011c191b683fcbea01371b6c767e36be6250e23b172bf013d3c18d1ffacbe77647de5f5b7c48facb35a79e2d631270258d3bcfc06bb384a9fc9101acc47df5a21a25a2c119f5abb6f6f937d7428e238ad3ce52035db941921f1038f25d45ca0d070f8f25360a7ae81c2e12291314a732ed4f609edc23feb0d00efaa0bd2f27f9a1ea8ba5201cfc336a9fa2676cda45a0e5a4150ee9b907ae39c641cd11b9dab206809b58aacab81c04a58d31286600a625b8e0d2791450992d2d43096235db565a3aa7e43c29e5c3f96bb7d5e3c77d470a4845d9e7bc73765c789f29560b367efe39e674632a9a0269596af88487a2e58e918af62d8557321b9150144ef2b1733219d629e7bf170f7aa970af1ffa62b1278c32b9b5c295799bf6a1217ff0f20b4f00ce7dccc1ffe2b2b339af3b178260739e4987ddfb9909fe1fa65275bb4f44ed5dc49805437ceada5baa93e61bd7cff8ec76c5b073064fb78636c93edea5bab39b13416e3a27a989e686a01be78c3f15e835f78c8ed76beefe8c3bf6bc5911945222b4a7c00743ff873e8329328fdd41e0db14c22d3c4ed02b2cca01317a4bef30a1f4b4f654bf16c382c2c1a6c1474be7a7df4f98ebf471088eff112efd16e3e27559703fd0063bdc14b9640d6dd20479e9e8358bbeaef3d3e4315d0042cfe272045d1fb3918005e8ce56b15c641208f62a2816d9faa8fe4f47cc776892dadedd2fb5a93e840013c132fab5cf3720cb2e3265fe1d90de63096b96c8cd617defa79352792884ba379b746c36eeeb859d25384baddd4fd80e5542fbefdfcec5769b9","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python速成","slug":"Python/Python速成","permalink":"http://www.a2data.cn/categories/Python/Python%E9%80%9F%E6%88%90/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"},{"name":"Python习题","slug":"Python习题","permalink":"http://www.a2data.cn/tags/Python%E4%B9%A0%E9%A2%98/"}]},{"title":"1.Python基础知识","slug":"Python/Python速成/1、Python基础知识","date":"2019-12-05T14:43:54.000Z","updated":"2020-09-11T08:14:26.828Z","comments":true,"path":"posts/59977.html","link":"","permalink":"http://www.a2data.cn/posts/59977.html","excerpt":"Python的基础语法","text":"Python的基础语法 Python 为什么那么多培训机构？那么多的程序员呢？ 很简单啊。 因为 门槛低啊。 ==. 不信？来动手试试吧。 1、操作系统(科普一下)目标 了解操作系统及应用 操作系统接口示意图 那么没有安装操作系统的计算机, 那就是裸机 2、Python优缺点 时势造英雄 人生苦短，我用python Python可以做什么呢？ 3、Python的第一个程序 上篇已经说过一些，但是竟然有人问我如何创建！！ 此处以 jupyter 为例吧。 果真是炒鸡小白。 1、运行服务，进入web页面 2、进入你的工作目录 3、成功输出你的第一行代码 4、注释4.1、注释引入1、未使用注释 2、使用注释 3、注释的作用 通过用自己熟悉的语言，在程序中对某些代码进行标注说明，这就是注释的作用，能够大大增强程序的可读性 4.2、注释分类1、&lt;单行注释&gt; # 我是注释，可以在里写一些功能说明之类的哦 print(&#39;hello world&#39;) 2、&lt;多行注释&gt; 3、&lt;注意&gt; 在python的语法规范中推荐使用的方式： （早期版本，不写的话，``print(‘努力赚钱的小风’) `就会报错哦） # -*- coding:utf-8 -*- 5、变量以及类型目标 掌握变量的定义和修改 了解变量有哪些类型和查看方式 5.1、&lt;变量的定义&gt; A：简单来讲就是，在程序中，我们需要对2个数据进行求和，那么该怎么做呢？ B：类比现实生活中，比如你去买早餐，一个鸡蛋，一个茄子包子等，你需要算你共花了多少钱。 所以，对于Python而言，存储一个数据，就需要一个变量 程序就是用来处理数据，而变量就是用来存储数据的。 *思考：我们应该让变量占用多大空间，保存什么样的数据？* 5.2、&lt;变量的类型&gt;生活中类型的例子(拿车来举例吧)： 挖掘机、轿车、跑车、公交车 （类型，大小，价格都不同） 程序中： 充分利用空间，有效管理内存 那么问题来了，如何知道一个变量的类型呢？ Python中，只要定义了变量，且它有数据，那么它的类型就确定了。不用去说明它的类型，系统会自动辨别。 type(变量名称)—- 查看变量类型 6、标示符和关键字6.1、标示符 开发人员在程序中自定义的一些符号和名称 标示符是自己定义的,如变量名 、函数名等 6.2、标示符的规则 标示符由字母、下划线和数字组成，且数字不能开头 找一找:（如下，哪些是对的，哪些是错的？） fromNo12 from#12 my_Boolean my-Boolean Obj2 2ndObj myInt test1 Mike2jack My_tExt _test test!32 haha(da)tt int jack_rose jack&amp;rose GUI G.U.I a2data python中的标识符是区分大小写的 6.3、命名规则 见名知意 驼峰命名 下划线链接 6.4、关键字 python一些具有特殊功能的标示符，这就是所谓的关键字 关键字，是python已经使用的了，所以不允许开发者自己定义和关键字相同的名字的标示符 查看关键字 7、输出7.1、普通输出# 打印提示 print(&quot;hello world&quot;) 7.1、格式化输出7.1.1、格式化的目的print(&#39;小风今年10岁&#39;) print(&#39;小风今年18岁&#39;) print(&#39;小风今年20岁&#39;) # 思考，年龄多次使用，如何简化 -- 字符串可视化 7.1.2、格式化 7.1.3、换行输出#在输出的时候，如果有\\n那么，此时\\n后的内容会在另外一行显示 print(&quot;1234567890-------&quot;) # 会在一行显示 print(&quot;1234567890\\n-------&quot;) # 一行显示1234567890，另外一行显示------- 7.1.4、Python2-3输出区别 Python3 使用 print 必须要以小括号包裹打印内容，比如 print(&#39;hi&#39;) Python2 既可以使用带小括号的方式，也可以使用一个空格来分隔打印内容，比如 print &#39;hi&#39; 现在都是以python3为主 7.1.5、动手试试吧 编码完成一下名片的显示： ================================== 姓名: 努力赚钱的小风 QQ:xxxxxxx 手机号:185xxxxxx 公司地址:北京市xxxx ================================== #思考，如何格式化输出？换行？ 8、输入 这里简单说一下，Python2中的输入是 raw_input()函数 而在Python3中只有input() 9、运算符 算术运算符 运算优先级 赋值运算符 复合赋值运算符 9.1、算术运算符下面以a=10 ,b=20为例进行计算 运算符 描述 实例 + 加 两个对象相加 a + b 输出结果 30 - 减 得到负数或是一个数减去另一个数 a - b 输出结果 -10 * 乘 两个数相乘或是返回一个被重复若干次的字符串 a * b 输出结果 200 / 除 x除以y b / a 输出结果 2 % 取余 返回除法的余数 b % a 输出结果 0 ** 幂 返回x的y次幂 a**b 为10的20次方， 输出结果 100000000000000000000 // 取整除 返回商的整数部分 9//2 输出结果 4 , 9.0//2.0 输出结果 4.0 &gt;&gt;&gt; 9 / 2.0 4.5 &gt;&gt;&gt; 9 // 2.0 4.0 &gt;&gt;&gt; 1 + 2*3 7 &gt;&gt;&gt; (1+2) * 3 9 9.2、赋值运算符 运算符 描述 实例 = 赋值运算符 把=号右边的结果给左边的变量 num=1+2*3 结果num的值为7 &gt;&gt;&gt; a, b = 1, 2 &gt;&gt;&gt; a 1 &gt;&gt;&gt; b 2 9.3、复合赋值运算符 运算符 描述 实例 += 加法赋值运算符 c += a 等效于 c = c + a -= 减法赋值运算符 c -= a 等效于 c = c - a *= 乘法赋值运算符 c *= a 等效于 c = c * a /= 除法赋值运算符 c /= a 等效于 c = c / a %= 取模赋值运算符 c %= a 等效于 c = c % a **= 幂赋值运算符 c ** = a 等效于 c = c ** a //= 取整除赋值运算符 c //= a 等效于 c = c // a 10、数据类型转化 了解类型转换的作用 掌握常用的类型转换 函数 说明 int(x [,base ]) 将x转换为一个整数 long(x [,base ]) 将x转换为一个长整数 float(x ) 将x转换到一个浮点数 complex(real [,imag ]) 创建一个复数 str(x ) 将对象 x 转换为字符串 repr(x ) 将对象 x 转换为表达式字符串 eval(str ) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s ) 将序列 s 转换为一个元组 list(s ) 将序列 s 转换为一个列表 chr(x ) 将一个整数转换为一个字符 unichr(x ) 将一个整数转换为Unicode字符 ord(x ) 将一个字符转换为它的整数值 hex(x ) 将一个整数转换为一个十六进制字符串 oct(x ) 将一个整数转换为一个八进制字符串 举例 a = &#39;100&#39; # 此时a的类型是一个字符串，里面存放了100这3个字符 b = int(a) # 此时b的类型是整型，里面存放的是数字100 print(&quot;a=%d&quot;%b) 11、判断语句介绍 直接拿一个例子来说明吧。 &lt;重要日期判断案例&gt; if 今天是周六或者周日: 约妹子 if 今天是情人节: 买玫瑰 if 今天发工资: 先还信用卡的钱 if 有剩余: 又可以happy了，O(∩_∩)O哈哈~ else: 噢，no。。。还的等30天 小总结： 如果某些条件满足，才能做某件事情，而不满足时不允许做，这就是所谓的判断 不仅生活中有，在软件开发中“判断”功能也经常会用到 12、if语句 掌握 if 语句的语法格式 12.1、if判断语句介绍 if语句是用来进行判断的，其使用格式如下： if 要判断的条件: 条件成立时，要做的事情 demo1: age = 30 print &quot;------if判断开始------&quot; if age&gt;=18: print &quot;我已经成年了&quot; print &quot;------if判断结束------&quot; 运行结果: ------if判断开始------ 我已经成年了 ------if判断结束------ demo2: age = 16 print &quot;------if判断开始------&quot; if age&gt;=18: print &quot;我已经成年了&quot; print &quot;------if判断结束------&quot; 运行结果: ------if判断开始------ ------if判断结束------ 小总结： 以上2个demo仅仅是age变量的值不一样，结果却不同；能够看得出if判断语句的作用：就是当满足一定条件时才会执行那块代码，否则就不执行那块代码 注意： 代码的缩进为一个tab键，或者4个空格 12.2、练一练要求：从键盘获取自己的年龄，判断是否大于或者等于18岁，如果满足就输出“哥，已成年，网吧可以去了” 使用input从键盘中获取数据，并且存入到一个变量中 使用if语句，来判断 age&gt;=18是否成立 12.3、想一想 判断age大于或者等于18岁，使用的是 &gt;=，还有哪些呢？ 13、比较、关系运算符13.1、比较(即关系)运算符python中的比较运算符如下表 运算符 描述 示例 == 检查两个操作数的值是否相等，如果是则条件变为真。 如a=3,b=3则（a == b) 为 true. != 检查两个操作数的值是否相等，如果值不相等，则条件变为真。 如a=1,b=3则(a != b) 为 true. &lt;&gt; 检查两个操作数的值是否相等，如果值不相等，则条件变为真。 如a=1,b=3则(a &lt;&gt; b) 为 true。这个类似于 != 运算符 &gt; 检查左操作数的值是否大于右操作数的值，如果是，则条件成立。 如a=7,b=3则(a &gt; b) 为 true. &lt; 检查左操作数的值是否小于右操作数的值，如果是，则条件成立。 如a=7,b=3则(a &lt; b) 为 false. &gt;= 检查左操作数的值是否大于或等于右操作数的值，如果是，则条件成立。 如a=3,b=3则(a &gt;= b) 为 true. &lt;= 检查左操作数的值是否小于或等于右操作数的值，如果是，则条件成立。 如a=3,b=3则(a &lt;= b) 为 true. 13.2、 逻辑运算符 运算符 逻辑表达式 描述 实例 and x and y 布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 (a and b) 返回 20。 or x or y 布尔”或” - 如果 x 是 True，它返回 True，否则它返回 y 的计算值。 (a or b) 返回 10。 not not x 布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not(a and b) 返回 False 14、小风作业练习必做题 说出变量名字，可以由哪些字符组成 写出变量命名时的规则 说出什么是驼峰法（大驼峰、小驼峰） 编写程序，完成以下要求： 提示用户进行输入数据 获取用户的数据数据（需要获取2个） 对获取的两个数字进行求和运行，并输出相应的结果 编写程序，完成以下要求： 提示用户进行输入数据 获取用户的数据数据（需要获取2个） 对获取的两个数字进行减法运行，并输出相应的结果 编写程序，完成以下信息的显示: ================================== = 欢迎进入到身份认证系统V1.0 = 1. 登录 = 2. 退出 = 3. 认证 = 4. 修改密码 ================================== 编写程序，从键盘获取一个人的信息，然后按照下面格式显示 ================================== 姓名: A2Data QQ:xxxxxxx 手机号:185xxxxxx 公司地址:北京市xxxx ================================== 编写程序，从键盘获取用户名和密码，然后判断，如果正确就输出以下信息 亲爱的xxx，欢迎登陆 A2Data学习管理系统","categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python速成","slug":"Python/Python速成","permalink":"http://www.a2data.cn/categories/Python/Python%E9%80%9F%E6%88%90/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"}]},{"title":"运营工具箱","slug":"Tools/运营工具箱","date":"2019-11-28T00:32:29.000Z","updated":"2020-09-11T09:28:58.969Z","comments":true,"path":"posts/41382.html","link":"","permalink":"http://www.a2data.cn/posts/41382.html","excerpt":"掌握这些工具，你就是自媒体大咖","text":"掌握这些工具，你就是自媒体大咖 126 种运营人必备工具微场景编辑器 易企秀：http://www.eqxiu.com/main 易企微：http://www.e7wei.com/ 兔展：http://www.rabbitpre.com/ 麦片 BlueMP：http://www.bluemp.cn 初页：http://www.ichuye.cn/ MAKA: http://maka.im/ 翼码旺财：http://cp.wangcaio2o.com/ 24好玩：http://24haowan.com/ 微页：http://www.zhichiwangluo.com/ 点点客海报：http://www.dodoca.com/ 秀米秀制作：http://xiumi.us/ 易传单：http://echuandan.com/ Epub360 意派：http://www.epub360.com/ LiveApp 场景应用：http://www.liveapp.cn/ Vxplo ：http://www.vxplo.cn/ 最酷网：http://www.zuiku.com/ 起飞页：http://www.qifeiye.com/#bit_elmpz WIX: http://www.wix.com/ 有图：http://www.360youtu.cn/ 图片素材来源 千图网：http://www.58pic.com/ 优美图：http://www.topit.me/ 花瓣：http://huaban.com/ 图虫：https://tuchong.com/ 图片 114：http://www.tupian114.com/ Picjumbo： https://picjumbo.com/ Pexels： https://www.pexels.com/ Gifs Categories：http://giphy.com/categories SOOGIF 动图搜索：http://soogif.com/ 素材公社：http://www.tooopen.com/ 插画家园：http://www.13cg.com/ Pixabay 免费高清图片：https://pixabay.com/ Wallpaper：http://cn.forwallpaper.com/ 图片处理网站 trikingly 建站工具：https://www.strikingly.com canva 海报设计：https://www.canva.com 暴走漫画制作器：http://baozoumanhua.com tuyitu 动图制作：http://www.tuyitu.com tagul 在线文字云制作：https://tagul.com smallpdf pdf 转换网站：https://smallpdf.com/cn Gif 录制编辑工具：GifCam 图片批量处理工具：美图秀秀批处理 创客贴：https://www.chuangkit.com/dc.html Magic Mockups：http://magicmockups.com/mockup/2/ 行业资源合作 APP换量/采量/变现/异业合作/礼品卡券 http://www.niaogebiji.com/pc/index/appchange 各大媒体平台 微信公众平台： https://mp.weixin.qq.com 企鹅媒体平台： http://om.qq.com/userAuth/index 头条号： http://mp.toutiao.com/ 搜狐公众平台： http://mp.sohu.com 网易媒体号： http://dy.163.com/wemedia/login.html UC 订阅平台： http://mp.uc.cn 百家号： http://publish.baidu.com 数据查询网站 搜狗微信搜索： http://weixin.sogou.com/ 新榜：http://www.newrank.cn/ 站长工具：http://tool.chinaz.com 百度搜索风云榜：http://top.baidu.com 百度指数：http://index.baidu.com 微指数： http://data.weibo.com/index 微博数据中心： http://data.weibo.com/datacenter/recommendapp 行业数据来源 媒体微博排行榜：http://v6.bang.weibo.com/xmt 友盟：http://www.umeng.com/ 中国新闻地图：http://vis.360.cn/open/cnnews/ 中国票房榜：http://www.cbooo.cn/ 收视率排行：http://www.tvtv.hk/archives/category/tv 农业大数据云平台：http://www.dataagri.com/agriculture/gis.action 房价指数：http://data.eastmoney.com/cjsj/newhouse.html 中国统计局：http://data.stats.gov.cn/ 主要城市拥堵实时排名：http://report.amap.com/traffic/ 中国综合社会调查：http://www.chinagss.org/ P2P 网贷指数：http://www.p2p001.com/wdzs/wdzs_p2pline.html Alexa：http://www.alexa.com/ 易车汽车指数：http://index.bitauto.com/ 旅游预测：http://trends.baidu.com/tour/ 网盘搜索网站 盘多多：http://www.panduoduo.net 网盘屋：http://www.wangpanwu.com/ 呆木瓜：http://www.daimugua.com 西林街：http://www.xilinjie.com 胖次网盘搜索引擎： http://www.panc.cc 百度网盘分享之家： http://wowenda.com/ 网盘 007：http://wangpan007.com/ 去转盘网：http://www.quzhuanpan.com/ 鸵鸟搜索：http://www.tuoniao.me/ 社群管理工具 进群宝：http://www.jinqunbao.com/ 小U管家企业版：http://www.xiaouqyfw.com/ 行业社群助手：https://xzs.jinqunla.com/ 群鲸SCRM个人号管理：http://www.qunsir.com/#/ Wetools：https://www.wxb.com/wetool 图文排版编辑器 i 排版：http://www.ipaiban.com/ 新榜编辑器：http://edit.newrank.cn/ 秀米：http://xiumi.us/ 96 微信编辑器：http://bj.96weixin.com/ 96 微信标题表情： http://bj.96weixin.com/emoji/ 135 编辑器：http://www.135editor.com/ 小蚂蚁微信编辑器：http://www.xmyeditor.com/ 易点编辑器：http://wxedit.yead.net/ 易企微微信编辑器：http://www.e7wei.cn/ 91 微信编辑器：http://www.91join.com/edit/ 微信编辑器：http://www.wxbj.cn/ 微助点微信编辑器：http://www.videaba.com/ 懒人模板：http://bj.lanrenmb.com/ 果优微信编辑器：http://guoyoo.99vu.com/ 做最好用的微信编辑器：http://editor.fzn.cc/ 微信在线编辑：http://wx.bzrw.net/ 微兔兔编辑器：http://www.weitutu.com/ 有图微信编辑器：http://bj.360youtu.com/ 排版 365：http://paiban.lizhi.in/ 乐排：http://pb.ishangtong.com/ 秀多多：http://xiudodo.com/?m=graphic#/for/new 在线问卷调查 腾讯问卷调查：http://wj.qq.com/ 麦客：http://www.mikecrm.com/ ICTR：http://cn2.ictr.cn/ 问道网：http://www.askform.cn/ 问卷星：http://www.sojump.com/ 调查派：http://www.diaochapai.com/ 问卷网：http://www.wenjuan.com/ SurveyMonkey：https://zh.surveymonkey.com/ 每日运营资讯 运营派https://www.adquan.com/ Next新产品http://next.36kr.com/posts 新榜资讯https://www.newrank.cn/public/news.html 二维码生成器 草料二维码：http://cli.im 联图网：http://www.liantu.com 二维工坊：http://www.2weima.com wwei 创意二维码：http://www.wwei.cn 二维码解码器：http://jiema.wwei.cn/ 半色调二维码生成器：https://spacekid.me/halftone-qr-code-generator/ 其他实用工具 多媒体格式转换工具：格式工厂 微信文章视频地址采集工具：http://www.hengha.tv/caiji.html 第一字体转换器：http://www.diyiziti.com/List 上传图片找字体：http://www.qiuziti.com/ 广告买卖网：http://www.admaimai.com/ GIF 压缩/水印/裁剪/制作/视频转 GIF：http://www.piggif.com/tools/compress 在线文件转换器：http://cn.office-converter.com/ PDF 转 DOC：http://pdf2doc.com/zh/ VIP 视频在线解析：http://vip.ifkdy.com/ 装逼神器：http://deepba.com/","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/categories/Tools/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/tags/Tools/"}]},{"title":"打造稳定快速、高效免费图床","slug":"Tools/打造稳定快速、高效免费图床","date":"2019-11-26T13:41:06.000Z","updated":"2020-08-07T10:28:25.857Z","comments":true,"path":"posts/6059.html","link":"","permalink":"http://www.a2data.cn/posts/6059.html","excerpt":"超级图床，高速稳定","text":"超级图床，高速稳定 GitHub + jsDelivr + PicGo + Imagine 打造稳定快速、高效免费图床前言 为什么要使用图床呢？ 因为在不同平台发布同一篇文章的时候，最一个痛苦的点就是，图片存储问题，各个平台的文件存储方式各不相同，无法直接 Ctrl + C 的方式一键搞定，为了解决这个问题，使用 MarkDown + 图床 的方式进行文章的写作，将图片放到一个统一的地方，在文章中引入图片外链。所谓图床，就是将图片储存到第三方静态资源库中，其返回给你一个 URL 进行获取图片。MarkDown 支持使用 URL 的方式显示图片，我想这也是程序员为什么对其偏爱的原因之一。作为程序员，你会发现，现在很多论坛和社区都开始支持使用 MarkDown，如果你没使用图床的情况下，你分享同一篇文章，你要在不同的平台，各自重新编辑排版一遍和上传图片一次。有了图床，情况就不一样了，Ctrl+C 的方式就搞定了，根本不用再 Check 文章内容一遍。 图床的选择？ 微博图床：以前用的人比较多，从 2019 年 4 月开始开启了防盗链，凉凉 SM.MS：运营四年多了，也变得越来越慢了，到了晚上直接打不开图片，速度堪忧 其他小众图床：随时有挂掉的风险 Imgur 等国外图床：国内访问速度太慢，随时有被墙的风险 大厂储存服务：例如七牛云、又拍云、腾讯云COS、阿里云OSS等，操作繁琐，又是实名认证又是域名备案的，麻烦，而且还要花钱（有钱又不怕麻烦的当我没说） GitHub 图床：免费，但是国内访问速度慢（不过没关系，利用 jsDelivr 提供的免费的 CDN 加速 速度足够了） 使用流程 新建 GitHub 仓库 生成一个 Token 配置 PicGo 并使用 jsdelivr 作为 CDN 加速 使用 Imagine 进行图片压缩 上传图片到 PicGo 并使用图床 新建 GitHub 仓库 登录/注册 GitHub 新建一个仓库，填写好仓库名 仓库描述 将权限设置成 public 根据需求选择是否为仓库初始化一个 README.md 描述文件 新建 GitHub 仓库 生成一个 Token 点击用户头像 -&gt; 选择 Settings Settings 点击 Developer settings Developer settings 点击 Personal access tokens Personal access tokens 点击 Generate new token Generate new token 填写 Token 描述，勾选 repo，然后点击 Generate token 生成一个 Token 填写 Token 描述 获取 Token 密钥 注意这个 Token 只会显示一次，自己先保存下来，或者等后面配置好 PicGo 后再关闭此网页 获取 Token 密钥 配置 PicGo 并使用 jsdelivr 作为 CDN 加速前往下载 PicGo（点击下载），安装好后开始配置图床 设定仓库名：按照 用户名/图床仓库名 的格式填写 设定分支名：master 设定 Token：粘贴之前生成的 Token 指定存储路径：填写想要储存的路径，如 img/，这样就会在仓库下创建一个名为 img 的文件夹，图片将会储存在此文件夹中 设定自定义域名：它的的作用是，在图片上传后，PicGo 会按照自定义域名+上传的图片名的方式生成访问链接，放到粘贴板上，因为我们要使用 jsDelivr 加速访问，所以可以设置为https://cdn.jsdelivr.net/gh/用户名/图床仓库名 配置 PicGo Text Q：什么是 jsdelivr ? A：jsDelivr 为开发者提供免费公共 CDN 加速服务 使用 Imagine 进行图片压缩通常情况下，图片大小都是超过 200KB 的，所以网页加载的时候会特别慢，一般我们会对图片进行压缩，这里我推荐 Imagine（点击下载） 支持全平台。 使用 Imagine 进行图片压缩 Imagine 采用的是有损压缩，介意的可以忽略这一步 顺便推荐一个无损压缩的网站：https://tinypng.com/ 上传图片到 PicGo 并使用图床配置好 PicGo 后，我们就可以进行高效创作了，将压缩后的图片拖拽到上传区，将会自动上传并复制访问链接，将链接粘贴到博文中就行了，访问速度杠杠的 上传图片到 PicGo 并使用图床 此外 PicGo 还有相册功能，可以对已上传的图片进行删除，修改链接等快捷操作，PicGo 还可以生成不同格式的链接、支持批量上传、快捷键上传、自定义链接格式、上传前重命名等，更多功能自己去探索吧！","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/categories/Tools/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/tags/Tools/"}]},{"title":"如何构建知识体系","slug":"Tools/如何构建知识体系","date":"2019-11-22T17:09:07.000Z","updated":"2020-08-07T10:28:56.454Z","comments":true,"path":"posts/18572.html","link":"","permalink":"http://www.a2data.cn/posts/18572.html","excerpt":"成长是什么呢？","text":"成长是什么呢？ 成长就是孤独的把委屈和泪水拼命的咽下去不让别人知道。 只有在孤独中，才能够更好的意识到自己真正追求的是什么，才能不局限于当下的小事，放眼更远大的志向。 知识体系 是在(恰如其分、环环相扣的)提问和实践的基础上形成的概念和概念间联系的集合，知识点之间彼此形式多样的方式关联，形成了特定的结构。 知行概念 = 内涵 + 外延 + 联系（知 -&gt; 行） 外延的常用描述方式 “是什么而不是什么”，经验是用枚举外延以及枚举高价值联系的方式来对提升概念理解的精确度，即将内涵方式描述不显而易见的加入到备忘录。 理解 = 能够枚举更多概念的CASE以及概念间的联系，理解就是 识 -&gt; 记 -&gt; 忆（用场景+联系来唤醒，记的时候想着忆，写的时候想着读）。 学以致用的基础是理解概念间的高价值联系，而发挥力量的关键是显性表达。 我们可以借助“八大问”，来分析信息、观点、事件、经历等，从中整理出概念和联系。八大问是一个提问的框架，将针对信息、观点、事件、经历等的提问，分为“前、因、后、果、适、用、边、界”八类。 八大问可以分为两组，前因后果用于分析信息，适用边界用于整理信息。 前（前车之鉴）：为什么这件事对我重要？它是怎么引出这个信息的？ 因（相因相生）：作者有哪些关于原因的假设？怎么验证或排除这些假设？还有其他可能性吗？ 后（以观后效）：从已有信息去做之后会怎样？对我的好处（效用）是什么？ 果（自食其果）：不这么做的后果是什么？不改变的问题有多严重？ 适（适得其反）：有没有相反的观点？有没有不支持这个实现的案例(CASE to CASE)？ 用（使用条件）：要这样做，需要具备哪些条件？（考虑 成本、收益、效率、安全、态度、能力 等）这件事可以哪些方式来完成？ 边（旁敲边鼓）：从前有没有类似的（或乍看起来差不多的）信息？其他 （领域 | 行业 | 人）如 何解决类似问题呢？ 界（楚河汉界）：无论是相反的还是类似的信息，和这个信息的真正区别是什么？交界在哪里？ 应用指南 在使用八大问时，不一定要原模原样地问上面列举出的示范问题，可以在理解这八类问题的前提下，针对具体情境，提出合适的问题。也就是说，八大问最重要的是提供了一种提出有洞察力的问题的框架，这是他的意义所在。如果你有能力，可以领会心法，保持心法不变，提出新的问题。 如果一开始不知道怎么用，则建议直接使用示范问题或在其基础上做变化。欢迎一起探讨哦。","categories":[{"name":"职场","slug":"职场","permalink":"http://www.a2data.cn/categories/%E8%81%8C%E5%9C%BA/"}],"tags":[{"name":"毒鸡汤","slug":"毒鸡汤","permalink":"http://www.a2data.cn/tags/%E6%AF%92%E9%B8%A1%E6%B1%A4/"}],"author":"Jack风"},{"title":"Markdown","slug":"Tools/Markdown","date":"2019-11-11T12:43:06.000Z","updated":"2025-05-04T18:37:40.531Z","comments":true,"path":"posts/17683.html","link":"","permalink":"http://www.a2data.cn/posts/17683.html","excerpt":"‘MD,原来是这么用的，你懂了吗？’","text":"‘MD,原来是这么用的，你懂了吗？’ MarkDown 用法精选Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。 强力推荐: TproaMarkDown编辑器跨平台 完美运行. Hexo```MHexoEditor编辑器博客好助手 完美支持 Hexo 博文. 优点：1、因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。2、操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而Markdown只需要在标题内容前加#即可 缺点：1、需要记一些语法（当然，是很简单。五分钟学会）。2、有些平台不支持Markdown编辑模式。 一、标题 在想要设置为标题的文字前面加#来表示一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。 示例：# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 效果如下： # 如上是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是五级标题 ###### 这是六级标题 二、字体 加粗要加粗的文字左右分别用两个号包起来斜体要倾斜的文字左右分别用一个号包起来斜体加粗要倾斜和加粗的文字左右分别用三个*号包起来删除线要加删除线的文字左右分别用两个~~号包起来 示例： **这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~ 效果如下：这是加粗的文字这是倾斜的文字`这是斜体加粗的文字这是加删除线的文字 三、引用块 在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;n个…貌似可以一直加下去，但没神马卵用 示例： &gt;这是引用的内容 &gt;&gt;这是引用的内容 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 效果如下： 这是引用的内容 这是引用的内容 这是引用的内容 四、分割线三个或者三个以上的 - 或者 * 都可以。 示例： --- ---- *** ***** 效果如下： 可以看到，显示效果是一样的。 五、图片语法： ![图片alt](图片地址 &#39;&#39;图片title&#39;&#39;) 图片alt就是显示在图片下面的文字，相当于对图片内容的解释。 图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例： ![img][A2DATA](/resource/image/markdown/1.png) 效果如下： - hexo 3 &#123;% asset_img test.jpg This is an test image %&#125; 上传本地图片直接点击导航栏的图片标志，选择图片即可 六、超链接语法： [超链接名](超链接地址 &quot;超链接title&quot;) title可加可不加 示例： [简书](http://jianshu.com) [百度](http://baidu.com) 效果如下： 简书百度 注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。 &lt;a href=&quot;超链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt; 示例 &lt;a href=&quot;https://www.baidu.com&quot; target=&quot;_blank&quot;&gt;百度&lt;/a&gt; 七、列表 无序列表 语法： 无序列表用 - + * 任何一种都可以 - 列表内容 + 列表内容 * 列表内容 注意：- + * 跟内容之间都要有一个空格 效果如下： 列表内容 列表内容 列表内容 有序列表 语法： 数字加点 1.列表内容 2.列表内容 3.列表内容 注意：序号跟内容之间要有空格 效果如下： 1.列表内容 2.列表内容 3.列表内容 列表嵌套 上一级和下一级之间敲三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 一级有序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级有序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 八、表格语法： 表头|表头|表头 ---|:--:|---: 内容|内容|内容 内容|内容|内容 第二行分割表头和内容。 - 有一个就行，为了对齐，多加了几个 文字默认居左 -两边加：表示文字居中 -右边加：表示文字居右 注：原生的语法两边都要用 | 包起来。此处省略 示例： 姓名|技能|排行 |--|:--:|--:| |欢迎|关注|微信| |公号|平台|A2DATA| |我们|一起|加油| 效果如下： I II III 欢迎 关注 微信 公号 平台 DataScience 我们 一起 加油 九、代码语法： 单行代码：代码之间分别用一个反引号包起来 `代码内容` 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 (```) 代码... 代码... 代码... (```) 注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。 示例： 单行代码 `create database hero;` 代码块 (```) function fun()&#123; echo &quot;这是一句非常牛逼的代码&quot;; &#125; fun(); (```) 效果如下： 单行代码 create database hero; 代码块 function fun()&#123; echo &quot;这是一句非常牛逼的代码&quot;; &#125; fun(); 十、流程图 横向流程图 graph LR A[方形] --&gt;B(圆角) B --&gt; C&#123;条件a&#125; C --&gt;|a=1| D[结果1] C --&gt;|a=2| E[结果2] F[横向流程图] 竖向流程图 graph TD A[方形] --&gt;B(圆角) B --&gt;C&#123;条件a&#125; C --&gt;|a=1|D[结果1] C --&gt;|a=2|E[结果2] F[竖向流程图] 效果如下： graph LR start[开始] --&gt; input[输入A,B,C] input --&gt; conditionA&#123;A是否大于B&#125; conditionA -- YES --&gt; conditionC&#123;A是否大于C&#125; conditionA -- NO --&gt; conditionB&#123;B是否大于C&#125; conditionC -- YES --&gt; printA[输出A] conditionC -- NO --&gt; printC[输出C] conditionB -- YES --&gt; printB[输出B] conditionB -- NO --&gt; printC[输出C] printA --&gt; stop[结束] printC --&gt; stop printB --&gt; stop","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/categories/Tools/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/tags/Tools/"}]},{"title":"Strive","slug":"Tools/strive","date":"2019-11-04T14:11:30.000Z","updated":"2020-08-07T10:29:35.053Z","comments":true,"path":"posts/18321.html","link":"","permalink":"http://www.a2data.cn/posts/18321.html","excerpt":"‘在你牛到一定程度前,所有的一切全是态度问题。’","text":"‘在你牛到一定程度前,所有的一切全是态度问题。’ 你为什么[努力]? 一位麦肯斯7年老员工的忠告：所谓的能力问题，全都是态度问题！ 态度哪有那么多「能力问题」，在你牛到一定程度前，全是「态度问题」 职场上有句话，「ta这是能力问题，工作态度还是好的」。 通常做得不够好的时候，「能力问题」似乎就比较容易得到谅解。 我承认，时代、机缘、天赋、性格、出身、早年教育，等等这些我们无法全然掌控的因素，关系重大，或许将我们的个人「能力」划定在某个范围内。 生活，是公平的，你选择了自己轻松，那你身边的家人一定会为你的选择付出成本和代价。 有些事情，你尝试了不一定可以成功，但是你不尝试，肯定是一丝可能都没有。· 努力的理由最近突然明白，一个人努力的理由是什么。 是为了在看到自己喜欢的东西时，毫不犹豫拿起就付款的大方样子； 是为了想去一个地方时再也不用精打细算的计划费用，而是领包就走毫无顾虑的潇洒样子； 是为了遇到自己喜欢的人，再也不用担心自己配不上对方，而是在对方面前自信满满的样子； 是为了过再也不用对别人点头哈腰的日子。 总结起来，就是一句话： 我之所以这么努力， 是为了能过上自己想要的生活， 能与自己所爱的人自信满满的打招呼， 而不是畏首畏尾，连说句“你好”都觉得卑微。 梦在远方，路在脚下 这世界上 从来没有谁能够 随随便便成功 天才也需要99%汗水的付出 相信自己可以去改变境遇，有这点志气，才能有撸起袖子去行动的能力。 正如瑞达利欧在《原则》中所写： 没有什么比「明白现实世界如何运作」并且「如何应对它」更重要的事，而你在这个过程中的心态，决定了所有的差别。 生活不止眼前的苟且，还有远方的苟且。","categories":[{"name":"职场","slug":"职场","permalink":"http://www.a2data.cn/categories/%E8%81%8C%E5%9C%BA/"}],"tags":[{"name":"毒鸡汤","slug":"毒鸡汤","permalink":"http://www.a2data.cn/tags/%E6%AF%92%E9%B8%A1%E6%B1%A4/"}]},{"title":"SublimeText","slug":"Tools/SublimeText","date":"2019-09-23T14:17:10.000Z","updated":"2020-08-07T10:18:18.005Z","comments":true,"path":"posts/55860.html","link":"","permalink":"http://www.a2data.cn/posts/55860.html","excerpt":"超级编辑器","text":"超级编辑器 SublimeText 必备插件第一步 安装 Package Control组件快捷键 Ctrl+` import urllib.request,os; pf = &#39;Package Control.sublime-package&#39;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), &#39;wb&#39;).write(urllib.request.urlopen( &#39;http://sublime.wbond.net/&#39; + pf.replace(&#39; &#39;,&#39;%20&#39;)).read()) 如果在Perferences-&gt;中看到package control这一项，则安装成功。 解决中文乱码问题Mac 快捷键： Cmd+ shift + p Windows : Ctrl + shift + p 1、打开 package control 2、输入： Install Package 3、安装 ： ConvertToUTF8插件 主题安装 Material theme 主题 安装方法：Ctrl(Mac下Cmd)+Shift+P install package -&gt; Material Theme install package -&gt; A File Icon 字体 装好又到之前的 首选项—–用户设置（user ）：选择字体：如果存在就修改为Fira Code，不存在就添加下面这行代码， &quot;font_face&quot;: &quot;Fira Code&quot; 至此大功告成，谢谢 字体安装路径 C:\\Users\\Desktop\\FiraCode-master\\FiraCode-master\\distr\\ttf FiraCode-master 字体下载已经上传到微云 更多骚操作等待你一起探讨哦 如需破解广告版本，请添加微信公众号：A2Data 联系小编获取哦。","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/categories/Tools/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/tags/Tools/"}]},{"title":"Linux安装","slug":"Linux/Linux安装","date":"2019-09-13T11:15:31.000Z","updated":"2020-09-11T08:45:44.385Z","comments":true,"path":"posts/43150.html","link":"","permalink":"http://www.a2data.cn/posts/43150.html","excerpt":"linux介绍及安装","text":"linux介绍及安装 一、Linux简介linux是一种由unix衍生出来的操作系统，，操作系统是用户和计算机之间的界面. 一方面操作系统管理着所有计算机系统资源,另一方面操作系统为用户提供了一个抽象概念上的计算机. 在操作系统的帮助下, 用户使用计算机时,避免了对计算机系统硬件的直接操作.二、Linux国内流行版本介绍1、Redhat2、CentOS3、Suse4、红旗（redflag）三、Linux 优点 1.稳定2.多线程3.架构可扩展4.开源5.简单（IT）四、Linux 缺点 1.技术要求相对较强2.图形界面不够好五、安装安装RedHat系统的方法有很多种，我们主要介绍如何使用光盘安装方法安装RedHat系统。既然说Linux是一种操作系统那么最常用的操作系统就是windows日常生活中它是一般装到我们的pc上的，大多数的企业会使用Linux系统装在服务器上的，所以为了模拟环境我们用了一个软件叫做VMware它能够帮我们实现一个虚拟的网络环境还支持很多系统，下面我们就来安装一下Redhat6.4准备镜像rhel-server-6.4-x86_64-dvd.iso首先安装VMware这个直接去网上下载安装就好 安装好以后我们会看见一下这个界面建议大家使用英文版的，在企业工作大多数都是英文，先熟悉一下环境 1、首先我们新建一个虚拟机 2、选择典型 3、选择稍后安装操作系统，后期我们自己挂载镜像 4、接下来选择linux的版本，根据自己下载的镜像版本而定 5、下一步给虚拟机取一个名字，给它一个存放路径，注意：路径最好不要出现中文 6、下面是磁盘大小和，将虚拟磁盘统一成一个文件 7、检查一下如果没有问题点击finish 8、在左上方会出现一个linux这就是我们即将安装的虚拟机，然后选择镜像 9、把开始下载的镜像路径添加到上面点击ok 10、然后运行此虚拟机 Linux安装1、选择第一项，然后回车： 2、跳过光盘质量测试提示上一步回车后，将出现下面的界面，使用“Tab”键切换到“Skip”，然后回车： 3、点击next如果鼠标不能移动可用Ctrl+Alt进行切换 4、选择安装过程使用的语言选择安装过程使用的语言：中文(简体)，然后点“Next”（还是建议大家使用英文的，这里为了方便讲解就用中文了） 5、设置键盘设置键盘为“美国英语式”，然后点“下一步”： 6、选择系统使用的存储设备一般情况，均默认选择“基本存储设备”，然后点“下一步”： 7、出现下图提示时，点击“是，忽略所有数据”： 8、设置计算机名可根据实际情况，对计算机主机名进行命名也可以安装好后用命令行进行更改 9、配置网络点击界面左下角的“配置网络”，配置服务器网络：选中eth0进行配置 点击“编辑” 勾上“自动连接” 选择“IPv4设置”选项卡，“方法”选择“手动” 点击“添加” 分别点击并配置“地址”、“子网掩码”、“网关” 填上“DNS服务器”地址（如果没有可不填，多个DNS用逗号分隔） 点击“应用”完成配置可参考下图： 选择系统时区时区默认为“亚洲/上海”，注意需要去掉“系统时钟使用UTC时间”前面的勾，然后点“下一步”： 设置root账户密码建议输入一个复杂组合的密码，密码包含：大写、小写、数字、符号 10、磁盘分区创建自定义布局分区 10.1、创建第1个分区（启动分区）： 10.2、配置1.“挂载点”选择“/boot”2.“大小(MB)”填入“300”3.点击“确定” 10.3 创建第2个分区（主分区）1.“挂载点”选择“/home”2.“大小(MB)”填入“8000”（根据实际硬盘大小填写）3.点击“确定” 11、重复创建步骤1.“文件系统类型”选择“swap”2.“大小(MB)”填入“800”（根据实际内存大小填写，一般为内存的1.5-2倍，不大于8G）3.点击“确定”创建第4个分区（根分区）：重复创建步骤1.“挂载点”选择“/”2.勾选“使用全部可用分区”3.点击“确定” 点击下一步进行格式化 点击修改写入磁盘 只有一个盘所以点击下一步即可 基础软件安装 各项包含软件Desktop :基本的桌面系统，包括常用的桌面软件，如文档查看工具。Minimal Desktop :基本的桌面系统，包含的软件更少。Minimal :基本的系统，不含有任何可选的软件包。Basic Server：安装的基本系统的平台支持，不包含桌面。Database Server :基本系统平台，加上mysql和PostgreSQL数据率，无桌面。Web Server :基本系统平台，加上PHP, Web server，还有mysqI和PostgreSQL数据库的客户端，无桌面。Virtual Host :基本系统加虚拟化平台。Software Development Workstation :包含的软件包较多，基本系统，虚拟化平台，桌面环境，开发工具。注意：我们一般运行的时候都不会使用桌面，这里我们就不安装桌面了，其他的软件后期需要我们也可以再安装。 勾选ftp服务器 点击下一步开始安装 至此完成安装 进入系统 出现以下界面证明你成功了 使用root用户，输入你的密码就可以使用了","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"}],"tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://www.a2data.cn/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"}]},{"title":"Hexo图片问题","slug":"Hexo/Hexo图片问题","date":"2019-09-05T15:41:52.000Z","updated":"2025-05-05T06:08:16.270Z","comments":true,"path":"posts/ee789513.html","link":"","permalink":"http://www.a2data.cn/posts/ee789513.html","excerpt":"Hexo 上传图片相关的问题。","text":"Hexo 上传图片相关的问题。 使用hexo上传图片，但是发现在文章中引用本地图片时总是显示不出来。花费了许久时间才解决这个问题。因此将一些解决经验整理出来，希望能帮助到大家。 一、插件安装与配置 首先我们需要安装一个图片路径转换的插件，这个插件名字是hexo-asset-image npm install https://github.com/CodeFalling/hexo-asset-image --save 但是这个插件的内容需要修改【不然可能会出Bug】 打开/node_modules/hexo-asset-image/index.js，将内容更换为下面的代码 &#39;use strict&#39;; var cheerio = require(&#39;cheerio&#39;); // http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string function getPosition(str, m, i) &#123; return str.split(m, i).join(m).length; &#125; var version = String(hexo.version).split(&#39;.&#39;); hexo.extend.filter.register(&#39;after_post_render&#39;, function(data)&#123; var config = hexo.config; if(config.post_asset_folder)&#123; var link = data.permalink; if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, &#39;/&#39;, 1) + 1; else var beginPos = getPosition(link, &#39;/&#39;, 3) + 1; // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;. var endPos = link.lastIndexOf(&#39;/&#39;) + 1; link = link.substring(beginPos, endPos); var toprocess = [&#39;excerpt&#39;, &#39;more&#39;, &#39;content&#39;]; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $(&#39;img&#39;).each(function()&#123; if ($(this).attr(&#39;src&#39;))&#123; // For windows style path, we replace &#39;\\&#39; to &#39;/&#39;. var src = $(this).attr(&#39;src&#39;).replace(&#39;\\\\&#39;, &#39;/&#39;); if(!/http[s]*.*|\\/\\/.*/.test(src) &amp;&amp; !/^\\s*\\//.test(src)) &#123; // For &quot;about&quot; page, the first part of &quot;src&quot; can&#39;t be removed. // In addition, to support multi-level local directory. var linkArray = link.split(&#39;/&#39;).filter(function(elem)&#123; return elem != &#39;&#39;; &#125;); var srcArray = src.split(&#39;/&#39;).filter(function(elem)&#123; return elem != &#39;&#39; &amp;&amp; elem != &#39;.&#39;; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join(&#39;/&#39;); $(this).attr(&#39;src&#39;, config.root + link + src); console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125; &#125;); 打开根目录下的_config.yml文件，修改下述内容post_asset_folder: true 二、问题推测1、本地图片没有有效的上传至github仓库中，导致引用无效解决方案，安装插件，请看上文如何安装 2、本地图片没有存放在同名文件夹下解决方案，将需要引用的本地图片存放在与文章名相同的文件夹中 3、图片路径出错这里多数人可能会将url 写成自己的域名。 切记：需要写成自己github项目的地址。我刚开始也错了。 4、相对路径引用的标签插件 通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。 也就是说在存档页和主页不能使用和文章内容中的常规语法来引用图片。 比如说：当你打开文章资源文件夹功能后，你把一个 example.jpg 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 ![](/a2data.jpg) ，它将 不会 出现在首页上。（但是它会在文章中按你期待的方式工作） 正确的引用图片方式是使用下列的标签插件而不是 markdown ：———————————————— &#123;% asset_img example.jpg This is an example image %&#125; 这是一个MD引入图片 这是标签引用方式","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.a2data.cn/tags/Hexo/"}]}],"categories":[{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/categories/Python/"},{"name":"Python入门","slug":"Python/Python入门","permalink":"http://www.a2data.cn/categories/Python/Python%E5%85%A5%E9%97%A8/"},{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/categories/Java/"},{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/categories/Tools/"},{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/categories/Linux/"},{"name":"Python速成","slug":"Python/Python速成","permalink":"http://www.a2data.cn/categories/Python/Python%E9%80%9F%E6%88%90/"},{"name":"职场","slug":"职场","permalink":"http://www.a2data.cn/categories/%E8%81%8C%E5%9C%BA/"}],"tags":[{"name":"数据可视化","slug":"数据可视化","permalink":"http://www.a2data.cn/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"},{"name":"Tools","slug":"Tools","permalink":"http://www.a2data.cn/tags/Tools/"},{"name":"Linux","slug":"Linux","permalink":"http://www.a2data.cn/tags/Linux/"},{"name":"Win10","slug":"Win10","permalink":"http://www.a2data.cn/tags/Win10/"},{"name":"Edge","slug":"Edge","permalink":"http://www.a2data.cn/tags/Edge/"},{"name":"数仓","slug":"数仓","permalink":"http://www.a2data.cn/tags/%E6%95%B0%E4%BB%93/"},{"name":"Windows","slug":"Windows","permalink":"http://www.a2data.cn/tags/Windows/"},{"name":"任务栏神器","slug":"任务栏神器","permalink":"http://www.a2data.cn/tags/%E4%BB%BB%E5%8A%A1%E6%A0%8F%E7%A5%9E%E5%99%A8/"},{"name":"Python","slug":"Python","permalink":"http://www.a2data.cn/tags/Python/"},{"name":"Git","slug":"Git","permalink":"http://www.a2data.cn/tags/Git/"},{"name":"Hexo","slug":"Hexo","permalink":"http://www.a2data.cn/tags/Hexo/"},{"name":"Anaconda","slug":"Anaconda","permalink":"http://www.a2data.cn/tags/Anaconda/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://www.a2data.cn/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"Java","slug":"Java","permalink":"http://www.a2data.cn/tags/Java/"},{"name":"图床","slug":"图床","permalink":"http://www.a2data.cn/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"Redis","slug":"Redis","permalink":"http://www.a2data.cn/tags/Redis/"},{"name":"Hadoop","slug":"Hadoop","permalink":"http://www.a2data.cn/tags/Hadoop/"},{"name":"资料分享","slug":"资料分享","permalink":"http://www.a2data.cn/tags/%E8%B5%84%E6%96%99%E5%88%86%E4%BA%AB/"},{"name":"MapReduce","slug":"MapReduce","permalink":"http://www.a2data.cn/tags/MapReduce/"},{"name":"面经","slug":"面经","permalink":"http://www.a2data.cn/tags/%E9%9D%A2%E7%BB%8F/"},{"name":"Python习题","slug":"Python习题","permalink":"http://www.a2data.cn/tags/Python%E4%B9%A0%E9%A2%98/"},{"name":"毒鸡汤","slug":"毒鸡汤","permalink":"http://www.a2data.cn/tags/%E6%AF%92%E9%B8%A1%E6%B1%A4/"}]}